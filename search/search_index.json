{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"narrowgate \u00a4 Python-based tools for Feature Screening intended for use with high-dimensional and time series data. accelerated with Numba Overview \u00a4 Enter through the narrow gate. For wide is the gate and broad is the road that leads to destruction, and many enter through it. But small is the gate and narrow the road that leads to life, and only a few find it. -- Matthew 7:13-14 There are a lot of ways for a practitioner to get confused, and lost when analyzing and modeling high-dimensional data. However, with the right tools, process, and discipline. any fear or anxiety is replaced with increased confidence and peace, and robust insights are derived almost magically. The tools and methods implemented within this package are meant to serve as a starting point for predictive modeling efforts with high-dimensional tabular and/or time series data. By focusing on meaningful and relevant processes and robust statistical metrics, the data science practitioner can be more confident that the \"narrow gate\" is being entered before any predictive modeling efforts begin. Installation \u00a4 pip \u00a4 pip install narrowgate conda \u00a4 conda config --add channels conda-forge conda config --set channel_priority strict conda install narrowgate development (github) \u00a4 It is assumed that you have the git version control system and the necessary dependent libraries installed. git clone https://github.com/narrowgateai/narrowgate.git cd narrowgate python setup.py develop Quickstart Examples \u00a4 The library is divided into the following functional categories: Encoders Model Selection Models Screeners NOTE: Out of respect for Dr. Masters (see Background ) and the numerous books he has written describing the algorithms implemented in this package, any documentation and corresponding examples will be primarily descriptive in nature. For an in-depth explanation of the implemented algorithms and/or a more meaningful explanation of metrics and exploratory processes, the practitioner is, once again, referred to the texts referenced in the Background section of this document. Encoders \u00a4 The functionality present within this category coincides with similar classes and functionality present within the sklearn.preprocessing sub-module. Nominal2OrdinalEncoder \u00a4 Encodes categorical features to a numerical value based on a numerical target variable. Utilizes percent-ranked values of the target variable rather than the raw numerical target values in an effort to minimize outlier impact. Similar to ' TargetEncoding ' functionality. Model Selection \u00a4 Contains functionality similar to what is present in the sklearn.model_selection sub-module. WalkforwardTimeSeriesCV \u00a4 An Enhanced TimeSeriesSplit class that utilizes a Pandas DatetimeIndex to split temporal data into train/test data sets working backwards through time, and thereby, maximizing usage of the most recent data. By utilizing the DatetimeIndex, the splitting behavior of the class insures cohorts of observations with the same granularity column value will be grouped together in the same train/test data split. CombinatorialPurgedCrossValidation \u00a4 Implementation of a more robust cross-validation method. Originally developed by Marcos Lopez de Prado, et. al, and described in Chapter 12 of the book, Advances in Financial Machine Learning. Models \u00a4 Contains modeling functionality adhering to the fit and predict paradigm within the scikit-learn package. LinearRegression_nb \u00a4 A numba.jitclass implementation of the traditional LinearRegression modeling method. supports the capability for embedding within a numba.prange loop, thereby allowing high-performance, multi-threaded execution. HMM_nb \u00a4 A numba.jitclass implementation of a Hidden Markov Model Screeners \u00a4 Contains functionality that can be used for feature evaluation, selection and/or filtering. UnivariateScreener \u00a4 calculates information-related measures between individual predictor variables and a target variable performs Monte Carlo Permutation Testing to help determine likelihood that calculated information measure of a predictor variable is superior to a predictor variable which possesses a random relationship with the target variable. supports the following discretization and continuous information measures: Mutual Information Uncertainty Reduction Cramer's V Pearson correlation Spearman rank correlation leverages Combinatorially Symmetric Cross Validation (CSCV) and out-of-sample performance to assist in determining superiority of an individual predictor variable in relation to all potential predictor variables in a given data set. BivariateScreener \u00a4 similar to above-described UnivariateScreener functionality, but instead, assesses the interaction effect of two variables in relation to a target variable. supports the following discretization-based information measures: Mutual Information Uncertainty Reduction FSCA \u00a4 Forward Selection Component Analysis An extension of the classic Principal Component Analysis (PCA) implementation with built-in feature selection capability. Assists the practitioner in identifying a fixed number of individual variables within a data set which contribute to a significant amount of the data set's explained variance. contains a cluster method to assist the practitioner in easily identifying and grouping highly similar (correlated) variables with one another. contains separate SelectorMixin and TranformerMixin classes for use within scikit-learn's Pipeline constructor. EnhancedStepwiseScreener \u00a4 Performs forward, step-wise feature selection utilizing an underlying linear-quadratic regression model. retains a user-specified number of best performing variable subsets upon each added feature to the model. performs Monte Carlo Permutation Testing at each new feature addition step to help determine whether any increased performance is truly worthwhile or, perhaps, just random. automatically stops step-wise addition of features if the addition of a new feature causes the model to perform worse or any performance gains are evaluated to be random in nature. contains a SelectorMixin extension for use within scikit-learn Pipeline constructors ( EnhancedStepwiseFeatureSelector ) HMMTargetLinkScreener \u00a4 Time-series based feature-screening method utilizing state probabilities from Hidden Markov Models (HMM). Hidden Markov Models and their resulting state probabilities are derived from predictor variable combinations independent of the target variable. State probabilities are, then, used as feature inputs to a linear-quadratic regression model on a continuous target variable. supports Monte Carlo Permutation Testing in order to help assess if predictive performance of any HMM model is truly superior or if the performance should simply be attributed to good luck. HMMMemoryScreener \u00a4 complement to HMMTargetLinkScreener assesses whether a Hidden Markov model produced by a combination of variables possesses meaningful HMM memory for use in a predictive model supports Monte Carlo Permutation Testing to help assess if the HMM's memory is truly meaningful or if it is purely random in nature. Background \u00a4 The majority of the screening tools/methods implemented within this library are documented heavily in multiple texts written by Dr. Timothy Masters. For a list of these texts and more information, please visit his website or the following links: Assessing and Improving Prediction and Classification Data Mining Algorithms in C++ Modern Data Mining Algorithms in C++ and CUDA C Please note that this repository is in no way affiliated with Dr. Masters and, subsequently, any views or opinions expressed herein are solely the views/opinions of the repository developer(s). Dr. Masters was a long-time consultant in the financial markets domain. As a result, he developed many novel methods to assist in identifying predictor variables with the highest probability of signal in relation to a target variable. His methods address efficiently and robustly quantifying the strength of a predictor variable when: evaluation of thousands of predictor variables are desired the signal-to-noise ratio of the problem space is extremely low. While many 'feature importance' and 'explainability' methods currently exist within the Python machine learning ecosystem, the methods present within this package are uniquely developed to assist the practitioner in: quantifying the impact of predictor variables in relation to a target variable using multiple information-theoretic metrics calculate p-values to serve as an indication of confidence that any detected predictive impact is truly non-random in nature. Numba usage \u00a4 A large portion of functionality within this repository has been implemented using the Numba Python package for increased performance. Specifically, the functions have been implemented such that they are ' just-in-time ' (JIT) compiled in ' nopython ' mode in order to achieve as close to C/C++ level performance as possible. Implementing the algorithms under this paradigm allows for the use of Numba's CPU ParallelAccelerator functionality in order to achieve among the fastest multi-threading capability within the Python language as possible. As a result, the first time many of these methods are executed, increased execution time will be experienced by the user as the functions will need to be compiled specifically for each user's system. Substantially decreased execution time should be experienced by the user on any subsequent numba-based function calls. CPU/GPU \u00a4 An additional benefit to using Numba is the capability of writing native Python code for highly parallelized execution on the GPU . The majority of functionality present within this package currently only supports execution on a user's CPU. However, future package enhancements include supporting identical operations on either the CPU or GPU. Documentation \u00a4 For a more detailed explanation (including examples) of the functionality present within this package, please visit the narrowgate documentation .","title":"Home"},{"location":"#narrowgate","text":"Python-based tools for Feature Screening intended for use with high-dimensional and time series data. accelerated with Numba","title":"narrowgate"},{"location":"#overview","text":"Enter through the narrow gate. For wide is the gate and broad is the road that leads to destruction, and many enter through it. But small is the gate and narrow the road that leads to life, and only a few find it. -- Matthew 7:13-14 There are a lot of ways for a practitioner to get confused, and lost when analyzing and modeling high-dimensional data. However, with the right tools, process, and discipline. any fear or anxiety is replaced with increased confidence and peace, and robust insights are derived almost magically. The tools and methods implemented within this package are meant to serve as a starting point for predictive modeling efforts with high-dimensional tabular and/or time series data. By focusing on meaningful and relevant processes and robust statistical metrics, the data science practitioner can be more confident that the \"narrow gate\" is being entered before any predictive modeling efforts begin.","title":"Overview"},{"location":"#installation","text":"","title":"Installation"},{"location":"#pip","text":"pip install narrowgate","title":"pip"},{"location":"#conda","text":"conda config --add channels conda-forge conda config --set channel_priority strict conda install narrowgate","title":"conda"},{"location":"#development-github","text":"It is assumed that you have the git version control system and the necessary dependent libraries installed. git clone https://github.com/narrowgateai/narrowgate.git cd narrowgate python setup.py develop","title":"development (github)"},{"location":"#quickstart-examples","text":"The library is divided into the following functional categories: Encoders Model Selection Models Screeners NOTE: Out of respect for Dr. Masters (see Background ) and the numerous books he has written describing the algorithms implemented in this package, any documentation and corresponding examples will be primarily descriptive in nature. For an in-depth explanation of the implemented algorithms and/or a more meaningful explanation of metrics and exploratory processes, the practitioner is, once again, referred to the texts referenced in the Background section of this document.","title":"Quickstart Examples"},{"location":"#encoders","text":"The functionality present within this category coincides with similar classes and functionality present within the sklearn.preprocessing sub-module.","title":" Encoders"},{"location":"#nominal2ordinalencoder","text":"Encodes categorical features to a numerical value based on a numerical target variable. Utilizes percent-ranked values of the target variable rather than the raw numerical target values in an effort to minimize outlier impact. Similar to ' TargetEncoding ' functionality.","title":"Nominal2OrdinalEncoder"},{"location":"#model-selection","text":"Contains functionality similar to what is present in the sklearn.model_selection sub-module.","title":" Model Selection"},{"location":"#walkforwardtimeseriescv","text":"An Enhanced TimeSeriesSplit class that utilizes a Pandas DatetimeIndex to split temporal data into train/test data sets working backwards through time, and thereby, maximizing usage of the most recent data. By utilizing the DatetimeIndex, the splitting behavior of the class insures cohorts of observations with the same granularity column value will be grouped together in the same train/test data split.","title":"WalkforwardTimeSeriesCV"},{"location":"#combinatorialpurgedcrossvalidation","text":"Implementation of a more robust cross-validation method. Originally developed by Marcos Lopez de Prado, et. al, and described in Chapter 12 of the book, Advances in Financial Machine Learning.","title":"CombinatorialPurgedCrossValidation"},{"location":"#models","text":"Contains modeling functionality adhering to the fit and predict paradigm within the scikit-learn package.","title":" Models"},{"location":"#linearregression_nb","text":"A numba.jitclass implementation of the traditional LinearRegression modeling method. supports the capability for embedding within a numba.prange loop, thereby allowing high-performance, multi-threaded execution.","title":"LinearRegression_nb"},{"location":"#hmm_nb","text":"A numba.jitclass implementation of a Hidden Markov Model","title":"HMM_nb"},{"location":"#screeners","text":"Contains functionality that can be used for feature evaluation, selection and/or filtering.","title":" Screeners"},{"location":"#univariatescreener","text":"calculates information-related measures between individual predictor variables and a target variable performs Monte Carlo Permutation Testing to help determine likelihood that calculated information measure of a predictor variable is superior to a predictor variable which possesses a random relationship with the target variable. supports the following discretization and continuous information measures: Mutual Information Uncertainty Reduction Cramer's V Pearson correlation Spearman rank correlation leverages Combinatorially Symmetric Cross Validation (CSCV) and out-of-sample performance to assist in determining superiority of an individual predictor variable in relation to all potential predictor variables in a given data set.","title":"UnivariateScreener"},{"location":"#bivariatescreener","text":"similar to above-described UnivariateScreener functionality, but instead, assesses the interaction effect of two variables in relation to a target variable. supports the following discretization-based information measures: Mutual Information Uncertainty Reduction","title":"BivariateScreener"},{"location":"#fsca","text":"Forward Selection Component Analysis An extension of the classic Principal Component Analysis (PCA) implementation with built-in feature selection capability. Assists the practitioner in identifying a fixed number of individual variables within a data set which contribute to a significant amount of the data set's explained variance. contains a cluster method to assist the practitioner in easily identifying and grouping highly similar (correlated) variables with one another. contains separate SelectorMixin and TranformerMixin classes for use within scikit-learn's Pipeline constructor.","title":"FSCA"},{"location":"#enhancedstepwisescreener","text":"Performs forward, step-wise feature selection utilizing an underlying linear-quadratic regression model. retains a user-specified number of best performing variable subsets upon each added feature to the model. performs Monte Carlo Permutation Testing at each new feature addition step to help determine whether any increased performance is truly worthwhile or, perhaps, just random. automatically stops step-wise addition of features if the addition of a new feature causes the model to perform worse or any performance gains are evaluated to be random in nature. contains a SelectorMixin extension for use within scikit-learn Pipeline constructors ( EnhancedStepwiseFeatureSelector )","title":"EnhancedStepwiseScreener"},{"location":"#hmmtargetlinkscreener","text":"Time-series based feature-screening method utilizing state probabilities from Hidden Markov Models (HMM). Hidden Markov Models and their resulting state probabilities are derived from predictor variable combinations independent of the target variable. State probabilities are, then, used as feature inputs to a linear-quadratic regression model on a continuous target variable. supports Monte Carlo Permutation Testing in order to help assess if predictive performance of any HMM model is truly superior or if the performance should simply be attributed to good luck.","title":"HMMTargetLinkScreener"},{"location":"#hmmmemoryscreener","text":"complement to HMMTargetLinkScreener assesses whether a Hidden Markov model produced by a combination of variables possesses meaningful HMM memory for use in a predictive model supports Monte Carlo Permutation Testing to help assess if the HMM's memory is truly meaningful or if it is purely random in nature.","title":"HMMMemoryScreener"},{"location":"#background","text":"The majority of the screening tools/methods implemented within this library are documented heavily in multiple texts written by Dr. Timothy Masters. For a list of these texts and more information, please visit his website or the following links: Assessing and Improving Prediction and Classification Data Mining Algorithms in C++ Modern Data Mining Algorithms in C++ and CUDA C Please note that this repository is in no way affiliated with Dr. Masters and, subsequently, any views or opinions expressed herein are solely the views/opinions of the repository developer(s). Dr. Masters was a long-time consultant in the financial markets domain. As a result, he developed many novel methods to assist in identifying predictor variables with the highest probability of signal in relation to a target variable. His methods address efficiently and robustly quantifying the strength of a predictor variable when: evaluation of thousands of predictor variables are desired the signal-to-noise ratio of the problem space is extremely low. While many 'feature importance' and 'explainability' methods currently exist within the Python machine learning ecosystem, the methods present within this package are uniquely developed to assist the practitioner in: quantifying the impact of predictor variables in relation to a target variable using multiple information-theoretic metrics calculate p-values to serve as an indication of confidence that any detected predictive impact is truly non-random in nature.","title":" Background"},{"location":"#numba-usage","text":"A large portion of functionality within this repository has been implemented using the Numba Python package for increased performance. Specifically, the functions have been implemented such that they are ' just-in-time ' (JIT) compiled in ' nopython ' mode in order to achieve as close to C/C++ level performance as possible. Implementing the algorithms under this paradigm allows for the use of Numba's CPU ParallelAccelerator functionality in order to achieve among the fastest multi-threading capability within the Python language as possible. As a result, the first time many of these methods are executed, increased execution time will be experienced by the user as the functions will need to be compiled specifically for each user's system. Substantially decreased execution time should be experienced by the user on any subsequent numba-based function calls.","title":"Numba usage"},{"location":"#cpugpu","text":"An additional benefit to using Numba is the capability of writing native Python code for highly parallelized execution on the GPU . The majority of functionality present within this package currently only supports execution on a user's CPU. However, future package enhancements include supporting identical operations on either the CPU or GPU.","title":"CPU/GPU"},{"location":"#documentation","text":"For a more detailed explanation (including examples) of the functionality present within this package, please visit the narrowgate documentation .","title":"Documentation"},{"location":"encoders/nom_ord/","text":"Nominal2OrdinalEncoder \u00a4 Nominal2OrdinalEncoder () Bases: TransformerMixin , BaseEstimator The Nominal2Ordinal encoder functions very much like a target encoder. However, rather than using the raw target variable values to calculate the numerically-encoded replacement value for the nominal (categorical) predictor variable, percent-ranked values of the target variable are used instead. This helps minimize the encoding effect of any outlier values in the target variable series. Because the percent-ranked values of the target variable are used in the calculation, Nominal2Ordinal encoding will only work in situations where the target variable is, itself, continuous or ordinal in nature. Therefore, multi-class classification tasks, where the target is categorical and numerical ordering is non-sensical, are not supported with this numerical encoding method. However, please note that the target variable used in the encoding does not have to be the actual target variable used when building a predictive model. Instead, the encoding target variable may be another predictor variable in the dataset that is continuous and known to be highly informationally related to the target variable used when a predictive model is built. In such a situation, a Nominal2Ordinal encoder could be used in a multi-class classification task 'by proxy' if an information-based profiling process (such as UnivariateScreener) is first executed and a highly-informative continuous predictor variable is discovered. The following methods are present in the original class described in the cited reference but are not presently implemented within this class: print_counts train mcpt print_ranks create (adds new feature to database) - not needed References \u00a4 Masters, Timothy. (2019) \"Extracting and Selecting Features for Data Mining: Algorithms in C++ and CUDA\". pp. 217-242 Source code in narrowgate/encoders/nom_ord.py 50 51 def __init__ ( self ): pass fit \u00a4 fit ( X , y , columns = 'auto' , smoothing_min_obs = 30 , gate = None ) Fit the encoder to predictor variable X and target variable y Parameters: Name Type Description Default X pd . DataFrame Pandas DataFrame containing the predictor variables. required y Union [ str , pd . Series , np . array ] If 'y is a string, refers to a column in 'X' that will represent the target variable to be used in the encoding. Otherwise, y must be either a pandas Series or numpy 1D array. required columns Union [ List [ str ], str ] If \"auto\" , then non-numeric columns within X will be automatically detected and encoded. If a string or list of strings, then the designated columns will be encoded regardless of data type. 'auto' smoothing_min_obs int integer value > 1 the number of observations a category or unique value of a predictor variable must possess in order for encoded value smoothing to not take place. If fewer than this number exists, the global encoded median of values will be combined with the encoded value of the category and weighted in a manner to represent a total of smoothing_min_obs observations. Example: If smoothing_min_obs is 30, and a given category value is only present 5 times within the dataset, then the actual encoded value for the category used during transform will be the calculated encoded value with the 5 observations with a weight of 5 and the global median encoded value for all observations weighted at 25. 30 gate Union [ str , None] Not implemented The encoded value of a category when a values of a third 'gating' variable is taken into account in relation to the target variable values. None Source code in narrowgate/encoders/nom_ord.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 def fit ( self , X : pd . DataFrame , y : Union [ str , pd . Series , np . array ], columns : Union [ List [ str ], str ] = 'auto' , smoothing_min_obs : int = 30 , gate : Union [ str , None ] = None ): \"\"\" Fit the encoder to predictor variable `X` and target variable `y` Parameters ---------- X : Pandas DataFrame containing the predictor variables. y : If `'y` is a string, refers to a column in 'X' that will represent the target variable to be used in the encoding. Otherwise, `y` must be either a pandas Series or numpy 1D array. columns : If **\"auto\"**, then non-numeric columns within `X` will be automatically detected and encoded. If a string or list of strings, then the designated columns will be encoded regardless of data type. smoothing_min_obs : integer value > 1 the number of observations a category or unique value of a predictor variable must possess in order for encoded value smoothing to not take place. If fewer than this number exists, the global encoded median of values will be combined with the encoded value of the category and weighted in a manner to represent a total of smoothing_min_obs observations. Example: If smoothing_min_obs is 30, and a given category value is only present 5 times within the dataset, then the actual encoded value for the category used during `transform` will be the calculated encoded value with the 5 observations with a weight of 5 and the global median encoded value for all observations weighted at 25. gate: Not implemented The encoded value of a category when a values of a third 'gating' variable is taken into account in relation to the target variable values. \"\"\" numeric_types = \\ [ 'int16' , 'int32' , 'int64' , 'float16' , 'float32' , 'float64' ] # Validation for 'gate' self . gate_ = gate if self . gate_ is not None : raise NotImplementedError ( \"'gate' functionality is not currently implemented\" ) assert ( self . gate_ . shape [ 0 ] == X . shape [ 0 ]) unique_gate = np . unique ( self . gate_ ) if unique_gate > 3 : raise ValueError ( \"'gate' has more than 3 unique values!\" ) gate_lookup , gate_indexed_vec = \\ np . unique ( self . gate_ , return_inverse = True ) # Validation for 'X' and 'columns' parameters if isinstance ( X , pd . DataFrame ): if columns == 'auto' : # filter the non-numeric columns nominal_features = \\ X . select_dtypes ( exclude = numeric_types ) . columns . tolist () else : # 'columns' is a custom list of columns to encode if not isinstance ( columns , list ): raise AttributeError ( \"'columns' parameter must have a string value of \" + \"'auto' or must be a list of column names in 'X'\" ) else : col_diff_list = set ( columns ) - set ( X . columns ) if len ( col_diff_list ) > 0 : raise RuntimeError ( \"The following columns are not present in 'X': \" + f \" { col_diff_list } \" ) nominal_features = columns if len ( nominal_features ) == 0 : raise RuntimeError ( \"'No categorical features present in 'X'!\" ) else : raise NotImplementedError ( \"'X' must be a pandas DataFrame\" ) # Validate 'y' # either standalone Series/array or column name (string) in X if isinstance ( y , pd . Series ): assert ( y . shape [ 0 ] == X . shape [ 0 ]) if not y . dtype in numeric_types : raise TypeError ( f \"'y' series must be a numeric data type!\" ) target = y . values elif isinstance ( y , str ): if not y in X . columns : raise AttributeError ( f \"'y' parameter, { y } , is not a column in 'X'\" ) else : if not X [ y ] . dtype in numeric_types : raise TypeError ( f \"'y' series must be a numeric data type!\" ) target = X [ y ] . values elif isinstance ( y , np . array ): assert ( y . shape [ 0 ] == X . shape [ 0 ]) if not y . dtype in numeric_types : raise TypeError ( f \"'y' series must be a numeric data type!\" ) target = y . copy () else : raise AttibuteError ( \"'y' parameter must be a pandas Series, numpy array, \" + \"or column name in X\" ) self . smoothing_min_obs = smoothing_min_obs # Begin transformation process for categorical variables in X preds = X [ nominal_features ] npred = preds . shape [ 1 ] ncases = preds . shape [ 0 ] lookup_list = [] for i in range ( npred ): lookup , indexed_vec = \\ np . unique ( preds . iloc [:, i ], return_inverse = True ) lookup_list . append ( lookup ) if i == 0 : indexed_mat = indexed_vec . reshape ( - 1 , 1 ) else : indexed_mat = \\ np . hstack (( indexed_mat , indexed_vec . reshape ( - 1 , 1 ))) # Convert the target to ranks (actually, percentiles), including ties # Get the grand median, which we may need later. # After this is done, sort again using the indices to put them back in order # so that they correspond to the predictors. self . y_lookup , indexed_target = \\ np . unique ( target , return_inverse = True ) indices = np . argsort ( indexed_target ) ranks = indexed_target [ indices ] . astype ( np . float64 ) # Creates the ranks for the target variable # 'centers' the rank value for all tied values i = 0 while i < ncases : val = ranks [ i ] # find all ties k = i + 1 while k < ncases : if ( ranks [ k ] > val ): break k += 1 rank = 0.5 * ( i + k + 1 ) while ( i < k ): ranks [ i ] = 100.0 * rank / ncases i += 1 if ncases % 2 : self . _median = ranks [ int ( ncases / 2 )] else : self . _median = \\ 0.5 * ( ranks [ int ( ncases / 2 - 1 )] + ranks [ int ( ncases / 2 )]) # Get the 'ranks' index back into it's original positioning ranks = ranks [ np . argsort ( indices )] # Pass through each column in preds # cumulating the mean rank for each class bin for each column self . mean_ranks = dict () for ncol in range ( npred ): nclasses = len ( lookup_list [ ncol ]) if self . gate_ is None : mean_ranks = np . zeros ( nclasses , dtype = np . float64 ) else : mean_ranks = np . zeros (( nclasses , 3 ), dtype = np . float64 ) if self . gate_ is None : for i in range ( nclasses ): class_mask = indexed_mat [:, ncol ] == i n_obs = np . sum ( class_mask ) if n_obs > self . smoothing_min_obs : mean_ranks [ i ] = np . mean ( ranks [ class_mask ]) else : if n_obs > 0 : n_prior = self . smoothing_min_obs - n_obs mean_ranks [ i ] = \\ (( n_prior * self . _median ) + ( n_obs * np . mean ( ranks [ class_mask ]))) / self . smoothing_min_obs else : mean_ranks [ i ] = self . _median else : for i in range ( nclasses ): class_mask = indexed_mat [:, ncol ] == i for j in range ( len ( gate_lookup )): gate_mask = gate_indexed_vec == j class_mask = class_mask & gate_mask n_obs = np . sum ( class_mask ) if n_obs > self . smoothing_min_obs : mean_ranks [ i , j ] = np . mean ( ranks [ class_mask ]) else : if n_obs > 0 : n_prior = self . smoothing_min_obs - n_obs mean_ranks [ i , j ] = \\ (( n_prior * self . _median ) + ( n_obs * np . mean ( ranks [ class_mask ]))) / self . smoothing_min_obs else : mean_ranks [ i , j ] = self . _median # Prepare the results in a dictionary for future_transformation self . mean_ranks [ nominal_features [ ncol ]] = \\ dict ( zip ( lookup_list [ ncol ], mean_ranks )) transform \u00a4 transform ( X , copy = True ) Transforms nominal values of a categorical variable to their encoded numeric values. Returns: Type Description pd.DataFrame pandas DataFrame with encoded values Parameters: Name Type Description Default X pd . DataFrame pandas DataFrame to be transformed with encoded values should ideally contain columns that were encoded during fit but will pass through unmodified if no encoded columns are present. required copy bool Flag for determining whether a copy of X should be returned with the encoded values ( True ) or whether X should be modified inplace with the encoded values ( False ). True Source code in narrowgate/encoders/nom_ord.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 def transform ( self , X : pd . DataFrame , copy : bool = True ) -> pd . DataFrame : \"\"\" Transforms nominal values of a categorical variable to their encoded numeric values. Returns ------- pd.DataFrame pandas DataFrame with encoded values Parameters ---------- X : pandas DataFrame to be transformed with encoded values should ideally contain columns that were encoded during `fit` but will pass through unmodified if no encoded columns are present. copy : Flag for determining whether a copy of `X` should be returned with the encoded values (`True`) or whether `X` should be modified inplace with the encoded values (`False`). \"\"\" assert ( isinstance ( X , pd . DataFrame )) if self . gate_ is not None : raise NotImplementedError ( \"'gate' functionality is not currently implemented\" ) if copy : X_work = X . copy () else : X_work = X X_columns = X_work . columns for col in X_columns : if col in self . mean_ranks . keys (): X_work [ col ] = \\ X_work [ col ] . map ( self . mean_ranks [ col ]) . fillna ( self . _median ) if copy : return X_work","title":"Nominal2OrdinalEncoder"},{"location":"encoders/nom_ord/#narrowgate.encoders.Nominal2OrdinalEncoder","text":"Nominal2OrdinalEncoder () Bases: TransformerMixin , BaseEstimator The Nominal2Ordinal encoder functions very much like a target encoder. However, rather than using the raw target variable values to calculate the numerically-encoded replacement value for the nominal (categorical) predictor variable, percent-ranked values of the target variable are used instead. This helps minimize the encoding effect of any outlier values in the target variable series. Because the percent-ranked values of the target variable are used in the calculation, Nominal2Ordinal encoding will only work in situations where the target variable is, itself, continuous or ordinal in nature. Therefore, multi-class classification tasks, where the target is categorical and numerical ordering is non-sensical, are not supported with this numerical encoding method. However, please note that the target variable used in the encoding does not have to be the actual target variable used when building a predictive model. Instead, the encoding target variable may be another predictor variable in the dataset that is continuous and known to be highly informationally related to the target variable used when a predictive model is built. In such a situation, a Nominal2Ordinal encoder could be used in a multi-class classification task 'by proxy' if an information-based profiling process (such as UnivariateScreener) is first executed and a highly-informative continuous predictor variable is discovered. The following methods are present in the original class described in the cited reference but are not presently implemented within this class: print_counts train mcpt print_ranks create (adds new feature to database) - not needed","title":"Nominal2OrdinalEncoder"},{"location":"encoders/nom_ord/#narrowgate.encoders.Nominal2OrdinalEncoder--references","text":"Masters, Timothy. (2019) \"Extracting and Selecting Features for Data Mining: Algorithms in C++ and CUDA\". pp. 217-242 Source code in narrowgate/encoders/nom_ord.py 50 51 def __init__ ( self ): pass","title":"References"},{"location":"encoders/nom_ord/#narrowgate.encoders.nom_ord.Nominal2OrdinalEncoder.fit","text":"fit ( X , y , columns = 'auto' , smoothing_min_obs = 30 , gate = None ) Fit the encoder to predictor variable X and target variable y Parameters: Name Type Description Default X pd . DataFrame Pandas DataFrame containing the predictor variables. required y Union [ str , pd . Series , np . array ] If 'y is a string, refers to a column in 'X' that will represent the target variable to be used in the encoding. Otherwise, y must be either a pandas Series or numpy 1D array. required columns Union [ List [ str ], str ] If \"auto\" , then non-numeric columns within X will be automatically detected and encoded. If a string or list of strings, then the designated columns will be encoded regardless of data type. 'auto' smoothing_min_obs int integer value > 1 the number of observations a category or unique value of a predictor variable must possess in order for encoded value smoothing to not take place. If fewer than this number exists, the global encoded median of values will be combined with the encoded value of the category and weighted in a manner to represent a total of smoothing_min_obs observations. Example: If smoothing_min_obs is 30, and a given category value is only present 5 times within the dataset, then the actual encoded value for the category used during transform will be the calculated encoded value with the 5 observations with a weight of 5 and the global median encoded value for all observations weighted at 25. 30 gate Union [ str , None] Not implemented The encoded value of a category when a values of a third 'gating' variable is taken into account in relation to the target variable values. None Source code in narrowgate/encoders/nom_ord.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 def fit ( self , X : pd . DataFrame , y : Union [ str , pd . Series , np . array ], columns : Union [ List [ str ], str ] = 'auto' , smoothing_min_obs : int = 30 , gate : Union [ str , None ] = None ): \"\"\" Fit the encoder to predictor variable `X` and target variable `y` Parameters ---------- X : Pandas DataFrame containing the predictor variables. y : If `'y` is a string, refers to a column in 'X' that will represent the target variable to be used in the encoding. Otherwise, `y` must be either a pandas Series or numpy 1D array. columns : If **\"auto\"**, then non-numeric columns within `X` will be automatically detected and encoded. If a string or list of strings, then the designated columns will be encoded regardless of data type. smoothing_min_obs : integer value > 1 the number of observations a category or unique value of a predictor variable must possess in order for encoded value smoothing to not take place. If fewer than this number exists, the global encoded median of values will be combined with the encoded value of the category and weighted in a manner to represent a total of smoothing_min_obs observations. Example: If smoothing_min_obs is 30, and a given category value is only present 5 times within the dataset, then the actual encoded value for the category used during `transform` will be the calculated encoded value with the 5 observations with a weight of 5 and the global median encoded value for all observations weighted at 25. gate: Not implemented The encoded value of a category when a values of a third 'gating' variable is taken into account in relation to the target variable values. \"\"\" numeric_types = \\ [ 'int16' , 'int32' , 'int64' , 'float16' , 'float32' , 'float64' ] # Validation for 'gate' self . gate_ = gate if self . gate_ is not None : raise NotImplementedError ( \"'gate' functionality is not currently implemented\" ) assert ( self . gate_ . shape [ 0 ] == X . shape [ 0 ]) unique_gate = np . unique ( self . gate_ ) if unique_gate > 3 : raise ValueError ( \"'gate' has more than 3 unique values!\" ) gate_lookup , gate_indexed_vec = \\ np . unique ( self . gate_ , return_inverse = True ) # Validation for 'X' and 'columns' parameters if isinstance ( X , pd . DataFrame ): if columns == 'auto' : # filter the non-numeric columns nominal_features = \\ X . select_dtypes ( exclude = numeric_types ) . columns . tolist () else : # 'columns' is a custom list of columns to encode if not isinstance ( columns , list ): raise AttributeError ( \"'columns' parameter must have a string value of \" + \"'auto' or must be a list of column names in 'X'\" ) else : col_diff_list = set ( columns ) - set ( X . columns ) if len ( col_diff_list ) > 0 : raise RuntimeError ( \"The following columns are not present in 'X': \" + f \" { col_diff_list } \" ) nominal_features = columns if len ( nominal_features ) == 0 : raise RuntimeError ( \"'No categorical features present in 'X'!\" ) else : raise NotImplementedError ( \"'X' must be a pandas DataFrame\" ) # Validate 'y' # either standalone Series/array or column name (string) in X if isinstance ( y , pd . Series ): assert ( y . shape [ 0 ] == X . shape [ 0 ]) if not y . dtype in numeric_types : raise TypeError ( f \"'y' series must be a numeric data type!\" ) target = y . values elif isinstance ( y , str ): if not y in X . columns : raise AttributeError ( f \"'y' parameter, { y } , is not a column in 'X'\" ) else : if not X [ y ] . dtype in numeric_types : raise TypeError ( f \"'y' series must be a numeric data type!\" ) target = X [ y ] . values elif isinstance ( y , np . array ): assert ( y . shape [ 0 ] == X . shape [ 0 ]) if not y . dtype in numeric_types : raise TypeError ( f \"'y' series must be a numeric data type!\" ) target = y . copy () else : raise AttibuteError ( \"'y' parameter must be a pandas Series, numpy array, \" + \"or column name in X\" ) self . smoothing_min_obs = smoothing_min_obs # Begin transformation process for categorical variables in X preds = X [ nominal_features ] npred = preds . shape [ 1 ] ncases = preds . shape [ 0 ] lookup_list = [] for i in range ( npred ): lookup , indexed_vec = \\ np . unique ( preds . iloc [:, i ], return_inverse = True ) lookup_list . append ( lookup ) if i == 0 : indexed_mat = indexed_vec . reshape ( - 1 , 1 ) else : indexed_mat = \\ np . hstack (( indexed_mat , indexed_vec . reshape ( - 1 , 1 ))) # Convert the target to ranks (actually, percentiles), including ties # Get the grand median, which we may need later. # After this is done, sort again using the indices to put them back in order # so that they correspond to the predictors. self . y_lookup , indexed_target = \\ np . unique ( target , return_inverse = True ) indices = np . argsort ( indexed_target ) ranks = indexed_target [ indices ] . astype ( np . float64 ) # Creates the ranks for the target variable # 'centers' the rank value for all tied values i = 0 while i < ncases : val = ranks [ i ] # find all ties k = i + 1 while k < ncases : if ( ranks [ k ] > val ): break k += 1 rank = 0.5 * ( i + k + 1 ) while ( i < k ): ranks [ i ] = 100.0 * rank / ncases i += 1 if ncases % 2 : self . _median = ranks [ int ( ncases / 2 )] else : self . _median = \\ 0.5 * ( ranks [ int ( ncases / 2 - 1 )] + ranks [ int ( ncases / 2 )]) # Get the 'ranks' index back into it's original positioning ranks = ranks [ np . argsort ( indices )] # Pass through each column in preds # cumulating the mean rank for each class bin for each column self . mean_ranks = dict () for ncol in range ( npred ): nclasses = len ( lookup_list [ ncol ]) if self . gate_ is None : mean_ranks = np . zeros ( nclasses , dtype = np . float64 ) else : mean_ranks = np . zeros (( nclasses , 3 ), dtype = np . float64 ) if self . gate_ is None : for i in range ( nclasses ): class_mask = indexed_mat [:, ncol ] == i n_obs = np . sum ( class_mask ) if n_obs > self . smoothing_min_obs : mean_ranks [ i ] = np . mean ( ranks [ class_mask ]) else : if n_obs > 0 : n_prior = self . smoothing_min_obs - n_obs mean_ranks [ i ] = \\ (( n_prior * self . _median ) + ( n_obs * np . mean ( ranks [ class_mask ]))) / self . smoothing_min_obs else : mean_ranks [ i ] = self . _median else : for i in range ( nclasses ): class_mask = indexed_mat [:, ncol ] == i for j in range ( len ( gate_lookup )): gate_mask = gate_indexed_vec == j class_mask = class_mask & gate_mask n_obs = np . sum ( class_mask ) if n_obs > self . smoothing_min_obs : mean_ranks [ i , j ] = np . mean ( ranks [ class_mask ]) else : if n_obs > 0 : n_prior = self . smoothing_min_obs - n_obs mean_ranks [ i , j ] = \\ (( n_prior * self . _median ) + ( n_obs * np . mean ( ranks [ class_mask ]))) / self . smoothing_min_obs else : mean_ranks [ i , j ] = self . _median # Prepare the results in a dictionary for future_transformation self . mean_ranks [ nominal_features [ ncol ]] = \\ dict ( zip ( lookup_list [ ncol ], mean_ranks ))","title":"fit()"},{"location":"encoders/nom_ord/#narrowgate.encoders.nom_ord.Nominal2OrdinalEncoder.transform","text":"transform ( X , copy = True ) Transforms nominal values of a categorical variable to their encoded numeric values. Returns: Type Description pd.DataFrame pandas DataFrame with encoded values Parameters: Name Type Description Default X pd . DataFrame pandas DataFrame to be transformed with encoded values should ideally contain columns that were encoded during fit but will pass through unmodified if no encoded columns are present. required copy bool Flag for determining whether a copy of X should be returned with the encoded values ( True ) or whether X should be modified inplace with the encoded values ( False ). True Source code in narrowgate/encoders/nom_ord.py 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 def transform ( self , X : pd . DataFrame , copy : bool = True ) -> pd . DataFrame : \"\"\" Transforms nominal values of a categorical variable to their encoded numeric values. Returns ------- pd.DataFrame pandas DataFrame with encoded values Parameters ---------- X : pandas DataFrame to be transformed with encoded values should ideally contain columns that were encoded during `fit` but will pass through unmodified if no encoded columns are present. copy : Flag for determining whether a copy of `X` should be returned with the encoded values (`True`) or whether `X` should be modified inplace with the encoded values (`False`). \"\"\" assert ( isinstance ( X , pd . DataFrame )) if self . gate_ is not None : raise NotImplementedError ( \"'gate' functionality is not currently implemented\" ) if copy : X_work = X . copy () else : X_work = X X_columns = X_work . columns for col in X_columns : if col in self . mean_ranks . keys (): X_work [ col ] = \\ X_work [ col ] . map ( self . mean_ranks [ col ]) . fillna ( self . _median ) if copy : return X_work","title":"transform()"},{"location":"model_selection/cpcv/","text":"CombinatorialPurgedCrossValidation \u00a4 CombinatorialPurgedCrossValidation ( n_folds = 6 , n_test_folds = 2 , n_purge = 1 , n_embargo = False ) Combinatorial-Purged Cross Validation (CPCV) class. Implements the cross validation methodology described in Chatper 12 of the cited reference. This methodology generates combinations of folds when generating train and test windows. Unlike other cross validation methods where an out-of-sample prediction is made on each observation in the data set exactly once, CPCV allows for multiple out-of-sample predictions to be made for each observation by combining multiple folds into a single out-of-sample fold. This assists in determining a more robust out-of-sample model performance estimate in the predictive modeling exercise. Current Limitation \u00a4 Currently, the class only supports numpy matrices and vectors with no knowledge of dates/timestamps. However, since the split method of the class returns indices, it is possible for a user to pass in a vector of sequential dates/timestamps from which the indices of these timestamps and their respective train/test membership of each trial will be returned. Unlike WalkBackwardTimeSeriesCV , this class does not currently support multiple time series or multiple occurrences of a single date in the data set. References \u00a4 Lopez de Prado, M. (2018) \"Advances in Financial Machine Learning\". John Wiley & Sons. pp. 161-168. Parameters: Name Type Description Default n_folds int Number of folds into which the data ( X ) will be divided. 6 n_test_folds int Number of folds that will be used in test (or out-of-sample) data This value must be bewteen 1 and n_folds /2 2 n_purge int Number of unique granularity observations between the end of a training fold and beginning of a test fold which need to be discarded. Typically used to fully prevent data leakage on autocorrelated features present in the training data fold. 1 n_embargo bool Boolean to determine whether n_purge unique granularity observations should all be discarded between the end of a test fold and beginning of a training fold. Typically used in conjuction with n_purge to fully prevent data leakage on autocorrelated features present in the training data fold. False Source code in narrowgate/model_selection/cpcv.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def __init__ ( self , n_folds : int = 6 , n_test_folds : int = 2 , n_purge : int = 1 , n_embargo : bool = False ): \"\"\" Parameters ---------- n_folds : Number of folds into which the data (`X`) will be divided. n_test_folds : Number of folds that will be used in test (or out-of-sample) data This value must be bewteen 1 and `n_folds`/2 n_purge : Number of unique `granularity` observations between the end of a training fold and beginning of a test fold which need to be discarded. Typically used to fully prevent data leakage on autocorrelated features present in the training data fold. n_embargo : Boolean to determine whether `n_purge` unique `granularity` observations should all be discarded between the end of a test fold and beginning of a training fold. Typically used in conjuction with `n_purge` to fully prevent data leakage on autocorrelated features present in the training data fold. \"\"\" assert n_folds > 1 assert 0 < n_test_folds <= int ( n_folds / 2 ) assert n_purge > 0 self . n_folds = n_folds self . n_test_folds = n_test_folds self . n_purge = n_purge self . n_embargo = n_embargo split \u00a4 split ( X , y ) Method for splitting X into the desired of groups train and test time-based folds. Yields train_idx and test_idx which are NUMERICAL indices of X . Doing so supports the ability for multiple rows/samples with the same date to be included in a given window. Parameters: Name Type Description Default X pandas DataFrame containing a DatetimeIndex (single or MultiIndex) or a datetime column as identified with the granularity parameter when class was instantiated. Contains the predictor variables to be used in predictive modeling or analytics. required y Not used directly by the method. Should always be None. However, y should contain the exact same number of observations as it is the target variable associated with X` in the predictive modeling exercise. required Yields: Name Type Description train_idx np.array numpy array of numerical indices corresponding to rows in X which will constitute the train data set test_idx np.array numpy array of numerical indices corresponding to rows in X which will constitute the test data set Source code in narrowgate/model_selection/cpcv.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def split ( self , X , y ): \"\"\" Method for splitting `X` into the desired of groups `train` and `test` time-based folds. Yields `train_idx` and `test_idx` which are **NUMERICAL** indices of `X`. Doing so supports the ability for multiple rows/samples with the same date to be included in a given window. Parameters ---------- X : pandas DataFrame containing a DatetimeIndex (single or MultiIndex) or a `datetime` column as identified with the `granularity` parameter when class was instantiated. Contains the predictor variables to be used in predictive modeling or analytics. y : Not used directly by the method. Should always be `None. However, `y` should contain the exact same number of observations as it is the target variable associated with `X` in the predictive modeling exercise. Yields ------ train_idx : np.array numpy array of numerical indices corresponding to rows in `X` which will constitute the **train** data set test_idx : np.array numpy array of numerical indices corresponding to rows in `X` which will constitute the **test** data set \"\"\" assert X . ndim >= 1 assert X . shape [ 0 ] == y . shape [ 0 ] n_cases = X . shape [ 0 ] xval_idx_mats = \\ generate_cpcv_matrices ( self . n_folds , self . n_test_folds , X . shape [ 0 ], n_purge = self . n_purge , n_embargo = self . n_embargo ) train_start_idx_mat = xval_idx_mats [ 0 ] train_end_idx_mat = xval_idx_mats [ 1 ] test_start_idx_mat = xval_idx_mats [ 2 ] test_end_idx_mat = xval_idx_mats [ 3 ] n_splits = train_start_idx_mat . shape [ 0 ] for i in range ( n_splits ): train_idx = \\ concat_xval_fold_idxs ( train_start_idx_mat [ i ], train_end_idx_mat [ i ], n_cases ) test_idx = \\ concat_xval_fold_idxs ( test_start_idx_mat [ i ], test_end_idx_mat [ i ], n_cases ) yield train_idx , test_idx","title":"CombinatorialPurgedCrossValidation"},{"location":"model_selection/cpcv/#narrowgate.model_selection.CombinatorialPurgedCrossValidation","text":"CombinatorialPurgedCrossValidation ( n_folds = 6 , n_test_folds = 2 , n_purge = 1 , n_embargo = False ) Combinatorial-Purged Cross Validation (CPCV) class. Implements the cross validation methodology described in Chatper 12 of the cited reference. This methodology generates combinations of folds when generating train and test windows. Unlike other cross validation methods where an out-of-sample prediction is made on each observation in the data set exactly once, CPCV allows for multiple out-of-sample predictions to be made for each observation by combining multiple folds into a single out-of-sample fold. This assists in determining a more robust out-of-sample model performance estimate in the predictive modeling exercise.","title":"CombinatorialPurgedCrossValidation"},{"location":"model_selection/cpcv/#narrowgate.model_selection.CombinatorialPurgedCrossValidation--current-limitation","text":"Currently, the class only supports numpy matrices and vectors with no knowledge of dates/timestamps. However, since the split method of the class returns indices, it is possible for a user to pass in a vector of sequential dates/timestamps from which the indices of these timestamps and their respective train/test membership of each trial will be returned. Unlike WalkBackwardTimeSeriesCV , this class does not currently support multiple time series or multiple occurrences of a single date in the data set.","title":"Current Limitation"},{"location":"model_selection/cpcv/#narrowgate.model_selection.CombinatorialPurgedCrossValidation--references","text":"Lopez de Prado, M. (2018) \"Advances in Financial Machine Learning\". John Wiley & Sons. pp. 161-168. Parameters: Name Type Description Default n_folds int Number of folds into which the data ( X ) will be divided. 6 n_test_folds int Number of folds that will be used in test (or out-of-sample) data This value must be bewteen 1 and n_folds /2 2 n_purge int Number of unique granularity observations between the end of a training fold and beginning of a test fold which need to be discarded. Typically used to fully prevent data leakage on autocorrelated features present in the training data fold. 1 n_embargo bool Boolean to determine whether n_purge unique granularity observations should all be discarded between the end of a test fold and beginning of a training fold. Typically used in conjuction with n_purge to fully prevent data leakage on autocorrelated features present in the training data fold. False Source code in narrowgate/model_selection/cpcv.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def __init__ ( self , n_folds : int = 6 , n_test_folds : int = 2 , n_purge : int = 1 , n_embargo : bool = False ): \"\"\" Parameters ---------- n_folds : Number of folds into which the data (`X`) will be divided. n_test_folds : Number of folds that will be used in test (or out-of-sample) data This value must be bewteen 1 and `n_folds`/2 n_purge : Number of unique `granularity` observations between the end of a training fold and beginning of a test fold which need to be discarded. Typically used to fully prevent data leakage on autocorrelated features present in the training data fold. n_embargo : Boolean to determine whether `n_purge` unique `granularity` observations should all be discarded between the end of a test fold and beginning of a training fold. Typically used in conjuction with `n_purge` to fully prevent data leakage on autocorrelated features present in the training data fold. \"\"\" assert n_folds > 1 assert 0 < n_test_folds <= int ( n_folds / 2 ) assert n_purge > 0 self . n_folds = n_folds self . n_test_folds = n_test_folds self . n_purge = n_purge self . n_embargo = n_embargo","title":"References"},{"location":"model_selection/cpcv/#narrowgate.model_selection.cpcv.CombinatorialPurgedCrossValidation.split","text":"split ( X , y ) Method for splitting X into the desired of groups train and test time-based folds. Yields train_idx and test_idx which are NUMERICAL indices of X . Doing so supports the ability for multiple rows/samples with the same date to be included in a given window. Parameters: Name Type Description Default X pandas DataFrame containing a DatetimeIndex (single or MultiIndex) or a datetime column as identified with the granularity parameter when class was instantiated. Contains the predictor variables to be used in predictive modeling or analytics. required y Not used directly by the method. Should always be None. However, y should contain the exact same number of observations as it is the target variable associated with X` in the predictive modeling exercise. required Yields: Name Type Description train_idx np.array numpy array of numerical indices corresponding to rows in X which will constitute the train data set test_idx np.array numpy array of numerical indices corresponding to rows in X which will constitute the test data set Source code in narrowgate/model_selection/cpcv.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def split ( self , X , y ): \"\"\" Method for splitting `X` into the desired of groups `train` and `test` time-based folds. Yields `train_idx` and `test_idx` which are **NUMERICAL** indices of `X`. Doing so supports the ability for multiple rows/samples with the same date to be included in a given window. Parameters ---------- X : pandas DataFrame containing a DatetimeIndex (single or MultiIndex) or a `datetime` column as identified with the `granularity` parameter when class was instantiated. Contains the predictor variables to be used in predictive modeling or analytics. y : Not used directly by the method. Should always be `None. However, `y` should contain the exact same number of observations as it is the target variable associated with `X` in the predictive modeling exercise. Yields ------ train_idx : np.array numpy array of numerical indices corresponding to rows in `X` which will constitute the **train** data set test_idx : np.array numpy array of numerical indices corresponding to rows in `X` which will constitute the **test** data set \"\"\" assert X . ndim >= 1 assert X . shape [ 0 ] == y . shape [ 0 ] n_cases = X . shape [ 0 ] xval_idx_mats = \\ generate_cpcv_matrices ( self . n_folds , self . n_test_folds , X . shape [ 0 ], n_purge = self . n_purge , n_embargo = self . n_embargo ) train_start_idx_mat = xval_idx_mats [ 0 ] train_end_idx_mat = xval_idx_mats [ 1 ] test_start_idx_mat = xval_idx_mats [ 2 ] test_end_idx_mat = xval_idx_mats [ 3 ] n_splits = train_start_idx_mat . shape [ 0 ] for i in range ( n_splits ): train_idx = \\ concat_xval_fold_idxs ( train_start_idx_mat [ i ], train_end_idx_mat [ i ], n_cases ) test_idx = \\ concat_xval_fold_idxs ( test_start_idx_mat [ i ], test_end_idx_mat [ i ], n_cases ) yield train_idx , test_idx","title":"split()"},{"location":"model_selection/walk_backward/","text":"WalkBackwardTimeSeriesCV \u00a4 WalkBackwardTimeSeriesCV ( n_train_period = 126 , n_test_period = 21 , n_splits = None , n_purged = None , granularity = \"date\" , shuffle = False , ** kwargs ) Generates tuples of train_idx , test_idx pairs Data being passed into the split() method of this class should contain columns or indices corresponding to time-related granularity. This class splits data according to the granularity (time-typed) column. This ensures that cohorts of observations with the same value in the granularity column will be grouped together in the same split, thereby making a best effort to prevent data leakage. While more widely used time-related cross-validation methods begin at the earliest time observation and work their way forward through time, this often times truncates the most recent data from being used if the train and test window lengths are not exact multiples of the number of unique time observations in the data set. In an attempt to assist the user in maximizing the amount of recent data used for out-of-sample evaluation, this class splits data from the most recent time observation and works backwards through time . This does put more responsibility on the user to make sure any data produced from this class gets transformed properly for downstream processes. This will most likely require a 'latest-to-earliest' sequential re-ordering of any out-of-sample values produced. This class was largely inspired by the work of Stefan Jansen presented in Chapters 6 and 7 of the reference cited below References \u00a4 Jansen, S. (2020). \"Machine Learning for Algorithmic Trading, Second Edition\". Packt Publishing. Parameters: Name Type Description Default n_splits Union [ int , None] Number of cross-validation splits to perform. If 'None', then max number of splits supported by the data is calculated at runtime when 'X' is passed into the 'split' method. None n_train_period int Number of unique granularity observations for in-sample, training window 126 n_test_period int Number of unique granularity observations to include in the out-of-sample test window 21 n_purged Union [ int , None] Number of unique granularity observations between the end of training window and beginning of test window. Typically used to fully prevent data leakage on autocorrelated features. None granularity str column or index name possesing the temporal ordering information 'date' shuffle Shuffles the training data. (Default: False) Should not be set to True unless certain that no autocorrelation exists anywhere within data set. False Source code in narrowgate/model_selection/walk_backward.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , n_train_period : int = 126 , n_test_period : int = 21 , n_splits : Union [ int , None ] = None , n_purged : Union [ int , None ] = None , granularity : str = 'date' , shuffle = False , ** kwargs ): \"\"\" Parameters ---------- n_splits : Number of cross-validation splits to perform. If 'None', then max number of splits supported by the data is calculated at runtime when 'X' is passed into the 'split' method. n_train_period : Number of unique `granularity` observations for in-sample, training window n_test_period : Number of unique `granularity` observations to include in the out-of-sample test window n_purged : Number of unique `granularity` observations between the end of training window and beginning of test window. Typically used to fully prevent data leakage on autocorrelated features. granularity : column or index name possesing the temporal ordering information shuffle : Shuffles the training data. (Default: False) Should not be set to `True` unless certain that no autocorrelation exists anywhere within data set. \"\"\" self . n_splits = n_splits self . n_test = n_test_period self . n_train = n_train_period self . shuffle = shuffle self . n_purged = n_purged self . granularity = granularity self . fold_window_dates = None split \u00a4 split ( X , y = None , groups = None ) Method for splitting X into the desired train and test time-based data windows. Yields train_idx and test_idx which are NUMERICAL indices of X . Doing so supports the ability for multiple rows/samples with the same date to be included in a given window. Parameters: Name Type Description Default X pd . DataFrame pandas DataFrame containing a DatetimeIndex (single or MultiIndex) or a datetime column as identified with the granularity parameter when class was instantiated. Contains the predictor variables to be used in predictive modeling or analytics. required y Union [ pd . Series , None] Not used directly by the method. Should always be None. However, y should contain the exact same number of observations as it is the target variable associated with X` in the predictive modeling exercise. None Yields: Name Type Description train_idx np.array numpy array of numerical indices corresponding to rows in X which will constitute the train data set test_idx np.array numpy array of numerical indices corresponding to rows in X which will constitute the test data set dates pd.DataFrame pandas DataFrame with a single column containing all dates present in the granularity column/index of X days list list of all unique dates in X sorted in reverse order where most recent date is first in the list and latest date is last. Source code in narrowgate/model_selection/walk_backward.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def split ( self , X : pd . DataFrame , y : Union [ pd . Series , None ] = None , groups : Union [ list , None ] = None ): \"\"\" Method for splitting `X` into the desired `train` and `test` time-based data windows. Yields `train_idx` and `test_idx` which are **NUMERICAL** indices of `X`. Doing so supports the ability for multiple rows/samples with the same date to be included in a given window. Parameters ---------- X : pandas DataFrame containing a DatetimeIndex (single or MultiIndex) or a `datetime` column as identified with the `granularity` parameter when class was instantiated. Contains the predictor variables to be used in predictive modeling or analytics. y : Not used directly by the method. Should always be `None. However, `y` should contain the exact same number of observations as it is the target variable associated with `X` in the predictive modeling exercise. Yields ------ train_idx : np.array numpy array of numerical indices corresponding to rows in `X` which will constitute the **train** data set test_idx : np.array numpy array of numerical indices corresponding to rows in `X` which will constitute the **test** data set dates : pd.DataFrame pandas DataFrame with a single column containing all dates present in the `granularity` column/index of `X` days : list list of all **unique** dates in `X` sorted in reverse order where most recent date is first in the list and latest date is last. \"\"\" # Account for if granularity is in index or column # If neither, throw an error if isinstance ( X , pd . DataFrame ): is_x_df = True if self . granularity in X . columns : unique_dates = X [ self . granularity ] . unique () granularity_is_column = True elif self . granularity in X . index . names : unique_dates = \\ X . index . get_level_values ( self . granularity ) . unique () granularity_is_column = False else : error_str = \\ \"The granularity, {} ,\" . format ( self . granularity ) + \\ \" is not a column or index.\" raise ValueError ( error_str ) elif isinstance ( X , pd . MultiIndex ): is_x_df = False if self . granularity in X . names : unique_dates = \\ X . get_level_values ( self . granularity ) . unique () else : error_str = \\ f \"The granularity, { self . granularity } ,\" + \\ \" is not a name in the index.\" raise ValueError ( error_str ) else : raise TypeError ( \"'X' must be a DataFrame or MultiIndex!\" ) # Test for n_purged = None if self . n_purged is None : n_purged = 1 elif self . n_purged > 0 : n_purged = self . n_purged else : raise ValueError ( \"'n_purged' parameter must be positive integer!\" ) # Get the unique dates and order them from most recent to earliest # thereby working backwards through time. If only one split is desired, # then set of train/test indices will correspond to the most recent dates. days = sorted ( unique_dates , reverse = True ) # Perform validation of 'n_splits' # 1. if n_splits is None, then calculate the number of splits for maximum # data usage and set n_splits to that value. # 2. If n_splits is not None, then determine if n_splits will exceed the # amount of data available. If this is the case, auto-adjust to this # number # Calculate max splits according to the data # The maximum number of test windows (given a train window of size 0), # will be number of days - length of a single test window # The list comprehension will be driven by a 1-based index since it # is not possible to have 'zero' splits (self.n_test*i=0 when i=0) max_test_windows = len ( days ) - self . n_test split_list = \\ [ self . n_test * i + self . n_train + n_purged < ( len ( days )) \\ for i in range ( 1 , int ( max_test_windows / self . n_test ))] # If 'False' appears in 'split_list' then this means that there is not # enough data to support this number of splits at that index value in the # list. However, because a 1-based index was used above to populate # 'split_list', the index at which 'False' appears is actually the # max number of splits. # If there is no 'False' present in the list then this means that all of # the data can be used and the max number of splits is the length of the # list. if False in split_list : max_splits = split_list . index ( False ) else : max_splits = len ( split_list ) if self . n_splits is None : self . n_splits = max_splits else : if self . n_splits > max_splits : warnings . warn ( \"'n_splits' value larger than maximum allowed given \" + \"data being passed in. Auto-adjusting 'n_splits'\" + f \"from { self . n_splits } to { max_splits } \" , RuntimeWarning ) self . n_splits = max_splits # calculate the indices corresponding to the dates in relation to # train and test period lengths split_idx = [] for i in range ( self . n_splits ): test_end_idx = i * self . n_test test_start_idx = test_end_idx + self . n_test train_end_idx = test_start_idx + n_purged train_start_idx = train_end_idx + self . n_train split_idx_list = \\ [ train_start_idx , train_end_idx , test_start_idx , test_end_idx ] split_idx . append ( split_idx_list ) if is_x_df : if granularity_is_column : dates = X [[ self . granularity ]] else : dates = X . reset_index ()[[ self . granularity ]] else : # need to create a DataFrame with the MultiIndex as columns # so that behavior is similar to above dates = X . to_frame () . reset_index ( drop = True ) for train_start , train_end , test_start , test_end in split_idx : train_idx = \\ dates [( dates [ self . granularity ] > days [ train_start ]) & ( dates [ self . granularity ] <= days [ train_end ])] . index test_idx = \\ dates [( dates [ self . granularity ] > days [ test_start ]) & ( dates [ self . granularity ] <= days [ test_end ])] . index if self . shuffle : np . random . shuffle ( list ( train_idx )) yield train_idx , test_idx , dates , days get_n_splits \u00a4 get_n_splits () Returns the number of train/test splits. Source code in narrowgate/model_selection/walk_backward.py 245 246 247 248 249 250 @property def get_n_splits ( self ): \"\"\" Returns the number of train/test splits. \"\"\" return self . n_splits","title":"WalkBackwardTimeSeriesCV"},{"location":"model_selection/walk_backward/#narrowgate.model_selection.WalkBackwardTimeSeriesCV","text":"WalkBackwardTimeSeriesCV ( n_train_period = 126 , n_test_period = 21 , n_splits = None , n_purged = None , granularity = \"date\" , shuffle = False , ** kwargs ) Generates tuples of train_idx , test_idx pairs Data being passed into the split() method of this class should contain columns or indices corresponding to time-related granularity. This class splits data according to the granularity (time-typed) column. This ensures that cohorts of observations with the same value in the granularity column will be grouped together in the same split, thereby making a best effort to prevent data leakage. While more widely used time-related cross-validation methods begin at the earliest time observation and work their way forward through time, this often times truncates the most recent data from being used if the train and test window lengths are not exact multiples of the number of unique time observations in the data set. In an attempt to assist the user in maximizing the amount of recent data used for out-of-sample evaluation, this class splits data from the most recent time observation and works backwards through time . This does put more responsibility on the user to make sure any data produced from this class gets transformed properly for downstream processes. This will most likely require a 'latest-to-earliest' sequential re-ordering of any out-of-sample values produced. This class was largely inspired by the work of Stefan Jansen presented in Chapters 6 and 7 of the reference cited below","title":"WalkBackwardTimeSeriesCV"},{"location":"model_selection/walk_backward/#narrowgate.model_selection.WalkBackwardTimeSeriesCV--references","text":"Jansen, S. (2020). \"Machine Learning for Algorithmic Trading, Second Edition\". Packt Publishing. Parameters: Name Type Description Default n_splits Union [ int , None] Number of cross-validation splits to perform. If 'None', then max number of splits supported by the data is calculated at runtime when 'X' is passed into the 'split' method. None n_train_period int Number of unique granularity observations for in-sample, training window 126 n_test_period int Number of unique granularity observations to include in the out-of-sample test window 21 n_purged Union [ int , None] Number of unique granularity observations between the end of training window and beginning of test window. Typically used to fully prevent data leakage on autocorrelated features. None granularity str column or index name possesing the temporal ordering information 'date' shuffle Shuffles the training data. (Default: False) Should not be set to True unless certain that no autocorrelation exists anywhere within data set. False Source code in narrowgate/model_selection/walk_backward.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , n_train_period : int = 126 , n_test_period : int = 21 , n_splits : Union [ int , None ] = None , n_purged : Union [ int , None ] = None , granularity : str = 'date' , shuffle = False , ** kwargs ): \"\"\" Parameters ---------- n_splits : Number of cross-validation splits to perform. If 'None', then max number of splits supported by the data is calculated at runtime when 'X' is passed into the 'split' method. n_train_period : Number of unique `granularity` observations for in-sample, training window n_test_period : Number of unique `granularity` observations to include in the out-of-sample test window n_purged : Number of unique `granularity` observations between the end of training window and beginning of test window. Typically used to fully prevent data leakage on autocorrelated features. granularity : column or index name possesing the temporal ordering information shuffle : Shuffles the training data. (Default: False) Should not be set to `True` unless certain that no autocorrelation exists anywhere within data set. \"\"\" self . n_splits = n_splits self . n_test = n_test_period self . n_train = n_train_period self . shuffle = shuffle self . n_purged = n_purged self . granularity = granularity self . fold_window_dates = None","title":"References"},{"location":"model_selection/walk_backward/#narrowgate.model_selection.walk_backward.WalkBackwardTimeSeriesCV.split","text":"split ( X , y = None , groups = None ) Method for splitting X into the desired train and test time-based data windows. Yields train_idx and test_idx which are NUMERICAL indices of X . Doing so supports the ability for multiple rows/samples with the same date to be included in a given window. Parameters: Name Type Description Default X pd . DataFrame pandas DataFrame containing a DatetimeIndex (single or MultiIndex) or a datetime column as identified with the granularity parameter when class was instantiated. Contains the predictor variables to be used in predictive modeling or analytics. required y Union [ pd . Series , None] Not used directly by the method. Should always be None. However, y should contain the exact same number of observations as it is the target variable associated with X` in the predictive modeling exercise. None Yields: Name Type Description train_idx np.array numpy array of numerical indices corresponding to rows in X which will constitute the train data set test_idx np.array numpy array of numerical indices corresponding to rows in X which will constitute the test data set dates pd.DataFrame pandas DataFrame with a single column containing all dates present in the granularity column/index of X days list list of all unique dates in X sorted in reverse order where most recent date is first in the list and latest date is last. Source code in narrowgate/model_selection/walk_backward.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 def split ( self , X : pd . DataFrame , y : Union [ pd . Series , None ] = None , groups : Union [ list , None ] = None ): \"\"\" Method for splitting `X` into the desired `train` and `test` time-based data windows. Yields `train_idx` and `test_idx` which are **NUMERICAL** indices of `X`. Doing so supports the ability for multiple rows/samples with the same date to be included in a given window. Parameters ---------- X : pandas DataFrame containing a DatetimeIndex (single or MultiIndex) or a `datetime` column as identified with the `granularity` parameter when class was instantiated. Contains the predictor variables to be used in predictive modeling or analytics. y : Not used directly by the method. Should always be `None. However, `y` should contain the exact same number of observations as it is the target variable associated with `X` in the predictive modeling exercise. Yields ------ train_idx : np.array numpy array of numerical indices corresponding to rows in `X` which will constitute the **train** data set test_idx : np.array numpy array of numerical indices corresponding to rows in `X` which will constitute the **test** data set dates : pd.DataFrame pandas DataFrame with a single column containing all dates present in the `granularity` column/index of `X` days : list list of all **unique** dates in `X` sorted in reverse order where most recent date is first in the list and latest date is last. \"\"\" # Account for if granularity is in index or column # If neither, throw an error if isinstance ( X , pd . DataFrame ): is_x_df = True if self . granularity in X . columns : unique_dates = X [ self . granularity ] . unique () granularity_is_column = True elif self . granularity in X . index . names : unique_dates = \\ X . index . get_level_values ( self . granularity ) . unique () granularity_is_column = False else : error_str = \\ \"The granularity, {} ,\" . format ( self . granularity ) + \\ \" is not a column or index.\" raise ValueError ( error_str ) elif isinstance ( X , pd . MultiIndex ): is_x_df = False if self . granularity in X . names : unique_dates = \\ X . get_level_values ( self . granularity ) . unique () else : error_str = \\ f \"The granularity, { self . granularity } ,\" + \\ \" is not a name in the index.\" raise ValueError ( error_str ) else : raise TypeError ( \"'X' must be a DataFrame or MultiIndex!\" ) # Test for n_purged = None if self . n_purged is None : n_purged = 1 elif self . n_purged > 0 : n_purged = self . n_purged else : raise ValueError ( \"'n_purged' parameter must be positive integer!\" ) # Get the unique dates and order them from most recent to earliest # thereby working backwards through time. If only one split is desired, # then set of train/test indices will correspond to the most recent dates. days = sorted ( unique_dates , reverse = True ) # Perform validation of 'n_splits' # 1. if n_splits is None, then calculate the number of splits for maximum # data usage and set n_splits to that value. # 2. If n_splits is not None, then determine if n_splits will exceed the # amount of data available. If this is the case, auto-adjust to this # number # Calculate max splits according to the data # The maximum number of test windows (given a train window of size 0), # will be number of days - length of a single test window # The list comprehension will be driven by a 1-based index since it # is not possible to have 'zero' splits (self.n_test*i=0 when i=0) max_test_windows = len ( days ) - self . n_test split_list = \\ [ self . n_test * i + self . n_train + n_purged < ( len ( days )) \\ for i in range ( 1 , int ( max_test_windows / self . n_test ))] # If 'False' appears in 'split_list' then this means that there is not # enough data to support this number of splits at that index value in the # list. However, because a 1-based index was used above to populate # 'split_list', the index at which 'False' appears is actually the # max number of splits. # If there is no 'False' present in the list then this means that all of # the data can be used and the max number of splits is the length of the # list. if False in split_list : max_splits = split_list . index ( False ) else : max_splits = len ( split_list ) if self . n_splits is None : self . n_splits = max_splits else : if self . n_splits > max_splits : warnings . warn ( \"'n_splits' value larger than maximum allowed given \" + \"data being passed in. Auto-adjusting 'n_splits'\" + f \"from { self . n_splits } to { max_splits } \" , RuntimeWarning ) self . n_splits = max_splits # calculate the indices corresponding to the dates in relation to # train and test period lengths split_idx = [] for i in range ( self . n_splits ): test_end_idx = i * self . n_test test_start_idx = test_end_idx + self . n_test train_end_idx = test_start_idx + n_purged train_start_idx = train_end_idx + self . n_train split_idx_list = \\ [ train_start_idx , train_end_idx , test_start_idx , test_end_idx ] split_idx . append ( split_idx_list ) if is_x_df : if granularity_is_column : dates = X [[ self . granularity ]] else : dates = X . reset_index ()[[ self . granularity ]] else : # need to create a DataFrame with the MultiIndex as columns # so that behavior is similar to above dates = X . to_frame () . reset_index ( drop = True ) for train_start , train_end , test_start , test_end in split_idx : train_idx = \\ dates [( dates [ self . granularity ] > days [ train_start ]) & ( dates [ self . granularity ] <= days [ train_end ])] . index test_idx = \\ dates [( dates [ self . granularity ] > days [ test_start ]) & ( dates [ self . granularity ] <= days [ test_end ])] . index if self . shuffle : np . random . shuffle ( list ( train_idx )) yield train_idx , test_idx , dates , days","title":"split()"},{"location":"model_selection/walk_backward/#narrowgate.model_selection.walk_backward.WalkBackwardTimeSeriesCV.get_n_splits","text":"get_n_splits () Returns the number of train/test splits. Source code in narrowgate/model_selection/walk_backward.py 245 246 247 248 249 250 @property def get_n_splits ( self ): \"\"\" Returns the number of train/test splits. \"\"\" return self . n_splits","title":"get_n_splits()"},{"location":"models/hmm/","text":"HMM_nb \u00a4 HMM_nb ( n_init = 1000 , max_iter = 100 ) Hidden Markov Model class. A hidden Markov model produces state probabilities where being in a given state at an observed time depends on the process's state at the prior observed time. This dependency is referred to as the 'memory' inherent in the model. Implemented using numba's @jitclass operator. Ideal for use inside numba parallelization loops ( prange ). A 'fit' model (via the fit() method) will produce the Attributes below The state_probs values are used as additional features in a predictive model within the HMMTargetLinkScreener class. The transition matrix provides the probability of transitioning from one state to another. Attributes: Name Type Description means np.ndarray matrix of means for each state shape: (nstates, nvars) covars np.ndarray set of covariance matrices, one for each state shape: (nstates, nvars, nvars) transition np.ndarray matrix of transition probabilities shape: (nstates, nstates) state_probs np.ndarray matrix of state membership probabilities for each case shape: (ncases, nstates) init_probs np.array vector of state probabilities of first case shape: (nstates,) References \u00a4 Masters, Timothy. (2019) \"Extracting and Selecting Features for Data Mining: Algorithms in C++ and CUDA\". pp. 119-158. Parameters: Name Type Description Default n_init int Number of initial trial parameter sets to test for finding a good stating point for iteration. Larger values make it more likely that the iterations, which always converge to a local optimum, will find the global optimum. (a minimum of 1000 is recommended by Masters with a value of 10,000 not being unreasonable). 1000 max_iter int Iteration limit for convergence. This is insurance only, and should always be set very large to ensure complete convergence. Normally, convergence will be obtained long before this is hit. 100 Source code in narrowgate/model/hmm.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def __init__ ( self , n_init = 1000 , max_iter = 100 ): \"\"\" Parameters ---------- n_init : int Number of initial trial parameter sets to test for finding a good stating point for iteration. Larger values make it more likely that the iterations, which always converge to a local optimum, will find the global optimum. (a minimum of 1000 is recommended by Masters with a value of 10,000 not being unreasonable). max_iter : int Iteration limit for convergence. This is insurance only, and should always be set very large to ensure complete convergence. Normally, convergence will be obtained long before this is hit. \"\"\" self . n_init = n_init self . max_iter = max_iter fit \u00a4 fit ( X , nstates , max_iter = 100 ) Method for estimating the parameters of a Hidden Markov Model utilizing the Baum-Welch Algorithm. Important note The number of time series features (columns) in dataset X (referred to inside the method as nvars ) should ideally be between 2 and 5. Using 5 to 10 features should be considered extremely dangerous due to substantially increased runtime and memory usage. Parameters: Name Type Description Default X np.ndarray Numpy matrix (ncases, nvars) It is ideal that the each column/feature be at least moderately standardized (mean zero, unit variance), although this is not required. If the data contains any features (time series) which are nearly collinear (highly correlated) with one another, the modeling process will encounter significant trouble. However, some correlation amongst the columns is fine. required n_states int The number of hidden states for the model to posit. More than 3 to 4 states can produce highly unstable results required max_iter int The number of iterations to perform for finding the maximum likelihood parameters of the model. If the model converges prior to this number, early stopping will occur. If the method completes and the return value of n_iter is max_iter-1 , then complete convergence was not obtained. 100 Returns: Name Type Description n_iter int The number of iterations performed before complete convergence of the algorithm was obtained. If the value returned is max_iter-1 , then complete convergence was not obtained. likelihood float The log likelihood of the observations in X coming from the best performing set of model parameters found across the performed iterations. Source code in narrowgate/model/hmm.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def fit ( self , X , nstates , max_iter = 100 ): \"\"\" Method for estimating the parameters of a Hidden Markov Model utilizing the Baum-Welch Algorithm. **Important note** The number of time series features (columns) in dataset `X` (referred to inside the method as `nvars`) should ideally be between 2 and 5. Using 5 to 10 features should be considered extremely dangerous due to substantially increased runtime and memory usage. Parameters ---------- X : np.ndarray Numpy matrix (ncases, nvars) It is ideal that the each column/feature be at least moderately standardized (mean zero, unit variance), although this is not required. If the data contains any features (time series) which are nearly collinear (highly correlated) with one another, the modeling process will encounter significant trouble. However, some correlation amongst the columns is fine. n_states : int The number of hidden states for the model to posit. More than 3 to 4 states can produce highly unstable results max_iter : int The number of iterations to perform for finding the maximum likelihood parameters of the model. If the model converges prior to this number, early stopping will occur. If the method completes and the return value of `n_iter` is `max_iter-1`, then complete convergence was not obtained. Returns ------- n_iter : int The number of iterations performed before complete convergence of the algorithm was obtained. If the value returned is `max_iter-1`, then complete convergence was not obtained. likelihood : float The log likelihood of the observations in `X` coming from the best performing set of model parameters found across the performed iterations. \"\"\" assert max_iter > 0 , \"'max_iter' must be greater than 0!\" self . max_iter = max_iter data = X ncases = data . shape [ 0 ] nvars = data . shape [ 1 ] # Initialize members to be used throughout methods self . means = np . zeros (( nstates , nvars )) self . covars = np . zeros (( nstates , nvars , nvars )) self . densities = np . zeros (( nstates , ncases )) self . alpha = np . zeros (( ncases , nstates )) self . beta = np . zeros (( ncases , nstates )) self . init_probs = np . zeros ( nstates ) self . transition = np . zeros (( nstates , nstates )) self . state_probs = np . zeros (( ncases , nstates )) ################ ## Initialize ## ################ self . find_mean_covar ( data , nstates ) self . initialize ( data , nstates ) # Initialize some other objects needed for this method trans_work1 = np . zeros (( nstates , nstates )) trans_work2 = np . zeros (( nstates , nstates )) temp = 0.0 max_prod = 0.0 # Main outermost loop is here prior_likelihood = - 1.e200 # create floor array floor = np . zeros ( nstates ) floor [:] = 1.e-100 for n_iter in range ( self . max_iter ): # Compute alpha, beta, and log likelihood. # While backward_prob is not explicitly needed, it can serve as a # nice diagnostic. self . find_densities ( data , self . means ) likelihood = self . forward ( self . transition ) backward_prob = self . backward () #if (print || file_print) # print_params ( print , file_print , iter , likelihood , backward_prob ) ; ##################################################### ## Compute probability of each state for each case ## ##################################################### # Update means and covariances for icase in range ( ncases ): # Step 1 of 3: Find maximum of (alpha * beta) alpha_beta_prod = self . alpha [ icase ] * self . beta [ icase ] # test against floor alpha_beta_prod = np . maximum ( alpha_beta_prod , floor ) max_prod = np . max ( alpha_beta_prod ) sum_ = np . sum ( alpha_beta_prod / max_prod ) self . state_probs [ icase ] = \\ alpha_beta_prod / max_prod / sum_ self . update_mean_covar ( data ) # Update initial state probabilities and transition matrix # set 'init_probs' and zero out the trans_work2 matrix self . init_probs [:] = self . state_probs [ 0 ,:] trans_work2 [:,:] = 0.0 for icase in range ( 1 , ncases ): # Find max product for scaling; # save each product to avoid recomputing for istate in range ( nstates ): for jstate in range ( nstates ): if self . alpha [( icase - 1 ), istate ] > np . exp ( - 300.0 ): temp = np . log ( self . alpha [( icase - 1 ), istate ]) else : temp = - 300.0 if self . transition [ istate , jstate ] > np . exp ( - 300.0 ): temp += np . log ( self . transition [ istate , jstate ]) else : temp -= 300.0 if self . densities [ jstate , icase ] > np . exp ( - 300.0 ): temp += np . log ( self . densities [ jstate , icase ]) else : temp -= 300.0 if self . beta [ icase , istate ] > np . exp ( - 300.0 ): temp += np . log ( self . beta [ icase , jstate ]) else : temp -= 300.0 trans_work1 [ istate , jstate ] = temp if ( istate == 0 ) and ( jstate == 0 ): max_prod = temp else : max_prod = max ( temp , max_prod ) # Sum the exp() of the shifted terms trans_work1 = np . exp ( trans_work1 - max_prod ) sum_ = np . sum ( trans_work1 ) # Normalize to probabilities trans_work2 += trans_work1 / sum_ ####################### ## End for all cases ## ####################### for istate in range ( nstates ): sum_ = np . sum ( trans_work2 [ istate ]) self . transition [ istate ] = trans_work2 [ istate ] / sum_ # Check for convergence if ( n_iter > 0 ) and (( likelihood - prior_likelihood ) < 1.e-8 ): break prior_likelihood = likelihood ####################### ## End of iterations ## ####################### return n_iter , likelihood forward \u00a4 forward ( these_transitions ) Forward pass of Baum-Welch algorithm for finding maximum-likelihood parameters of a Hidden Markov Model. This is Master's enhanced version that use logarithmic values for increased numerical stability. Source code in narrowgate/model/hmm.py 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def forward ( self , these_transitions ): \"\"\" Forward pass of Baum-Welch algorithm for finding maximum-likelihood parameters of a Hidden Markov Model. This is Master's enhanced version that use logarithmic values for increased numerical stability. \"\"\" # Instance members # init_probs -> (nstates,) # alpha -> (ncases, nstates) # beta -> (ncases, nstates) # densities -> (nstates, ncases) # Parameters # these_transitions -> (nstates, nstates) ncases = self . densities . shape [ 1 ] nstates = self . densities . shape [ 0 ] # Initialize first case (t=0): self . alpha [ 0 ] = self . init_probs * self . densities [:, 0 ] denom = np . sum ( self . alpha [ 0 ]) log_likelihood = np . log ( denom ) self . alpha [ 0 ] /= denom # Recursion for remaining cases: # alpha[t,i] = Sum over j of (alpha[t-1,j]*transitions[j,i]) * densities[i,t] for t in range ( 1 , ncases ): for i in range ( nstates ): sum_ = np . sum ( self . alpha [ t - 1 ] * these_transitions [:, i ]) self . alpha [ t , i ] = sum_ * self . densities [ i , t ] denom = np . sum ( self . alpha [ t ]) log_likelihood += np . log ( denom ) self . alpha [ t ] /= denom return log_likelihood backward \u00a4 backward () Backward pass of Baum-Welch algorithm for finding maximum-likelihood parameters of a Hidden Markov Model. This is Master's enhanced version that use logarithmic values for increased numerical stability. Source code in narrowgate/model/hmm.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 def backward ( self ): \"\"\" Backward pass of Baum-Welch algorithm for finding maximum-likelihood parameters of a Hidden Markov Model. This is Master's enhanced version that use logarithmic values for increased numerical stability. \"\"\" # init_probs -> (nstates,) # beta -> (ncases, nstates) # densities -> (nstates, ncases) # these_transitions -> (nstates, nstates) ncases = self . densities . shape [ 1 ] nstates = self . densities . shape [ 0 ] # Initialize for last case (t=ncases-1): # beta[ncases-1,i] = 1.0 self . beta [ ncases - 1 ,:] = 1 / nstates log_likelihood = np . log ( nstates ) # Recursion for remaining cases: # beta[t,i] = \\ # Sum over j of (transition[i,j] * densities[j,t+1] * beta[t+1,j]) for t in range ( ncases - 2 , - 1 , - 1 ): denom = 0.0 for i in range ( nstates ): sum_ = \\ np . sum ( self . transition [ i ,:] * self . densities [:, t + 1 ] * self . beta [ t + 1 ,:]) self . beta [ t , i ] = sum_ denom += sum_ log_likelihood += np . log ( denom ) self . beta [ t ] /= denom # Termination: # Final probability = \\ # Sum over i of init_probs[i] * densities[i,0] * beta[0,i] sum_ = np . sum ( self . init_probs * self . densities [:, 0 ] * self . beta [ 0 ]) # Include the termination likelihood log_likelihood_terminal = np . log ( sum_ ) + log_likelihood return log_likelihood_terminal initialize \u00a4 initialize ( X , nstates ) Initialize starting parameters of a Hidden Markov Model. Tries some random values of means and transition probabilities to find the best likelihood in the parameter search space compared to other points in the space. Results from this method will serve as the starting point for iterations performed in the fit() method. Called after find_mean_covar() method. Source code in narrowgate/model/hmm.py 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 def initialize ( self , X , nstates ): \"\"\" Initialize starting parameters of a Hidden Markov Model. Tries some random values of means and transition probabilities to find the best likelihood in the parameter search space compared to other points in the space. Results from this method will serve as the starting point for iterations performed in the `fit()` method. Called after `find_mean_covar()` method. \"\"\" ncases = X . shape [ 0 ] nvars = X . shape [ 1 ] # create working arrays and matrices trial_transition = np . zeros (( nstates , nstates )) trial_means = np . zeros (( nstates , nvars )) init_covar = self . covars [ 0 ] . copy () # initialize probabilities self . init_probs [:] = 1 / nstates # Start main loop ... trying many combinations # For the first half of trials, assign equal transition probs prob = 1.0 / nstates trial_transition [:,:] = prob best_likelihood = - 1.e200 for itrial in range ( self . n_init ): # Perturb the means. Make sure the offsets sum to zero. for i in range ( nvars ): sum_ = 0.0 for istate in range ( nstates ): if ( istate < nstates - 1 ): unif_rand = np . random . random () - 0.5 wt = 6 * unif_rand * np . sqrt ( self . covars [ istate , i , i ]) sum_ += wt else : wt = - sum_ trial_means [ istate , i ] = self . means [ istate , i ] + wt # Perturb the covariances by shrinking # Shrinkage for diagonal wtd = 0.4 + 0.5 * np . random . random () # Shrinkage for off-diagonal wto = 0.7 * np . random . random () * wtd for i in range ( nvars ): for j in range ( nvars ): if ( i == j ): dtemp = wtd * init_covar [ i , j ] else : dtemp = wto * init_covar [ i , j ] ; for istate in range ( nstates ): self . covars [ istate , i , j ] = dtemp # Perturb the transition probabilities starting at half of the trials if itrial >= self . n_init / 2 : for istate in range ( nstates ): unif_rand = 0.4 + np . random . random () * 0.5 prob = unif_rand trial_transition [ istate , istate ] = unif_rand for i in range ( nstates ): if not i == istate : trial_transition [ istate , i ] = \\ ( 1 - prob ) / ( nstates - 1 ) #HMM::find_densities(double *these_means) self . find_densities ( X , trial_means ) likelihood = self . forward ( trial_transition ) # Print trial if requested #fprintf ( fp , \"\\n\\n\\nInitialization trial %d of %d\", itrial+1, n_trials ) ; #sprintf ( msg , \"State %d Means =\", istate ) ; #sprintf ( msg2 , \" %10.2lf\", trial_means[istate*nvars+i] ) ; #fprintf ( fp , \"\\n\\nCommon covariances...\" ) ; #fprintf ( fp, \"\\n\\nTransition probability matrix...\" ) ; #sprintf ( msg2 , \" %7.3lf\", trial_transition[i*nstates+j] ) ; # update best if ( itrial == 0 ) or ( likelihood > best_likelihood ): best_likelihood = likelihood #for (i=0 ; i<nstates*nvars ; i++) # best_means[i] = trial_means[i] ; best_means = trial_means . copy () #for (i=0 ; i<nvars*nvars ; i++) # best_covar[i] = covars[i] ; best_covar = self . covars [ 0 ] . copy () #for (i=0 ; i<nstates*nstates ; i++) # best_transition[i] = trial_transition[i] ; best_transition = trial_transition . copy () # The best are found. Copy them to the private versions. self . means [:,:] = best_means [:,:] self . transition [:,:] = best_transition [:,:] for istate in range ( nstates ): self . covars [ istate ] = best_covar [:,:] find_mean_covar \u00a4 find_mean_covar ( data , nstates ) Compute means and covariances of features/columns. Called once before calling initialize() method. Source code in narrowgate/model/hmm.py 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 def find_mean_covar ( self , data , nstates ): \"\"\" Compute means and covariances of features/columns. Called once before calling `initialize()` method. \"\"\" nvars = data . shape [ 1 ] data_means = np . zeros ( nvars ) for i in range ( nvars ): data_means [ i ] = np . mean ( data [:, i ]) data_covar = np . cov ( data . transpose ()) for i in range ( nstates ): self . means [ i ] = data_means self . covars [ i ] = data_covar find_densities \u00a4 find_densities ( data , these_means ) Compute densities of features/columns Source code in narrowgate/model/hmm.py 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def find_densities ( self , data , these_means ): \"\"\" Compute densities of features/columns \"\"\" nstates = self . densities . shape [ 0 ] ncases = data . shape [ 0 ] for istate in range ( nstates ): for i in range ( ncases ): self . densities [ istate , i ] = \\ mv_normal_pdf_nb ( data [ i ], these_means [ istate ], self . covars [ istate ]) update_mean_covar \u00a4 update_mean_covar ( data ) Update means and covariances of features/columns. Source code in narrowgate/model/hmm.py 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 def update_mean_covar ( self , data ): \"\"\" Update means and covariances of features/columns. \"\"\" # X -> # means -> (nstates, nvars) # covars -> (nstates, nvars, nvars) # state_probs -> (ncases, nstates) ncases = data . shape [ 0 ] nvars = data . shape [ 1 ] nstates = self . state_probs . shape [ 1 ] for istate in range ( nstates ): # 'Reset' covars matrix for the given state self . covars [ istate ,:,:] = 0.0 # Prevent zero variance np . fill_diagonal ( self . covars [ istate ], 1.e-20 ) # retrieve the state probabilities to serve as weights weights = self . state_probs [:, istate ] denom = np . sum ( weights ) # Calculate the means for each variable according to the # state probabilities which serve as weights # The following line of code applies the vector of probabilities # for the given state (istate) to each variable/column in data. tmp = np . dot ( np . diag ( weights ), data ) for i in range ( nvars ): self . means [ istate , i ] = \\ np . sum ( tmp [:, i ]) / ( denom + 1.e-100 ) # calculate the covariance matrix # since weights need to be applied and numba does not support # weights in the 'nopython' mode, need to do this the same way # Masters does in C. assert ( data . shape [ 1 ] == self . means [ istate ] . shape [ 0 ]) # subtract the means for each variable for istate across all # observation in data (via broadcast) tmp = data - self . means [ istate ] for icase in range ( ncases ): weight = weights [ icase ] for i in range ( nvars ): for j in range ( nvars ): self . covars [ istate , i , j ] += \\ weight * tmp [ icase , i ] * tmp [ icase , j ] self . covars [ istate ] /= ( denom + 1.e-100 ) # ensure that matrix is invertible for i in range ( nvars ): for j in range ( nvars ): const1 = \\ ( 0.999999 * np . sqrt ( self . covars [ istate , i , i ] * self . covars [ istate , j , j ])) const2 = \\ ( - 0.999999 * np . sqrt ( self . covars [ istate , i , i ] * self . covars [ istate , j , j ])) cond0 = i != j cond1 = self . covars [ istate , i , j ] > const1 cond2 = self . covars [ istate , i , j ] < const2 if cond0 and cond1 : self . covars [ istate , i , j ] = const1 if cond0 and cond2 : self . covars [ istate , i , j ] = const2","title":"HMM_nb"},{"location":"models/hmm/#narrowgate.model.hmm.HMM_nb","text":"HMM_nb ( n_init = 1000 , max_iter = 100 ) Hidden Markov Model class. A hidden Markov model produces state probabilities where being in a given state at an observed time depends on the process's state at the prior observed time. This dependency is referred to as the 'memory' inherent in the model. Implemented using numba's @jitclass operator. Ideal for use inside numba parallelization loops ( prange ). A 'fit' model (via the fit() method) will produce the Attributes below The state_probs values are used as additional features in a predictive model within the HMMTargetLinkScreener class. The transition matrix provides the probability of transitioning from one state to another. Attributes: Name Type Description means np.ndarray matrix of means for each state shape: (nstates, nvars) covars np.ndarray set of covariance matrices, one for each state shape: (nstates, nvars, nvars) transition np.ndarray matrix of transition probabilities shape: (nstates, nstates) state_probs np.ndarray matrix of state membership probabilities for each case shape: (ncases, nstates) init_probs np.array vector of state probabilities of first case shape: (nstates,)","title":"HMM_nb"},{"location":"models/hmm/#narrowgate.model.hmm.HMM_nb--references","text":"Masters, Timothy. (2019) \"Extracting and Selecting Features for Data Mining: Algorithms in C++ and CUDA\". pp. 119-158. Parameters: Name Type Description Default n_init int Number of initial trial parameter sets to test for finding a good stating point for iteration. Larger values make it more likely that the iterations, which always converge to a local optimum, will find the global optimum. (a minimum of 1000 is recommended by Masters with a value of 10,000 not being unreasonable). 1000 max_iter int Iteration limit for convergence. This is insurance only, and should always be set very large to ensure complete convergence. Normally, convergence will be obtained long before this is hit. 100 Source code in narrowgate/model/hmm.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def __init__ ( self , n_init = 1000 , max_iter = 100 ): \"\"\" Parameters ---------- n_init : int Number of initial trial parameter sets to test for finding a good stating point for iteration. Larger values make it more likely that the iterations, which always converge to a local optimum, will find the global optimum. (a minimum of 1000 is recommended by Masters with a value of 10,000 not being unreasonable). max_iter : int Iteration limit for convergence. This is insurance only, and should always be set very large to ensure complete convergence. Normally, convergence will be obtained long before this is hit. \"\"\" self . n_init = n_init self . max_iter = max_iter","title":"References"},{"location":"models/hmm/#narrowgate.model.hmm.HMM_nb.fit","text":"fit ( X , nstates , max_iter = 100 ) Method for estimating the parameters of a Hidden Markov Model utilizing the Baum-Welch Algorithm. Important note The number of time series features (columns) in dataset X (referred to inside the method as nvars ) should ideally be between 2 and 5. Using 5 to 10 features should be considered extremely dangerous due to substantially increased runtime and memory usage. Parameters: Name Type Description Default X np.ndarray Numpy matrix (ncases, nvars) It is ideal that the each column/feature be at least moderately standardized (mean zero, unit variance), although this is not required. If the data contains any features (time series) which are nearly collinear (highly correlated) with one another, the modeling process will encounter significant trouble. However, some correlation amongst the columns is fine. required n_states int The number of hidden states for the model to posit. More than 3 to 4 states can produce highly unstable results required max_iter int The number of iterations to perform for finding the maximum likelihood parameters of the model. If the model converges prior to this number, early stopping will occur. If the method completes and the return value of n_iter is max_iter-1 , then complete convergence was not obtained. 100 Returns: Name Type Description n_iter int The number of iterations performed before complete convergence of the algorithm was obtained. If the value returned is max_iter-1 , then complete convergence was not obtained. likelihood float The log likelihood of the observations in X coming from the best performing set of model parameters found across the performed iterations. Source code in narrowgate/model/hmm.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def fit ( self , X , nstates , max_iter = 100 ): \"\"\" Method for estimating the parameters of a Hidden Markov Model utilizing the Baum-Welch Algorithm. **Important note** The number of time series features (columns) in dataset `X` (referred to inside the method as `nvars`) should ideally be between 2 and 5. Using 5 to 10 features should be considered extremely dangerous due to substantially increased runtime and memory usage. Parameters ---------- X : np.ndarray Numpy matrix (ncases, nvars) It is ideal that the each column/feature be at least moderately standardized (mean zero, unit variance), although this is not required. If the data contains any features (time series) which are nearly collinear (highly correlated) with one another, the modeling process will encounter significant trouble. However, some correlation amongst the columns is fine. n_states : int The number of hidden states for the model to posit. More than 3 to 4 states can produce highly unstable results max_iter : int The number of iterations to perform for finding the maximum likelihood parameters of the model. If the model converges prior to this number, early stopping will occur. If the method completes and the return value of `n_iter` is `max_iter-1`, then complete convergence was not obtained. Returns ------- n_iter : int The number of iterations performed before complete convergence of the algorithm was obtained. If the value returned is `max_iter-1`, then complete convergence was not obtained. likelihood : float The log likelihood of the observations in `X` coming from the best performing set of model parameters found across the performed iterations. \"\"\" assert max_iter > 0 , \"'max_iter' must be greater than 0!\" self . max_iter = max_iter data = X ncases = data . shape [ 0 ] nvars = data . shape [ 1 ] # Initialize members to be used throughout methods self . means = np . zeros (( nstates , nvars )) self . covars = np . zeros (( nstates , nvars , nvars )) self . densities = np . zeros (( nstates , ncases )) self . alpha = np . zeros (( ncases , nstates )) self . beta = np . zeros (( ncases , nstates )) self . init_probs = np . zeros ( nstates ) self . transition = np . zeros (( nstates , nstates )) self . state_probs = np . zeros (( ncases , nstates )) ################ ## Initialize ## ################ self . find_mean_covar ( data , nstates ) self . initialize ( data , nstates ) # Initialize some other objects needed for this method trans_work1 = np . zeros (( nstates , nstates )) trans_work2 = np . zeros (( nstates , nstates )) temp = 0.0 max_prod = 0.0 # Main outermost loop is here prior_likelihood = - 1.e200 # create floor array floor = np . zeros ( nstates ) floor [:] = 1.e-100 for n_iter in range ( self . max_iter ): # Compute alpha, beta, and log likelihood. # While backward_prob is not explicitly needed, it can serve as a # nice diagnostic. self . find_densities ( data , self . means ) likelihood = self . forward ( self . transition ) backward_prob = self . backward () #if (print || file_print) # print_params ( print , file_print , iter , likelihood , backward_prob ) ; ##################################################### ## Compute probability of each state for each case ## ##################################################### # Update means and covariances for icase in range ( ncases ): # Step 1 of 3: Find maximum of (alpha * beta) alpha_beta_prod = self . alpha [ icase ] * self . beta [ icase ] # test against floor alpha_beta_prod = np . maximum ( alpha_beta_prod , floor ) max_prod = np . max ( alpha_beta_prod ) sum_ = np . sum ( alpha_beta_prod / max_prod ) self . state_probs [ icase ] = \\ alpha_beta_prod / max_prod / sum_ self . update_mean_covar ( data ) # Update initial state probabilities and transition matrix # set 'init_probs' and zero out the trans_work2 matrix self . init_probs [:] = self . state_probs [ 0 ,:] trans_work2 [:,:] = 0.0 for icase in range ( 1 , ncases ): # Find max product for scaling; # save each product to avoid recomputing for istate in range ( nstates ): for jstate in range ( nstates ): if self . alpha [( icase - 1 ), istate ] > np . exp ( - 300.0 ): temp = np . log ( self . alpha [( icase - 1 ), istate ]) else : temp = - 300.0 if self . transition [ istate , jstate ] > np . exp ( - 300.0 ): temp += np . log ( self . transition [ istate , jstate ]) else : temp -= 300.0 if self . densities [ jstate , icase ] > np . exp ( - 300.0 ): temp += np . log ( self . densities [ jstate , icase ]) else : temp -= 300.0 if self . beta [ icase , istate ] > np . exp ( - 300.0 ): temp += np . log ( self . beta [ icase , jstate ]) else : temp -= 300.0 trans_work1 [ istate , jstate ] = temp if ( istate == 0 ) and ( jstate == 0 ): max_prod = temp else : max_prod = max ( temp , max_prod ) # Sum the exp() of the shifted terms trans_work1 = np . exp ( trans_work1 - max_prod ) sum_ = np . sum ( trans_work1 ) # Normalize to probabilities trans_work2 += trans_work1 / sum_ ####################### ## End for all cases ## ####################### for istate in range ( nstates ): sum_ = np . sum ( trans_work2 [ istate ]) self . transition [ istate ] = trans_work2 [ istate ] / sum_ # Check for convergence if ( n_iter > 0 ) and (( likelihood - prior_likelihood ) < 1.e-8 ): break prior_likelihood = likelihood ####################### ## End of iterations ## ####################### return n_iter , likelihood","title":"fit()"},{"location":"models/hmm/#narrowgate.model.hmm.HMM_nb.forward","text":"forward ( these_transitions ) Forward pass of Baum-Welch algorithm for finding maximum-likelihood parameters of a Hidden Markov Model. This is Master's enhanced version that use logarithmic values for increased numerical stability. Source code in narrowgate/model/hmm.py 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def forward ( self , these_transitions ): \"\"\" Forward pass of Baum-Welch algorithm for finding maximum-likelihood parameters of a Hidden Markov Model. This is Master's enhanced version that use logarithmic values for increased numerical stability. \"\"\" # Instance members # init_probs -> (nstates,) # alpha -> (ncases, nstates) # beta -> (ncases, nstates) # densities -> (nstates, ncases) # Parameters # these_transitions -> (nstates, nstates) ncases = self . densities . shape [ 1 ] nstates = self . densities . shape [ 0 ] # Initialize first case (t=0): self . alpha [ 0 ] = self . init_probs * self . densities [:, 0 ] denom = np . sum ( self . alpha [ 0 ]) log_likelihood = np . log ( denom ) self . alpha [ 0 ] /= denom # Recursion for remaining cases: # alpha[t,i] = Sum over j of (alpha[t-1,j]*transitions[j,i]) * densities[i,t] for t in range ( 1 , ncases ): for i in range ( nstates ): sum_ = np . sum ( self . alpha [ t - 1 ] * these_transitions [:, i ]) self . alpha [ t , i ] = sum_ * self . densities [ i , t ] denom = np . sum ( self . alpha [ t ]) log_likelihood += np . log ( denom ) self . alpha [ t ] /= denom return log_likelihood","title":"forward()"},{"location":"models/hmm/#narrowgate.model.hmm.HMM_nb.backward","text":"backward () Backward pass of Baum-Welch algorithm for finding maximum-likelihood parameters of a Hidden Markov Model. This is Master's enhanced version that use logarithmic values for increased numerical stability. Source code in narrowgate/model/hmm.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 def backward ( self ): \"\"\" Backward pass of Baum-Welch algorithm for finding maximum-likelihood parameters of a Hidden Markov Model. This is Master's enhanced version that use logarithmic values for increased numerical stability. \"\"\" # init_probs -> (nstates,) # beta -> (ncases, nstates) # densities -> (nstates, ncases) # these_transitions -> (nstates, nstates) ncases = self . densities . shape [ 1 ] nstates = self . densities . shape [ 0 ] # Initialize for last case (t=ncases-1): # beta[ncases-1,i] = 1.0 self . beta [ ncases - 1 ,:] = 1 / nstates log_likelihood = np . log ( nstates ) # Recursion for remaining cases: # beta[t,i] = \\ # Sum over j of (transition[i,j] * densities[j,t+1] * beta[t+1,j]) for t in range ( ncases - 2 , - 1 , - 1 ): denom = 0.0 for i in range ( nstates ): sum_ = \\ np . sum ( self . transition [ i ,:] * self . densities [:, t + 1 ] * self . beta [ t + 1 ,:]) self . beta [ t , i ] = sum_ denom += sum_ log_likelihood += np . log ( denom ) self . beta [ t ] /= denom # Termination: # Final probability = \\ # Sum over i of init_probs[i] * densities[i,0] * beta[0,i] sum_ = np . sum ( self . init_probs * self . densities [:, 0 ] * self . beta [ 0 ]) # Include the termination likelihood log_likelihood_terminal = np . log ( sum_ ) + log_likelihood return log_likelihood_terminal","title":"backward()"},{"location":"models/hmm/#narrowgate.model.hmm.HMM_nb.initialize","text":"initialize ( X , nstates ) Initialize starting parameters of a Hidden Markov Model. Tries some random values of means and transition probabilities to find the best likelihood in the parameter search space compared to other points in the space. Results from this method will serve as the starting point for iterations performed in the fit() method. Called after find_mean_covar() method. Source code in narrowgate/model/hmm.py 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 def initialize ( self , X , nstates ): \"\"\" Initialize starting parameters of a Hidden Markov Model. Tries some random values of means and transition probabilities to find the best likelihood in the parameter search space compared to other points in the space. Results from this method will serve as the starting point for iterations performed in the `fit()` method. Called after `find_mean_covar()` method. \"\"\" ncases = X . shape [ 0 ] nvars = X . shape [ 1 ] # create working arrays and matrices trial_transition = np . zeros (( nstates , nstates )) trial_means = np . zeros (( nstates , nvars )) init_covar = self . covars [ 0 ] . copy () # initialize probabilities self . init_probs [:] = 1 / nstates # Start main loop ... trying many combinations # For the first half of trials, assign equal transition probs prob = 1.0 / nstates trial_transition [:,:] = prob best_likelihood = - 1.e200 for itrial in range ( self . n_init ): # Perturb the means. Make sure the offsets sum to zero. for i in range ( nvars ): sum_ = 0.0 for istate in range ( nstates ): if ( istate < nstates - 1 ): unif_rand = np . random . random () - 0.5 wt = 6 * unif_rand * np . sqrt ( self . covars [ istate , i , i ]) sum_ += wt else : wt = - sum_ trial_means [ istate , i ] = self . means [ istate , i ] + wt # Perturb the covariances by shrinking # Shrinkage for diagonal wtd = 0.4 + 0.5 * np . random . random () # Shrinkage for off-diagonal wto = 0.7 * np . random . random () * wtd for i in range ( nvars ): for j in range ( nvars ): if ( i == j ): dtemp = wtd * init_covar [ i , j ] else : dtemp = wto * init_covar [ i , j ] ; for istate in range ( nstates ): self . covars [ istate , i , j ] = dtemp # Perturb the transition probabilities starting at half of the trials if itrial >= self . n_init / 2 : for istate in range ( nstates ): unif_rand = 0.4 + np . random . random () * 0.5 prob = unif_rand trial_transition [ istate , istate ] = unif_rand for i in range ( nstates ): if not i == istate : trial_transition [ istate , i ] = \\ ( 1 - prob ) / ( nstates - 1 ) #HMM::find_densities(double *these_means) self . find_densities ( X , trial_means ) likelihood = self . forward ( trial_transition ) # Print trial if requested #fprintf ( fp , \"\\n\\n\\nInitialization trial %d of %d\", itrial+1, n_trials ) ; #sprintf ( msg , \"State %d Means =\", istate ) ; #sprintf ( msg2 , \" %10.2lf\", trial_means[istate*nvars+i] ) ; #fprintf ( fp , \"\\n\\nCommon covariances...\" ) ; #fprintf ( fp, \"\\n\\nTransition probability matrix...\" ) ; #sprintf ( msg2 , \" %7.3lf\", trial_transition[i*nstates+j] ) ; # update best if ( itrial == 0 ) or ( likelihood > best_likelihood ): best_likelihood = likelihood #for (i=0 ; i<nstates*nvars ; i++) # best_means[i] = trial_means[i] ; best_means = trial_means . copy () #for (i=0 ; i<nvars*nvars ; i++) # best_covar[i] = covars[i] ; best_covar = self . covars [ 0 ] . copy () #for (i=0 ; i<nstates*nstates ; i++) # best_transition[i] = trial_transition[i] ; best_transition = trial_transition . copy () # The best are found. Copy them to the private versions. self . means [:,:] = best_means [:,:] self . transition [:,:] = best_transition [:,:] for istate in range ( nstates ): self . covars [ istate ] = best_covar [:,:]","title":"initialize()"},{"location":"models/hmm/#narrowgate.model.hmm.HMM_nb.find_mean_covar","text":"find_mean_covar ( data , nstates ) Compute means and covariances of features/columns. Called once before calling initialize() method. Source code in narrowgate/model/hmm.py 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 def find_mean_covar ( self , data , nstates ): \"\"\" Compute means and covariances of features/columns. Called once before calling `initialize()` method. \"\"\" nvars = data . shape [ 1 ] data_means = np . zeros ( nvars ) for i in range ( nvars ): data_means [ i ] = np . mean ( data [:, i ]) data_covar = np . cov ( data . transpose ()) for i in range ( nstates ): self . means [ i ] = data_means self . covars [ i ] = data_covar","title":"find_mean_covar()"},{"location":"models/hmm/#narrowgate.model.hmm.HMM_nb.find_densities","text":"find_densities ( data , these_means ) Compute densities of features/columns Source code in narrowgate/model/hmm.py 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def find_densities ( self , data , these_means ): \"\"\" Compute densities of features/columns \"\"\" nstates = self . densities . shape [ 0 ] ncases = data . shape [ 0 ] for istate in range ( nstates ): for i in range ( ncases ): self . densities [ istate , i ] = \\ mv_normal_pdf_nb ( data [ i ], these_means [ istate ], self . covars [ istate ])","title":"find_densities()"},{"location":"models/hmm/#narrowgate.model.hmm.HMM_nb.update_mean_covar","text":"update_mean_covar ( data ) Update means and covariances of features/columns. Source code in narrowgate/model/hmm.py 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 def update_mean_covar ( self , data ): \"\"\" Update means and covariances of features/columns. \"\"\" # X -> # means -> (nstates, nvars) # covars -> (nstates, nvars, nvars) # state_probs -> (ncases, nstates) ncases = data . shape [ 0 ] nvars = data . shape [ 1 ] nstates = self . state_probs . shape [ 1 ] for istate in range ( nstates ): # 'Reset' covars matrix for the given state self . covars [ istate ,:,:] = 0.0 # Prevent zero variance np . fill_diagonal ( self . covars [ istate ], 1.e-20 ) # retrieve the state probabilities to serve as weights weights = self . state_probs [:, istate ] denom = np . sum ( weights ) # Calculate the means for each variable according to the # state probabilities which serve as weights # The following line of code applies the vector of probabilities # for the given state (istate) to each variable/column in data. tmp = np . dot ( np . diag ( weights ), data ) for i in range ( nvars ): self . means [ istate , i ] = \\ np . sum ( tmp [:, i ]) / ( denom + 1.e-100 ) # calculate the covariance matrix # since weights need to be applied and numba does not support # weights in the 'nopython' mode, need to do this the same way # Masters does in C. assert ( data . shape [ 1 ] == self . means [ istate ] . shape [ 0 ]) # subtract the means for each variable for istate across all # observation in data (via broadcast) tmp = data - self . means [ istate ] for icase in range ( ncases ): weight = weights [ icase ] for i in range ( nvars ): for j in range ( nvars ): self . covars [ istate , i , j ] += \\ weight * tmp [ icase , i ] * tmp [ icase , j ] self . covars [ istate ] /= ( denom + 1.e-100 ) # ensure that matrix is invertible for i in range ( nvars ): for j in range ( nvars ): const1 = \\ ( 0.999999 * np . sqrt ( self . covars [ istate , i , i ] * self . covars [ istate , j , j ])) const2 = \\ ( - 0.999999 * np . sqrt ( self . covars [ istate , i , i ] * self . covars [ istate , j , j ])) cond0 = i != j cond1 = self . covars [ istate , i , j ] > const1 cond2 = self . covars [ istate , i , j ] < const2 if cond0 and cond1 : self . covars [ istate , i , j ] = const1 if cond0 and cond2 : self . covars [ istate , i , j ] = const2","title":"update_mean_covar()"},{"location":"models/linear_regression/","text":"LinearRegression_nb \u00a4 LinearRegression_nb ( alpha = 0.03 , n_iter = 1500 , quadratic = False , sgd = False ) Basic initialization of the class Source code in narrowgate/model/linear_model.py 32 33 34 35 36 37 38 39 40 41 42 43 44 def __init__ ( self , alpha = 0.03 , n_iter = 1500 , quadratic = False , sgd = False ): \"\"\" Basic initialization of the class \"\"\" self . alpha = alpha self . n_iter = n_iter self . quadratic = quadratic self . sgd = sgd fit \u00a4 fit ( X , y , scale_X = False , use_intercept = False ) Fit the linear regression model Source code in narrowgate/model/linear_model.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def fit ( self , X , y , scale_X = False , use_intercept = False ): \"\"\" Fit the linear regression model \"\"\" assert ( X . shape [ 0 ] == y . shape [ 0 ]) self . n_samples = X . shape [ 0 ] # Handle if 'X' is an array being passed in # convert to a matrix if X . ndim == 1 : X_mat = np . ascontiguousarray ( X ) X_mat = np . reshape ( X_mat , ( self . n_samples , 1 )) . astype ( np . float64 ) else : X_mat = X . copy () self . n_features = X_mat . shape [ 1 ] if self . sgd : assert ( y . ndim < 3 ) else : assert ( y . ndim == 1 ) self . scale_X = scale_X self . use_intercept = use_intercept if scale_X : X_mat , X_mean , X_stdev = scale_columnwise_nb ( X_mat ) self . X_mean = X_mean self . X_stdev = X_stdev else : self . X_mean = np . zeros ( self . n_features ) self . X_stdev = np . ones ( self . n_features ) # If this is a quadratic fit then the squares and cross product of # all the variables will need to be calculated and added into X_mat # Calculate the squares first and then the cross-products if self . quadratic : # squares X_mat = np . hstack (( X_mat , np . square ( X_mat ) . astype ( np . float64 ))) # cross-products for i in range ( self . n_features - 1 ): prod_col_mat = X_mat [:, i + 1 : self . n_features ] . transpose () work_col_vec = X_mat [:, i ] cross_prod_mat = \\ np . multiply ( prod_col_mat , work_col_vec ) . transpose () X_mat = \\ np . hstack (( X_mat , cross_prod_mat . astype ( np . float64 ))) # Add intercept if requested by the user if self . use_intercept : ones_matrix = np . ones (( self . n_samples , 1 )) . astype ( np . float64 ) X_mat = np . hstack (( ones_matrix , X_mat )) if self . sgd : # ensure that y is two dimensions if y . ndim == 2 : y_mat = y . reshape (( self . n_samples , y . shape [ 1 ])) . astype ( np . float64 ) else : # ndim is 1 y_mat = np . reshape ( y , ( self . n_samples , 1 )) . astype ( np . float64 ) n_params = X_mat . shape [ 1 ] work_params = np . zeros (( n_params , 1 )) X_T = X_mat . T for i in range ( self . n_iter ): work_params = \\ ( work_params - ( self . alpha / self . n_samples ) * np . dot ( X_T , ( np . dot ( X_mat , work_params ) - y_mat ))) self . params = work_params [:, 0 ] else : params , _ , _ , _ = \\ np . linalg . lstsq ( X_mat , y , rcond = 1.e-7 ) self . params = params return self score \u00a4 score ( X , y , method = 'rsquared' ) Parameters: Name Type Description Default method scoring criteria for assessing model fit 'rsquared' Source code in narrowgate/model/linear_model.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def score ( self , X , y , method = 'rsquared' ): \"\"\" Parameters ---------- method: {'rsquared', 'rss'}, default='rsquared' scoring criteria for assessing model fit \"\"\" if X . ndim == 1 : X_matrix = np . ascontiguousarray ( X ) n_obs = X_matrix . shape [ 0 ] X_matrix = \\ np . reshape ( X_matrix , ( n_obs , 1 )) . astype ( np . float64 ) else : X_matrix = X . copy () assert ( X_matrix . shape [ 1 ] == self . n_features ) n_samples = X_matrix . shape [ 0 ] # leverage the mean and stdev from the original # model that was trained if data needs to be scaled if self . scale_X : X_matrix = np . ascontiguousarray ( X_matrix ) for j in range ( self . n_features ): X_matrix [:, j ] = \\ ( X_matrix [:, j ] - self . X_mean [ j ]) / self . X_stdev [ j ] else : X_matrix = np . ascontiguousarray ( X_matrix ) # calculate squares and cross products if self . quadratic : # squares X_matrix = np . hstack (( X_matrix , np . square ( X_matrix ) . astype ( np . float64 ))) # cross-products for i in range ( self . n_features - 1 ): prod_col_mat = X_matrix [:, i + 1 : self . n_features ] . transpose () work_col_vec = np . ascontiguousarray ( X_matrix [:, i ]) cross_prod_mat = \\ np . multiply ( prod_col_mat , work_col_vec ) . transpose () X_matrix = \\ np . hstack (( X_matrix , cross_prod_mat . astype ( np . float64 ))) # add an intercept if model was trained with one if self . use_intercept : ones_matrix = np . ones (( n_samples , 1 )) . astype ( np . float64 ) X_matrix = np . hstack (( ones_matrix , X_matrix )) assert ( X_matrix . shape [ 1 ] == self . params . shape [ 0 ]) assert ( y . shape [ 0 ] == X_matrix . shape [ 0 ]) assert ( y . ndim == 1 ) X_matrix = np . ascontiguousarray ( X_matrix ) params = np . ascontiguousarray ( self . params ) y_pred = np . dot ( X_matrix , params ) y_mean = np . nanmean ( y ) y_mean_arr = np . zeros ( y . shape [ 0 ]) y_mean_arr . fill ( y_mean ) rss = np . sum ( np . square ( y - y_pred )) score_ = 0.0 if method == 'rsquared' : tss = np . sum ( np . square ( y - y_mean_arr )) score_ = 1 - ( rss / tss ) elif method == 'rss' : score_ = rss return score_","title":"LinearRegression_nb"},{"location":"models/linear_regression/#narrowgate.model.linear_model.LinearRegression_nb","text":"LinearRegression_nb ( alpha = 0.03 , n_iter = 1500 , quadratic = False , sgd = False ) Basic initialization of the class Source code in narrowgate/model/linear_model.py 32 33 34 35 36 37 38 39 40 41 42 43 44 def __init__ ( self , alpha = 0.03 , n_iter = 1500 , quadratic = False , sgd = False ): \"\"\" Basic initialization of the class \"\"\" self . alpha = alpha self . n_iter = n_iter self . quadratic = quadratic self . sgd = sgd","title":"LinearRegression_nb"},{"location":"models/linear_regression/#narrowgate.model.linear_model.LinearRegression_nb.fit","text":"fit ( X , y , scale_X = False , use_intercept = False ) Fit the linear regression model Source code in narrowgate/model/linear_model.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def fit ( self , X , y , scale_X = False , use_intercept = False ): \"\"\" Fit the linear regression model \"\"\" assert ( X . shape [ 0 ] == y . shape [ 0 ]) self . n_samples = X . shape [ 0 ] # Handle if 'X' is an array being passed in # convert to a matrix if X . ndim == 1 : X_mat = np . ascontiguousarray ( X ) X_mat = np . reshape ( X_mat , ( self . n_samples , 1 )) . astype ( np . float64 ) else : X_mat = X . copy () self . n_features = X_mat . shape [ 1 ] if self . sgd : assert ( y . ndim < 3 ) else : assert ( y . ndim == 1 ) self . scale_X = scale_X self . use_intercept = use_intercept if scale_X : X_mat , X_mean , X_stdev = scale_columnwise_nb ( X_mat ) self . X_mean = X_mean self . X_stdev = X_stdev else : self . X_mean = np . zeros ( self . n_features ) self . X_stdev = np . ones ( self . n_features ) # If this is a quadratic fit then the squares and cross product of # all the variables will need to be calculated and added into X_mat # Calculate the squares first and then the cross-products if self . quadratic : # squares X_mat = np . hstack (( X_mat , np . square ( X_mat ) . astype ( np . float64 ))) # cross-products for i in range ( self . n_features - 1 ): prod_col_mat = X_mat [:, i + 1 : self . n_features ] . transpose () work_col_vec = X_mat [:, i ] cross_prod_mat = \\ np . multiply ( prod_col_mat , work_col_vec ) . transpose () X_mat = \\ np . hstack (( X_mat , cross_prod_mat . astype ( np . float64 ))) # Add intercept if requested by the user if self . use_intercept : ones_matrix = np . ones (( self . n_samples , 1 )) . astype ( np . float64 ) X_mat = np . hstack (( ones_matrix , X_mat )) if self . sgd : # ensure that y is two dimensions if y . ndim == 2 : y_mat = y . reshape (( self . n_samples , y . shape [ 1 ])) . astype ( np . float64 ) else : # ndim is 1 y_mat = np . reshape ( y , ( self . n_samples , 1 )) . astype ( np . float64 ) n_params = X_mat . shape [ 1 ] work_params = np . zeros (( n_params , 1 )) X_T = X_mat . T for i in range ( self . n_iter ): work_params = \\ ( work_params - ( self . alpha / self . n_samples ) * np . dot ( X_T , ( np . dot ( X_mat , work_params ) - y_mat ))) self . params = work_params [:, 0 ] else : params , _ , _ , _ = \\ np . linalg . lstsq ( X_mat , y , rcond = 1.e-7 ) self . params = params return self","title":"fit()"},{"location":"models/linear_regression/#narrowgate.model.linear_model.LinearRegression_nb.score","text":"score ( X , y , method = 'rsquared' ) Parameters: Name Type Description Default method scoring criteria for assessing model fit 'rsquared' Source code in narrowgate/model/linear_model.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 def score ( self , X , y , method = 'rsquared' ): \"\"\" Parameters ---------- method: {'rsquared', 'rss'}, default='rsquared' scoring criteria for assessing model fit \"\"\" if X . ndim == 1 : X_matrix = np . ascontiguousarray ( X ) n_obs = X_matrix . shape [ 0 ] X_matrix = \\ np . reshape ( X_matrix , ( n_obs , 1 )) . astype ( np . float64 ) else : X_matrix = X . copy () assert ( X_matrix . shape [ 1 ] == self . n_features ) n_samples = X_matrix . shape [ 0 ] # leverage the mean and stdev from the original # model that was trained if data needs to be scaled if self . scale_X : X_matrix = np . ascontiguousarray ( X_matrix ) for j in range ( self . n_features ): X_matrix [:, j ] = \\ ( X_matrix [:, j ] - self . X_mean [ j ]) / self . X_stdev [ j ] else : X_matrix = np . ascontiguousarray ( X_matrix ) # calculate squares and cross products if self . quadratic : # squares X_matrix = np . hstack (( X_matrix , np . square ( X_matrix ) . astype ( np . float64 ))) # cross-products for i in range ( self . n_features - 1 ): prod_col_mat = X_matrix [:, i + 1 : self . n_features ] . transpose () work_col_vec = np . ascontiguousarray ( X_matrix [:, i ]) cross_prod_mat = \\ np . multiply ( prod_col_mat , work_col_vec ) . transpose () X_matrix = \\ np . hstack (( X_matrix , cross_prod_mat . astype ( np . float64 ))) # add an intercept if model was trained with one if self . use_intercept : ones_matrix = np . ones (( n_samples , 1 )) . astype ( np . float64 ) X_matrix = np . hstack (( ones_matrix , X_matrix )) assert ( X_matrix . shape [ 1 ] == self . params . shape [ 0 ]) assert ( y . shape [ 0 ] == X_matrix . shape [ 0 ]) assert ( y . ndim == 1 ) X_matrix = np . ascontiguousarray ( X_matrix ) params = np . ascontiguousarray ( self . params ) y_pred = np . dot ( X_matrix , params ) y_mean = np . nanmean ( y ) y_mean_arr = np . zeros ( y . shape [ 0 ]) y_mean_arr . fill ( y_mean ) rss = np . sum ( np . square ( y - y_pred )) score_ = 0.0 if method == 'rsquared' : tss = np . sum ( np . square ( y - y_mean_arr )) score_ = 1 - ( rss / tss ) elif method == 'rss' : score_ = rss return score_","title":"score()"},{"location":"notebooks/nominal2ordinal/","text":"(function (global, factory) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.ClipboardCopyElement = factory()); }(this, function () { 'use strict'; function createNode(text) { const node = document.createElement('pre'); node.style.width = '1px'; node.style.height = '1px'; node.style.position = 'fixed'; node.style.top = '5px'; node.textContent = text; return node; } function copyNode(node) { if ('clipboard' in navigator) { // eslint-disable-next-line flowtype/no-flow-fix-me-comments // $FlowFixMe Clipboard is not defined in Flow yet. return navigator.clipboard.writeText(node.textContent); } const selection = getSelection(); if (selection == null) { return Promise.reject(new Error()); } selection.removeAllRanges(); const range = document.createRange(); range.selectNodeContents(node); selection.addRange(range); document.execCommand('copy'); selection.removeAllRanges(); return Promise.resolve(); } function copyText(text) { if ('clipboard' in navigator) { // eslint-disable-next-line flowtype/no-flow-fix-me-comments // $FlowFixMe Clipboard is not defined in Flow yet. return navigator.clipboard.writeText(text); } const body = document.body; if (!body) { return Promise.reject(new Error()); } const node = createNode(text); body.appendChild(node); copyNode(node); body.removeChild(node); return Promise.resolve(); } function copy(button) { const id = button.getAttribute('for'); const text = button.getAttribute('value'); function trigger() { button.dispatchEvent(new CustomEvent('clipboard-copy', { bubbles: true })); } if (text) { copyText(text).then(trigger); } else if (id) { const root = 'getRootNode' in Element.prototype ? button.getRootNode() : button.ownerDocument; if (!(root instanceof Document || 'ShadowRoot' in window && root instanceof ShadowRoot)) return; const node = root.getElementById(id); if (node) copyTarget(node).then(trigger); } } function copyTarget(content) { if (content instanceof HTMLInputElement || content instanceof HTMLTextAreaElement) { return copyText(content.value); } else if (content instanceof HTMLAnchorElement && content.hasAttribute('href')) { return copyText(content.href); } else { return copyNode(content); } } function clicked(event) { const button = event.currentTarget; if (button instanceof HTMLElement) { copy(button); } } function keydown(event) { if (event.key === ' ' || event.key === 'Enter') { const button = event.currentTarget; if (button instanceof HTMLElement) { event.preventDefault(); copy(button); } } } function focused(event) { event.currentTarget.addEventListener('keydown', keydown); } function blurred(event) { event.currentTarget.removeEventListener('keydown', keydown); } class ClipboardCopyElement extends HTMLElement { constructor() { super(); this.addEventListener('click', clicked); this.addEventListener('focus', focused); this.addEventListener('blur', blurred); } connectedCallback() { if (!this.hasAttribute('tabindex')) { this.setAttribute('tabindex', '0'); } if (!this.hasAttribute('role')) { this.setAttribute('role', 'button'); } } get value() { return this.getAttribute('value') || ''; } set value(text) { this.setAttribute('value', text); } } if (!window.customElements.get('clipboard-copy')) { window.ClipboardCopyElement = ClipboardCopyElement; window.customElements.define('clipboard-copy', ClipboardCopyElement); } return ClipboardCopyElement; })); document.addEventListener('clipboard-copy', function(event) { const notice = event.target.querySelector('.notice') notice.hidden = false setTimeout(function() { notice.hidden = true }, 1000) }) pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; } span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; } .highlight-ipynb .hll { background-color: var(--jp-cell-editor-active-background) } .highlight-ipynb { background: var(--jp-cell-editor-background); color: var(--jp-mirror-editor-variable-color) } .highlight-ipynb .c { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment */ .highlight-ipynb .err { color: var(--jp-mirror-editor-error-color) } /* Error */ .highlight-ipynb .k { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword */ .highlight-ipynb .o { color: var(--jp-mirror-editor-operator-color); font-weight: bold } /* Operator */ .highlight-ipynb .p { color: var(--jp-mirror-editor-punctuation-color) } /* Punctuation */ .highlight-ipynb .ch { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Hashbang */ .highlight-ipynb .cm { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Multiline */ .highlight-ipynb .cp { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Preproc */ .highlight-ipynb .cpf { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.PreprocFile */ .highlight-ipynb .c1 { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Single */ .highlight-ipynb .cs { color: var(--jp-mirror-editor-comment-color); font-style: italic } /* Comment.Special */ .highlight-ipynb .kc { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Constant */ .highlight-ipynb .kd { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Declaration */ .highlight-ipynb .kn { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Namespace */ .highlight-ipynb .kp { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Pseudo */ .highlight-ipynb .kr { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Reserved */ .highlight-ipynb .kt { color: var(--jp-mirror-editor-keyword-color); font-weight: bold } /* Keyword.Type */ .highlight-ipynb .m { color: var(--jp-mirror-editor-number-color) } /* Literal.Number */ .highlight-ipynb .s { color: var(--jp-mirror-editor-string-color) } /* Literal.String */ .highlight-ipynb .ow { color: var(--jp-mirror-editor-operator-color); font-weight: bold } /* Operator.Word */ .highlight-ipynb .w { color: var(--jp-mirror-editor-variable-color) } /* Text.Whitespace */ .highlight-ipynb .mb { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Bin */ .highlight-ipynb .mf { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Float */ .highlight-ipynb .mh { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Hex */ .highlight-ipynb .mi { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Integer */ .highlight-ipynb .mo { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Oct */ .highlight-ipynb .sa { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Affix */ .highlight-ipynb .sb { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Backtick */ .highlight-ipynb .sc { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Char */ .highlight-ipynb .dl { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Delimiter */ .highlight-ipynb .sd { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Doc */ .highlight-ipynb .s2 { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Double */ .highlight-ipynb .se { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Escape */ .highlight-ipynb .sh { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Heredoc */ .highlight-ipynb .si { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Interpol */ .highlight-ipynb .sx { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Other */ .highlight-ipynb .sr { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Regex */ .highlight-ipynb .s1 { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Single */ .highlight-ipynb .ss { color: var(--jp-mirror-editor-string-color) } /* Literal.String.Symbol */ .highlight-ipynb .il { color: var(--jp-mirror-editor-number-color) } /* Literal.Number.Integer.Long */ /* This file is taken from the built JupyterLab theme.css Found on share/nbconvert/templates/lab/static Some changes have been made and marked with CHANGE */ .jupyter-wrapper { /* Elevation * * We style box-shadows using Material Design's idea of elevation. These particular numbers are taken from here: * * https://github.com/material-components/material-components-web * https://material-components-web.appspot.com/elevation.html */ --jp-shadow-base-lightness: 0; --jp-shadow-umbra-color: rgba( var(--jp-shadow-base-lightness), var(--jp-shadow-base-lightness), var(--jp-shadow-base-lightness), 0.2 ); --jp-shadow-penumbra-color: rgba( var(--jp-shadow-base-lightness), var(--jp-shadow-base-lightness), var(--jp-shadow-base-lightness), 0.14 ); --jp-shadow-ambient-color: rgba( var(--jp-shadow-base-lightness), var(--jp-shadow-base-lightness), var(--jp-shadow-base-lightness), 0.12 ); --jp-elevation-z0: none; --jp-elevation-z1: 0px 2px 1px -1px var(--jp-shadow-umbra-color), 0px 1px 1px 0px var(--jp-shadow-penumbra-color), 0px 1px 3px 0px var(--jp-shadow-ambient-color); --jp-elevation-z2: 0px 3px 1px -2px var(--jp-shadow-umbra-color), 0px 2px 2px 0px var(--jp-shadow-penumbra-color), 0px 1px 5px 0px var(--jp-shadow-ambient-color); --jp-elevation-z4: 0px 2px 4px -1px var(--jp-shadow-umbra-color), 0px 4px 5px 0px var(--jp-shadow-penumbra-color), 0px 1px 10px 0px var(--jp-shadow-ambient-color); --jp-elevation-z6: 0px 3px 5px -1px var(--jp-shadow-umbra-color), 0px 6px 10px 0px var(--jp-shadow-penumbra-color), 0px 1px 18px 0px var(--jp-shadow-ambient-color); --jp-elevation-z8: 0px 5px 5px -3px var(--jp-shadow-umbra-color), 0px 8px 10px 1px var(--jp-shadow-penumbra-color), 0px 3px 14px 2px var(--jp-shadow-ambient-color); --jp-elevation-z12: 0px 7px 8px -4px var(--jp-shadow-umbra-color), 0px 12px 17px 2px var(--jp-shadow-penumbra-color), 0px 5px 22px 4px var(--jp-shadow-ambient-color); --jp-elevation-z16: 0px 8px 10px -5px var(--jp-shadow-umbra-color), 0px 16px 24px 2px var(--jp-shadow-penumbra-color), 0px 6px 30px 5px var(--jp-shadow-ambient-color); --jp-elevation-z20: 0px 10px 13px -6px var(--jp-shadow-umbra-color), 0px 20px 31px 3px var(--jp-shadow-penumbra-color), 0px 8px 38px 7px var(--jp-shadow-ambient-color); --jp-elevation-z24: 0px 11px 15px -7px var(--jp-shadow-umbra-color), 0px 24px 38px 3px var(--jp-shadow-penumbra-color), 0px 9px 46px 8px var(--jp-shadow-ambient-color); /* Borders * * The following variables, specify the visual styling of borders in JupyterLab. */ --jp-border-width: 1px; --jp-border-color0: var(--md-grey-400); --jp-border-color1: var(--md-grey-400); --jp-border-color2: var(--md-grey-300); --jp-border-color3: var(--md-grey-200); --jp-border-radius: 2px; /* UI Fonts * * The UI font CSS variables are used for the typography all of the JupyterLab * user interface elements that are not directly user generated content. * * The font sizing here is done assuming that the body font size of --jp-ui-font-size1 * is applied to a parent element. When children elements, such as headings, are sized * in em all things will be computed relative to that body size. */ --jp-ui-font-scale-factor: 1.2; --jp-ui-font-size0: 0.83333em; --jp-ui-font-size1: 13px; /* Base font size */ --jp-ui-font-size2: 1.2em; --jp-ui-font-size3: 1.44em; --jp-ui-font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"; /* * Use these font colors against the corresponding main layout colors. * In a light theme, these go from dark to light. */ /* Defaults use Material Design specification */ --jp-ui-font-color0: rgba(0, 0, 0, 1); --jp-ui-font-color1: rgba(0, 0, 0, 0.87); --jp-ui-font-color2: rgba(0, 0, 0, 0.54); --jp-ui-font-color3: rgba(0, 0, 0, 0.38); /* * Use these against the brand/accent/warn/error colors. * These will typically go from light to darker, in both a dark and light theme. */ --jp-ui-inverse-font-color0: rgba(255, 255, 255, 1); --jp-ui-inverse-font-color1: rgba(255, 255, 255, 1); --jp-ui-inverse-font-color2: rgba(255, 255, 255, 0.7); --jp-ui-inverse-font-color3: rgba(255, 255, 255, 0.5); /* Content Fonts * * Content font variables are used for typography of user generated content. * * The font sizing here is done assuming that the body font size of --jp-content-font-size1 * is applied to a parent element. When children elements, such as headings, are sized * in em all things will be computed relative to that body size. */ --jp-content-line-height: 1.6; --jp-content-font-scale-factor: 1.2; --jp-content-font-size0: 0.83333em; --jp-content-font-size1: 14px; /* Base font size */ --jp-content-font-size2: 1.2em; --jp-content-font-size3: 1.44em; --jp-content-font-size4: 1.728em; --jp-content-font-size5: 2.0736em; /* This gives a magnification of about 125% in presentation mode over normal. */ --jp-content-presentation-font-size1: 17px; --jp-content-heading-line-height: 1; --jp-content-heading-margin-top: 1.2em; --jp-content-heading-margin-bottom: 0.8em; --jp-content-heading-font-weight: 500; /* Defaults use Material Design specification */ --jp-content-font-color0: rgba(0, 0, 0, 1); --jp-content-font-color1: rgba(0, 0, 0, 0.87); --jp-content-font-color2: rgba(0, 0, 0, 0.54); --jp-content-font-color3: rgba(0, 0, 0, 0.38); --jp-content-link-color: var(--md-blue-700); --jp-content-font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"; /* * Code Fonts * * Code font variables are used for typography of code and other monospaces content. */ --jp-code-font-size: 13px; --jp-code-line-height: 1.3077; /* 17px for 13px base */ --jp-code-padding: 5px; /* 5px for 13px base, codemirror highlighting needs integer px value */ --jp-code-font-family-default: Menlo, Consolas, \"DejaVu Sans Mono\", monospace; --jp-code-font-family: var(--jp-code-font-family-default); /* This gives a magnification of about 125% in presentation mode over normal. */ --jp-code-presentation-font-size: 16px; /* may need to tweak cursor width if you change font size */ --jp-code-cursor-width0: 1.4px; --jp-code-cursor-width1: 2px; --jp-code-cursor-width2: 4px; /* Layout * * The following are the main layout colors use in JupyterLab. In a light * theme these would go from light to dark. */ --jp-layout-color0: white; --jp-layout-color1: white; --jp-layout-color2: var(--md-grey-200); --jp-layout-color3: var(--md-grey-400); --jp-layout-color4: var(--md-grey-600); /* Inverse Layout * * The following are the inverse layout colors use in JupyterLab. In a light * theme these would go from dark to light. */ --jp-inverse-layout-color0: #111111; --jp-inverse-layout-color1: var(--md-grey-900); --jp-inverse-layout-color2: var(--md-grey-800); --jp-inverse-layout-color3: var(--md-grey-700); --jp-inverse-layout-color4: var(--md-grey-600); /* Brand/accent */ --jp-brand-color0: var(--md-blue-900); --jp-brand-color1: var(--md-blue-700); --jp-brand-color2: var(--md-blue-300); --jp-brand-color3: var(--md-blue-100); --jp-brand-color4: var(--md-blue-50); --jp-accent-color0: var(--md-green-900); --jp-accent-color1: var(--md-green-700); --jp-accent-color2: var(--md-green-300); --jp-accent-color3: var(--md-green-100); /* State colors (warn, error, success, info) */ --jp-warn-color0: var(--md-orange-900); --jp-warn-color1: var(--md-orange-700); --jp-warn-color2: var(--md-orange-300); --jp-warn-color3: var(--md-orange-100); --jp-error-color0: var(--md-red-900); --jp-error-color1: var(--md-red-700); --jp-error-color2: var(--md-red-300); --jp-error-color3: var(--md-red-100); --jp-success-color0: var(--md-green-900); --jp-success-color1: var(--md-green-700); --jp-success-color2: var(--md-green-300); --jp-success-color3: var(--md-green-100); --jp-info-color0: var(--md-cyan-900); --jp-info-color1: var(--md-cyan-700); --jp-info-color2: var(--md-cyan-300); --jp-info-color3: var(--md-cyan-100); /* Cell specific styles */ --jp-cell-padding: 5px; --jp-cell-collapser-width: 8px; --jp-cell-collapser-min-height: 20px; --jp-cell-collapser-not-active-hover-opacity: 0.6; --jp-cell-editor-background: var(--md-grey-100); --jp-cell-editor-border-color: var(--md-grey-300); --jp-cell-editor-box-shadow: inset 0 0 2px var(--md-blue-300); --jp-cell-editor-active-background: var(--jp-layout-color0); --jp-cell-editor-active-border-color: var(--jp-brand-color1); --jp-cell-prompt-width: 64px; --jp-cell-prompt-font-family: var(--jp-code-font-family-default); --jp-cell-prompt-letter-spacing: 0px; --jp-cell-prompt-opacity: 1; --jp-cell-prompt-not-active-opacity: 0.5; --jp-cell-prompt-not-active-font-color: var(--md-grey-700); /* A custom blend of MD grey and blue 600 * See https://meyerweb.com/eric/tools/color-blend/#546E7A:1E88E5:5:hex */ --jp-cell-inprompt-font-color: #307fc1; /* A custom blend of MD grey and orange 600 * https://meyerweb.com/eric/tools/color-blend/#546E7A:F4511E:5:hex */ --jp-cell-outprompt-font-color: #bf5b3d; /* Notebook specific styles */ --jp-notebook-padding: 10px; --jp-notebook-select-background: var(--jp-layout-color1); --jp-notebook-multiselected-color: var(--md-blue-50); /* The scroll padding is calculated to fill enough space at the bottom of the notebook to show one single-line cell (with appropriate padding) at the top when the notebook is scrolled all the way to the bottom. We also subtract one pixel so that no scrollbar appears if we have just one single-line cell in the notebook. This padding is to enable a 'scroll past end' feature in a notebook. */ --jp-notebook-scroll-padding: calc( 100% - var(--jp-code-font-size) * var(--jp-code-line-height) - var(--jp-code-padding) - var(--jp-cell-padding) - 1px ); /* Rendermime styles */ --jp-rendermime-error-background: #fdd; --jp-rendermime-table-row-background: var(--md-grey-100); --jp-rendermime-table-row-hover-background: var(--md-light-blue-50); /* Dialog specific styles */ --jp-dialog-background: rgba(0, 0, 0, 0.25); /* Console specific styles */ --jp-console-padding: 10px; /* Toolbar specific styles */ --jp-toolbar-border-color: var(--jp-border-color1); --jp-toolbar-micro-height: 8px; --jp-toolbar-background: var(--jp-layout-color1); --jp-toolbar-box-shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.24); --jp-toolbar-header-margin: 4px 4px 0px 4px; --jp-toolbar-active-background: var(--md-grey-300); /* Statusbar specific styles */ --jp-statusbar-height: 24px; /* Input field styles */ --jp-input-box-shadow: inset 0 0 2px var(--md-blue-300); --jp-input-active-background: var(--jp-layout-color1); --jp-input-hover-background: var(--jp-layout-color1); --jp-input-background: var(--md-grey-100); --jp-input-border-color: var(--jp-border-color1); --jp-input-active-border-color: var(--jp-brand-color1); --jp-input-active-box-shadow-color: rgba(19, 124, 189, 0.3); /* General editor styles */ --jp-editor-selected-background: #d9d9d9; --jp-editor-selected-focused-background: #d7d4f0; --jp-editor-cursor-color: var(--jp-ui-font-color0); /* Code mirror specific styles */ --jp-mirror-editor-keyword-color: #008000; --jp-mirror-editor-atom-color: #88f; --jp-mirror-editor-number-color: #080; --jp-mirror-editor-def-color: #00f; --jp-mirror-editor-variable-color: var(--md-grey-900); --jp-mirror-editor-variable-2-color: #05a; --jp-mirror-editor-variable-3-color: #085; --jp-mirror-editor-punctuation-color: #05a; --jp-mirror-editor-property-color: #05a; --jp-mirror-editor-operator-color: #aa22ff; --jp-mirror-editor-comment-color: #408080; --jp-mirror-editor-string-color: #ba2121; --jp-mirror-editor-string-2-color: #708; --jp-mirror-editor-meta-color: #aa22ff; --jp-mirror-editor-qualifier-color: #555; --jp-mirror-editor-builtin-color: #008000; --jp-mirror-editor-bracket-color: #997; --jp-mirror-editor-tag-color: #170; --jp-mirror-editor-attribute-color: #00c; --jp-mirror-editor-header-color: blue; --jp-mirror-editor-quote-color: #090; --jp-mirror-editor-link-color: #00c; --jp-mirror-editor-error-color: #f00; --jp-mirror-editor-hr-color: #999; /* Vega extension styles */ --jp-vega-background: white; /* Sidebar-related styles */ --jp-sidebar-min-width: 250px; /* Search-related styles */ --jp-search-toggle-off-opacity: 0.5; --jp-search-toggle-hover-opacity: 0.8; --jp-search-toggle-on-opacity: 1; --jp-search-selected-match-background-color: rgb(245, 200, 0); --jp-search-selected-match-color: black; --jp-search-unselected-match-background-color: var( --jp-inverse-layout-color0 ); --jp-search-unselected-match-color: var(--jp-ui-inverse-font-color0); /* Icon colors that work well with light or dark backgrounds */ --jp-icon-contrast-color0: var(--md-purple-600); --jp-icon-contrast-color1: var(--md-green-600); --jp-icon-contrast-color2: var(--md-pink-600); --jp-icon-contrast-color3: var(--md-blue-600); } [data-md-color-scheme=\"slate\"] .jupyter-wrapper { /* Elevation * * We style box-shadows using Material Design's idea of elevation. These particular numbers are taken from here: * * https://github.com/material-components/material-components-web * https://material-components-web.appspot.com/elevation.html */ /* The dark theme shadows need a bit of work, but this will probably also require work on the core layout * colors used in the theme as well. */ --jp-shadow-base-lightness: 32; --jp-shadow-umbra-color: rgba( var(--jp-shadow-base-lightness), var(--jp-shadow-base-lightness), var(--jp-shadow-base-lightness), 0.2 ); --jp-shadow-penumbra-color: rgba( var(--jp-shadow-base-lightness), var(--jp-shadow-base-lightness), var(--jp-shadow-base-lightness), 0.14 ); --jp-shadow-ambient-color: rgba( var(--jp-shadow-base-lightness), var(--jp-shadow-base-lightness), var(--jp-shadow-base-lightness), 0.12 ); --jp-elevation-z0: none; --jp-elevation-z1: 0px 2px 1px -1px var(--jp-shadow-umbra-color), 0px 1px 1px 0px var(--jp-shadow-penumbra-color), 0px 1px 3px 0px var(--jp-shadow-ambient-color); --jp-elevation-z2: 0px 3px 1px -2px var(--jp-shadow-umbra-color), 0px 2px 2px 0px var(--jp-shadow-penumbra-color), 0px 1px 5px 0px var(--jp-shadow-ambient-color); --jp-elevation-z4: 0px 2px 4px -1px var(--jp-shadow-umbra-color), 0px 4px 5px 0px var(--jp-shadow-penumbra-color), 0px 1px 10px 0px var(--jp-shadow-ambient-color); --jp-elevation-z6: 0px 3px 5px -1px var(--jp-shadow-umbra-color), 0px 6px 10px 0px var(--jp-shadow-penumbra-color), 0px 1px 18px 0px var(--jp-shadow-ambient-color); --jp-elevation-z8: 0px 5px 5px -3px var(--jp-shadow-umbra-color), 0px 8px 10px 1px var(--jp-shadow-penumbra-color), 0px 3px 14px 2px var(--jp-shadow-ambient-color); --jp-elevation-z12: 0px 7px 8px -4px var(--jp-shadow-umbra-color), 0px 12px 17px 2px var(--jp-shadow-penumbra-color), 0px 5px 22px 4px var(--jp-shadow-ambient-color); --jp-elevation-z16: 0px 8px 10px -5px var(--jp-shadow-umbra-color), 0px 16px 24px 2px var(--jp-shadow-penumbra-color), 0px 6px 30px 5px var(--jp-shadow-ambient-color); --jp-elevation-z20: 0px 10px 13px -6px var(--jp-shadow-umbra-color), 0px 20px 31px 3px var(--jp-shadow-penumbra-color), 0px 8px 38px 7px var(--jp-shadow-ambient-color); --jp-elevation-z24: 0px 11px 15px -7px var(--jp-shadow-umbra-color), 0px 24px 38px 3px var(--jp-shadow-penumbra-color), 0px 9px 46px 8px var(--jp-shadow-ambient-color); /* Borders * * The following variables, specify the visual styling of borders in JupyterLab. */ --jp-border-width: 1px; --jp-border-color0: var(--md-grey-700); --jp-border-color1: var(--md-grey-700); --jp-border-color2: var(--md-grey-800); --jp-border-color3: var(--md-grey-900); --jp-border-radius: 2px; /* UI Fonts * * The UI font CSS variables are used for the typography all of the JupyterLab * user interface elements that are not directly user generated content. * * The font sizing here is done assuming that the body font size of --jp-ui-font-size1 * is applied to a parent element. When children elements, such as headings, are sized * in em all things will be computed relative to that body size. */ --jp-ui-font-scale-factor: 1.2; --jp-ui-font-size0: 0.83333em; --jp-ui-font-size1: 13px; /* Base font size */ --jp-ui-font-size2: 1.2em; --jp-ui-font-size3: 1.44em; --jp-ui-font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"; /* * Use these font colors against the corresponding main layout colors. * In a light theme, these go from dark to light. */ /* Defaults use Material Design specification */ --jp-ui-font-color0: rgba(255, 255, 255, 1); --jp-ui-font-color1: rgba(255, 255, 255, 0.87); --jp-ui-font-color2: rgba(255, 255, 255, 0.54); --jp-ui-font-color3: rgba(255, 255, 255, 0.38); /* * Use these against the brand/accent/warn/error colors. * These will typically go from light to darker, in both a dark and light theme. */ --jp-ui-inverse-font-color0: rgba(0, 0, 0, 1); --jp-ui-inverse-font-color1: rgba(0, 0, 0, 0.8); --jp-ui-inverse-font-color2: rgba(0, 0, 0, 0.5); --jp-ui-inverse-font-color3: rgba(0, 0, 0, 0.3); /* Content Fonts * * Content font variables are used for typography of user generated content. * * The font sizing here is done assuming that the body font size of --jp-content-font-size1 * is applied to a parent element. When children elements, such as headings, are sized * in em all things will be computed relative to that body size. */ --jp-content-line-height: 1.6; --jp-content-font-scale-factor: 1.2; --jp-content-font-size0: 0.83333em; --jp-content-font-size1: 14px; /* Base font size */ --jp-content-font-size2: 1.2em; --jp-content-font-size3: 1.44em; --jp-content-font-size4: 1.728em; --jp-content-font-size5: 2.0736em; /* This gives a magnification of about 125% in presentation mode over normal. */ --jp-content-presentation-font-size1: 17px; --jp-content-heading-line-height: 1; --jp-content-heading-margin-top: 1.2em; --jp-content-heading-margin-bottom: 0.8em; --jp-content-heading-font-weight: 500; /* Defaults use Material Design specification */ --jp-content-font-color0: rgba(255, 255, 255, 1); --jp-content-font-color1: rgba(255, 255, 255, 1); --jp-content-font-color2: rgba(255, 255, 255, 0.7); --jp-content-font-color3: rgba(255, 255, 255, 0.5); --jp-content-link-color: var(--md-blue-300); --jp-content-font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"; /* * Code Fonts * * Code font variables are used for typography of code and other monospaces content. */ --jp-code-font-size: 13px; --jp-code-line-height: 1.3077; /* 17px for 13px base */ --jp-code-padding: 5px; /* 5px for 13px base, codemirror highlighting needs integer px value */ --jp-code-font-family-default: Menlo, Consolas, \"DejaVu Sans Mono\", monospace; --jp-code-font-family: var(--jp-code-font-family-default); /* This gives a magnification of about 125% in presentation mode over normal. */ --jp-code-presentation-font-size: 16px; /* may need to tweak cursor width if you change font size */ --jp-code-cursor-width0: 1.4px; --jp-code-cursor-width1: 2px; --jp-code-cursor-width2: 4px; /* Layout * * The following are the main layout colors use in JupyterLab. In a light * theme these would go from light to dark. */ --jp-layout-color0: #111111; --jp-layout-color1: var(--md-grey-900); --jp-layout-color2: var(--md-grey-800); --jp-layout-color3: var(--md-grey-700); --jp-layout-color4: var(--md-grey-600); /* Inverse Layout * * The following are the inverse layout colors use in JupyterLab. In a light * theme these would go from dark to light. */ --jp-inverse-layout-color0: white; --jp-inverse-layout-color1: white; --jp-inverse-layout-color2: var(--md-grey-200); --jp-inverse-layout-color3: var(--md-grey-400); --jp-inverse-layout-color4: var(--md-grey-600); /* Brand/accent */ --jp-brand-color0: var(--md-blue-700); --jp-brand-color1: var(--md-blue-500); --jp-brand-color2: var(--md-blue-300); --jp-brand-color3: var(--md-blue-100); --jp-brand-color4: var(--md-blue-50); --jp-accent-color0: var(--md-green-700); --jp-accent-color1: var(--md-green-500); --jp-accent-color2: var(--md-green-300); --jp-accent-color3: var(--md-green-100); /* State colors (warn, error, success, info) */ --jp-warn-color0: var(--md-orange-700); --jp-warn-color1: var(--md-orange-500); --jp-warn-color2: var(--md-orange-300); --jp-warn-color3: var(--md-orange-100); --jp-error-color0: var(--md-red-700); --jp-error-color1: var(--md-red-500); --jp-error-color2: var(--md-red-300); --jp-error-color3: var(--md-red-100); --jp-success-color0: var(--md-green-700); --jp-success-color1: var(--md-green-500); --jp-success-color2: var(--md-green-300); --jp-success-color3: var(--md-green-100); --jp-info-color0: var(--md-cyan-700); --jp-info-color1: var(--md-cyan-500); --jp-info-color2: var(--md-cyan-300); --jp-info-color3: var(--md-cyan-100); /* Cell specific styles */ --jp-cell-padding: 5px; --jp-cell-collapser-width: 8px; --jp-cell-collapser-min-height: 20px; --jp-cell-collapser-not-active-hover-opacity: 0.6; --jp-cell-editor-background: var(--jp-layout-color1); --jp-cell-editor-border-color: var(--md-grey-700); --jp-cell-editor-box-shadow: inset 0 0 2px var(--md-blue-300); --jp-cell-editor-active-background: var(--jp-layout-color0); --jp-cell-editor-active-border-color: var(--jp-brand-color1); --jp-cell-prompt-width: 64px; --jp-cell-prompt-font-family: var(--jp-code-font-family-default); --jp-cell-prompt-letter-spacing: 0px; --jp-cell-prompt-opacity: 1; --jp-cell-prompt-not-active-opacity: 1; --jp-cell-prompt-not-active-font-color: var(--md-grey-300); /* A custom blend of MD grey and blue 600 * See https://meyerweb.com/eric/tools/color-blend/#546E7A:1E88E5:5:hex */ --jp-cell-inprompt-font-color: #307fc1; /* A custom blend of MD grey and orange 600 * https://meyerweb.com/eric/tools/color-blend/#546E7A:F4511E:5:hex */ --jp-cell-outprompt-font-color: #bf5b3d; /* Notebook specific styles */ --jp-notebook-padding: 10px; --jp-notebook-select-background: var(--jp-layout-color1); --jp-notebook-multiselected-color: rgba(33, 150, 243, 0.24); /* The scroll padding is calculated to fill enough space at the bottom of the notebook to show one single-line cell (with appropriate padding) at the top when the notebook is scrolled all the way to the bottom. We also subtract one pixel so that no scrollbar appears if we have just one single-line cell in the notebook. This padding is to enable a 'scroll past end' feature in a notebook. */ --jp-notebook-scroll-padding: calc( 100% - var(--jp-code-font-size) * var(--jp-code-line-height) - var(--jp-code-padding) - var(--jp-cell-padding) - 1px ); /* Rendermime styles */ --jp-rendermime-error-background: rgba(244, 67, 54, 0.28); --jp-rendermime-table-row-background: var(--md-grey-900); --jp-rendermime-table-row-hover-background: rgba(3, 169, 244, 0.2); /* Dialog specific styles */ --jp-dialog-background: rgba(0, 0, 0, 0.6); /* Console specific styles */ --jp-console-padding: 10px; /* Toolbar specific styles */ --jp-toolbar-border-color: var(--jp-border-color2); --jp-toolbar-micro-height: 8px; --jp-toolbar-background: var(--jp-layout-color1); --jp-toolbar-box-shadow: 0px 0px 2px 0px rgba(0, 0, 0, 0.8); --jp-toolbar-header-margin: 4px 4px 0px 4px; --jp-toolbar-active-background: var(--jp-layout-color0); /* Statusbar specific styles */ --jp-statusbar-height: 24px; /* Input field styles */ --jp-input-box-shadow: inset 0 0 2px var(--md-blue-300); --jp-input-active-background: var(--jp-layout-color0); --jp-input-hover-background: var(--jp-layout-color2); --jp-input-background: var(--md-grey-800); --jp-input-border-color: var(--jp-border-color1); --jp-input-active-border-color: var(--jp-brand-color1); --jp-input-active-box-shadow-color: rgba(19, 124, 189, 0.3); /* General editor styles */ --jp-editor-selected-background: var(--jp-layout-color2); --jp-editor-selected-focused-background: rgba(33, 150, 243, 0.24); --jp-editor-cursor-color: var(--jp-ui-font-color0); /* Code mirror specific styles */ --jp-mirror-editor-keyword-color: var(--md-green-500); --jp-mirror-editor-atom-color: var(--md-blue-300); --jp-mirror-editor-number-color: var(--md-green-400); --jp-mirror-editor-def-color: var(--md-blue-600); --jp-mirror-editor-variable-color: var(--md-grey-300); --jp-mirror-editor-variable-2-color: var(--md-blue-400); --jp-mirror-editor-variable-3-color: var(--md-green-600); --jp-mirror-editor-punctuation-color: var(--md-blue-400); --jp-mirror-editor-property-color: var(--md-blue-400); --jp-mirror-editor-operator-color: #aa22ff; --jp-mirror-editor-comment-color: #408080; --jp-mirror-editor-string-color: #ff7070; --jp-mirror-editor-string-2-color: var(--md-purple-300); --jp-mirror-editor-meta-color: #aa22ff; --jp-mirror-editor-qualifier-color: #555; --jp-mirror-editor-builtin-color: var(--md-green-600); --jp-mirror-editor-bracket-color: #997; --jp-mirror-editor-tag-color: var(--md-green-700); --jp-mirror-editor-attribute-color: var(--md-blue-700); --jp-mirror-editor-header-color: var(--md-blue-500); --jp-mirror-editor-quote-color: var(--md-green-300); --jp-mirror-editor-link-color: var(--md-blue-700); --jp-mirror-editor-error-color: #f00; --jp-mirror-editor-hr-color: #999; /* Vega extension styles */ --jp-vega-background: var(--md-grey-400); /* Sidebar-related styles */ --jp-sidebar-min-width: 250px; /* Search-related styles */ --jp-search-toggle-off-opacity: 0.6; --jp-search-toggle-hover-opacity: 0.8; --jp-search-toggle-on-opacity: 1; --jp-search-selected-match-background-color: rgb(255, 225, 0); --jp-search-selected-match-color: black; --jp-search-unselected-match-background-color: var( --jp-inverse-layout-color0 ); --jp-search-unselected-match-color: var(--jp-ui-inverse-font-color0); /* scrollbar related styles. Supports every browser except Edge. */ /* colors based on JetBrain's Darcula theme */ --jp-scrollbar-background-color: #3f4244; --jp-scrollbar-thumb-color: 88, 96, 97; /* need to specify thumb color as an RGB triplet */ --jp-scrollbar-endpad: 3px; /* the minimum gap between the thumb and the ends of a scrollbar */ /* hacks for setting the thumb shape. These do nothing in Firefox */ --jp-scrollbar-thumb-margin: 3.5px; /* the space in between the sides of the thumb and the track */ --jp-scrollbar-thumb-radius: 9px; /* set to a large-ish value for rounded endcaps on the thumb */ /* Icon colors that work well with light or dark backgrounds */ --jp-icon-contrast-color0: var(--md-purple-600); --jp-icon-contrast-color1: var(--md-green-600); --jp-icon-contrast-color2: var(--md-pink-600); --jp-icon-contrast-color3: var(--md-blue-600); } :root{--md-red-50: #ffebee;--md-red-100: #ffcdd2;--md-red-200: #ef9a9a;--md-red-300: #e57373;--md-red-400: #ef5350;--md-red-500: #f44336;--md-red-600: #e53935;--md-red-700: #d32f2f;--md-red-800: #c62828;--md-red-900: #b71c1c;--md-red-A100: #ff8a80;--md-red-A200: #ff5252;--md-red-A400: #ff1744;--md-red-A700: #d50000;--md-pink-50: #fce4ec;--md-pink-100: #f8bbd0;--md-pink-200: #f48fb1;--md-pink-300: #f06292;--md-pink-400: #ec407a;--md-pink-500: #e91e63;--md-pink-600: #d81b60;--md-pink-700: #c2185b;--md-pink-800: #ad1457;--md-pink-900: #880e4f;--md-pink-A100: #ff80ab;--md-pink-A200: #ff4081;--md-pink-A400: #f50057;--md-pink-A700: #c51162;--md-purple-50: #f3e5f5;--md-purple-100: #e1bee7;--md-purple-200: #ce93d8;--md-purple-300: #ba68c8;--md-purple-400: #ab47bc;--md-purple-500: #9c27b0;--md-purple-600: #8e24aa;--md-purple-700: #7b1fa2;--md-purple-800: #6a1b9a;--md-purple-900: #4a148c;--md-purple-A100: #ea80fc;--md-purple-A200: #e040fb;--md-purple-A400: #d500f9;--md-purple-A700: #aa00ff;--md-deep-purple-50: #ede7f6;--md-deep-purple-100: #d1c4e9;--md-deep-purple-200: #b39ddb;--md-deep-purple-300: #9575cd;--md-deep-purple-400: #7e57c2;--md-deep-purple-500: #673ab7;--md-deep-purple-600: #5e35b1;--md-deep-purple-700: #512da8;--md-deep-purple-800: #4527a0;--md-deep-purple-900: #311b92;--md-deep-purple-A100: #b388ff;--md-deep-purple-A200: #7c4dff;--md-deep-purple-A400: #651fff;--md-deep-purple-A700: #6200ea;--md-indigo-50: #e8eaf6;--md-indigo-100: #c5cae9;--md-indigo-200: #9fa8da;--md-indigo-300: #7986cb;--md-indigo-400: #5c6bc0;--md-indigo-500: #3f51b5;--md-indigo-600: #3949ab;--md-indigo-700: #303f9f;--md-indigo-800: #283593;--md-indigo-900: #1a237e;--md-indigo-A100: #8c9eff;--md-indigo-A200: #536dfe;--md-indigo-A400: #3d5afe;--md-indigo-A700: #304ffe;--md-blue-50: #e3f2fd;--md-blue-100: #bbdefb;--md-blue-200: #90caf9;--md-blue-300: #64b5f6;--md-blue-400: #42a5f5;--md-blue-500: #2196f3;--md-blue-600: #1e88e5;--md-blue-700: #1976d2;--md-blue-800: #1565c0;--md-blue-900: #0d47a1;--md-blue-A100: #82b1ff;--md-blue-A200: #448aff;--md-blue-A400: #2979ff;--md-blue-A700: #2962ff;--md-light-blue-50: #e1f5fe;--md-light-blue-100: #b3e5fc;--md-light-blue-200: #81d4fa;--md-light-blue-300: #4fc3f7;--md-light-blue-400: #29b6f6;--md-light-blue-500: #03a9f4;--md-light-blue-600: #039be5;--md-light-blue-700: #0288d1;--md-light-blue-800: #0277bd;--md-light-blue-900: #01579b;--md-light-blue-A100: #80d8ff;--md-light-blue-A200: #40c4ff;--md-light-blue-A400: #00b0ff;--md-light-blue-A700: #0091ea;--md-cyan-50: #e0f7fa;--md-cyan-100: #b2ebf2;--md-cyan-200: #80deea;--md-cyan-300: #4dd0e1;--md-cyan-400: #26c6da;--md-cyan-500: #00bcd4;--md-cyan-600: #00acc1;--md-cyan-700: #0097a7;--md-cyan-800: #00838f;--md-cyan-900: #006064;--md-cyan-A100: #84ffff;--md-cyan-A200: #18ffff;--md-cyan-A400: #00e5ff;--md-cyan-A700: #00b8d4;--md-teal-50: #e0f2f1;--md-teal-100: #b2dfdb;--md-teal-200: #80cbc4;--md-teal-300: #4db6ac;--md-teal-400: #26a69a;--md-teal-500: #009688;--md-teal-600: #00897b;--md-teal-700: #00796b;--md-teal-800: #00695c;--md-teal-900: #004d40;--md-teal-A100: #a7ffeb;--md-teal-A200: #64ffda;--md-teal-A400: #1de9b6;--md-teal-A700: #00bfa5;--md-green-50: #e8f5e9;--md-green-100: #c8e6c9;--md-green-200: #a5d6a7;--md-green-300: #81c784;--md-green-400: #66bb6a;--md-green-500: #4caf50;--md-green-600: #43a047;--md-green-700: #388e3c;--md-green-800: #2e7d32;--md-green-900: #1b5e20;--md-green-A100: #b9f6ca;--md-green-A200: #69f0ae;--md-green-A400: #00e676;--md-green-A700: #00c853;--md-light-green-50: #f1f8e9;--md-light-green-100: #dcedc8;--md-light-green-200: #c5e1a5;--md-light-green-300: #aed581;--md-light-green-400: #9ccc65;--md-light-green-500: #8bc34a;--md-light-green-600: #7cb342;--md-light-green-700: #689f38;--md-light-green-800: #558b2f;--md-light-green-900: #33691e;--md-light-green-A100: #ccff90;--md-light-green-A200: #b2ff59;--md-light-green-A400: #76ff03;--md-light-green-A700: #64dd17;--md-lime-50: #f9fbe7;--md-lime-100: #f0f4c3;--md-lime-200: #e6ee9c;--md-lime-300: #dce775;--md-lime-400: #d4e157;--md-lime-500: #cddc39;--md-lime-600: #c0ca33;--md-lime-700: #afb42b;--md-lime-800: #9e9d24;--md-lime-900: #827717;--md-lime-A100: #f4ff81;--md-lime-A200: #eeff41;--md-lime-A400: #c6ff00;--md-lime-A700: #aeea00;--md-yellow-50: #fffde7;--md-yellow-100: #fff9c4;--md-yellow-200: #fff59d;--md-yellow-300: #fff176;--md-yellow-400: #ffee58;--md-yellow-500: #ffeb3b;--md-yellow-600: #fdd835;--md-yellow-700: #fbc02d;--md-yellow-800: #f9a825;--md-yellow-900: #f57f17;--md-yellow-A100: #ffff8d;--md-yellow-A200: #ffff00;--md-yellow-A400: #ffea00;--md-yellow-A700: #ffd600;--md-amber-50: #fff8e1;--md-amber-100: #ffecb3;--md-amber-200: #ffe082;--md-amber-300: #ffd54f;--md-amber-400: #ffca28;--md-amber-500: #ffc107;--md-amber-600: #ffb300;--md-amber-700: #ffa000;--md-amber-800: #ff8f00;--md-amber-900: #ff6f00;--md-amber-A100: #ffe57f;--md-amber-A200: #ffd740;--md-amber-A400: #ffc400;--md-amber-A700: #ffab00;--md-orange-50: #fff3e0;--md-orange-100: #ffe0b2;--md-orange-200: #ffcc80;--md-orange-300: #ffb74d;--md-orange-400: #ffa726;--md-orange-500: #ff9800;--md-orange-600: #fb8c00;--md-orange-700: #f57c00;--md-orange-800: #ef6c00;--md-orange-900: #e65100;--md-orange-A100: #ffd180;--md-orange-A200: #ffab40;--md-orange-A400: #ff9100;--md-orange-A700: #ff6d00;--md-deep-orange-50: #fbe9e7;--md-deep-orange-100: #ffccbc;--md-deep-orange-200: #ffab91;--md-deep-orange-300: #ff8a65;--md-deep-orange-400: #ff7043;--md-deep-orange-500: #ff5722;--md-deep-orange-600: #f4511e;--md-deep-orange-700: #e64a19;--md-deep-orange-800: #d84315;--md-deep-orange-900: #bf360c;--md-deep-orange-A100: #ff9e80;--md-deep-orange-A200: #ff6e40;--md-deep-orange-A400: #ff3d00;--md-deep-orange-A700: #dd2c00;--md-brown-50: #efebe9;--md-brown-100: #d7ccc8;--md-brown-200: #bcaaa4;--md-brown-300: #a1887f;--md-brown-400: #8d6e63;--md-brown-500: #795548;--md-brown-600: #6d4c41;--md-brown-700: #5d4037;--md-brown-800: #4e342e;--md-brown-900: #3e2723;--md-grey-50: #fafafa;--md-grey-100: #f5f5f5;--md-grey-200: #eeeeee;--md-grey-300: #e0e0e0;--md-grey-400: #bdbdbd;--md-grey-500: #9e9e9e;--md-grey-600: #757575;--md-grey-700: #616161;--md-grey-800: #424242;--md-grey-900: #212121;--md-blue-grey-50: #eceff1;--md-blue-grey-100: #cfd8dc;--md-blue-grey-200: #b0bec5;--md-blue-grey-300: #90a4ae;--md-blue-grey-400: #78909c;--md-blue-grey-500: #607d8b;--md-blue-grey-600: #546e7a;--md-blue-grey-700: #455a64;--md-blue-grey-800: #37474f;--md-blue-grey-900: #263238}.jupyter-wrapper{/*! Copyright 2015-present Palantir Technologies, Inc. All rights reserved. Licensed under the Apache License, Version 2.0. *//*! Copyright 2017-present Palantir Technologies, Inc. All rights reserved. Licensed under the Apache License, Version 2.0. */}.jupyter-wrapper [data-jp-theme-scrollbars=true]{scrollbar-color:rgb(var(--jp-scrollbar-thumb-color)) var(--jp-scrollbar-background-color)}.jupyter-wrapper [data-jp-theme-scrollbars=true] .CodeMirror-hscrollbar,.jupyter-wrapper [data-jp-theme-scrollbars=true] .CodeMirror-vscrollbar{scrollbar-color:rgba(var(--jp-scrollbar-thumb-color), 0.5) transparent}.jupyter-wrapper [data-jp-theme-scrollbars=true] ::-webkit-scrollbar,.jupyter-wrapper [data-jp-theme-scrollbars=true] ::-webkit-scrollbar-corner{background:var(--jp-scrollbar-background-color)}.jupyter-wrapper [data-jp-theme-scrollbars=true] ::-webkit-scrollbar-thumb{background:rgb(var(--jp-scrollbar-thumb-color));border:var(--jp-scrollbar-thumb-margin) solid transparent;background-clip:content-box;border-radius:var(--jp-scrollbar-thumb-radius)}.jupyter-wrapper [data-jp-theme-scrollbars=true] ::-webkit-scrollbar-track:horizontal{border-left:var(--jp-scrollbar-endpad) solid var(--jp-scrollbar-background-color);border-right:var(--jp-scrollbar-endpad) solid var(--jp-scrollbar-background-color)}.jupyter-wrapper [data-jp-theme-scrollbars=true] ::-webkit-scrollbar-track:vertical{border-top:var(--jp-scrollbar-endpad) solid var(--jp-scrollbar-background-color);border-bottom:var(--jp-scrollbar-endpad) solid var(--jp-scrollbar-background-color)}.jupyter-wrapper [data-jp-theme-scrollbars=true] .CodeMirror-hscrollbar::-webkit-scrollbar,.jupyter-wrapper [data-jp-theme-scrollbars=true] .CodeMirror-vscrollbar::-webkit-scrollbar,.jupyter-wrapper [data-jp-theme-scrollbars=true] .CodeMirror-hscrollbar::-webkit-scrollbar-corner,.jupyter-wrapper [data-jp-theme-scrollbars=true] .CodeMirror-vscrollbar::-webkit-scrollbar-corner{background-color:transparent}.jupyter-wrapper [data-jp-theme-scrollbars=true] .CodeMirror-hscrollbar::-webkit-scrollbar-thumb,.jupyter-wrapper [data-jp-theme-scrollbars=true] .CodeMirror-vscrollbar::-webkit-scrollbar-thumb{background:rgba(var(--jp-scrollbar-thumb-color), 0.5);border:var(--jp-scrollbar-thumb-margin) solid transparent;background-clip:content-box;border-radius:var(--jp-scrollbar-thumb-radius)}.jupyter-wrapper [data-jp-theme-scrollbars=true] .CodeMirror-hscrollbar::-webkit-scrollbar-track:horizontal{border-left:var(--jp-scrollbar-endpad) solid transparent;border-right:var(--jp-scrollbar-endpad) solid transparent}.jupyter-wrapper [data-jp-theme-scrollbars=true] .CodeMirror-vscrollbar::-webkit-scrollbar-track:vertical{border-top:var(--jp-scrollbar-endpad) solid transparent;border-bottom:var(--jp-scrollbar-endpad) solid transparent}.jupyter-wrapper .lm-ScrollBar[data-orientation=horizontal]{min-height:16px;max-height:16px;min-width:45px;border-top:1px solid #a0a0a0}.jupyter-wrapper .lm-ScrollBar[data-orientation=vertical]{min-width:16px;max-width:16px;min-height:45px;border-left:1px solid #a0a0a0}.jupyter-wrapper .lm-ScrollBar-button{background-color:#f0f0f0;background-position:center center;min-height:15px;max-height:15px;min-width:15px;max-width:15px}.jupyter-wrapper .lm-ScrollBar-button:hover{background-color:#dadada}.jupyter-wrapper .lm-ScrollBar-button.lm-mod-active{background-color:#cdcdcd}.jupyter-wrapper .lm-ScrollBar-track{background:#f0f0f0}.jupyter-wrapper .lm-ScrollBar-thumb{background:#cdcdcd}.jupyter-wrapper .lm-ScrollBar-thumb:hover{background:#bababa}.jupyter-wrapper .lm-ScrollBar-thumb.lm-mod-active{background:#a0a0a0}.jupyter-wrapper .lm-ScrollBar[data-orientation=horizontal] .lm-ScrollBar-thumb{height:100%;min-width:15px;border-left:1px solid #a0a0a0;border-right:1px solid #a0a0a0}.jupyter-wrapper .lm-ScrollBar[data-orientation=vertical] .lm-ScrollBar-thumb{width:100%;min-height:15px;border-top:1px solid #a0a0a0;border-bottom:1px solid #a0a0a0}.jupyter-wrapper .lm-ScrollBar[data-orientation=horizontal] .lm-ScrollBar-button[data-action=decrement]{background-image:var(--jp-icon-caret-left);background-size:17px}.jupyter-wrapper .lm-ScrollBar[data-orientation=horizontal] .lm-ScrollBar-button[data-action=increment]{background-image:var(--jp-icon-caret-right);background-size:17px}.jupyter-wrapper .lm-ScrollBar[data-orientation=vertical] .lm-ScrollBar-button[data-action=decrement]{background-image:var(--jp-icon-caret-up);background-size:17px}.jupyter-wrapper .lm-ScrollBar[data-orientation=vertical] .lm-ScrollBar-button[data-action=increment]{background-image:var(--jp-icon-caret-down);background-size:17px}.jupyter-wrapper .p-Widget,.jupyter-wrapper .lm-Widget{box-sizing:border-box;position:relative;overflow:hidden;cursor:default}.jupyter-wrapper .p-Widget.p-mod-hidden,.jupyter-wrapper .lm-Widget.lm-mod-hidden{display:none !important}.jupyter-wrapper .p-CommandPalette,.jupyter-wrapper .lm-CommandPalette{display:flex;flex-direction:column;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.jupyter-wrapper .p-CommandPalette-search,.jupyter-wrapper .lm-CommandPalette-search{flex:0 0 auto}.jupyter-wrapper .p-CommandPalette-content,.jupyter-wrapper .lm-CommandPalette-content{flex:1 1 auto;margin:0;padding:0;min-height:0;overflow:auto;list-style-type:none}.jupyter-wrapper .p-CommandPalette-header,.jupyter-wrapper .lm-CommandPalette-header{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.jupyter-wrapper .p-CommandPalette-item,.jupyter-wrapper .lm-CommandPalette-item{display:flex;flex-direction:row}.jupyter-wrapper .p-CommandPalette-itemIcon,.jupyter-wrapper .lm-CommandPalette-itemIcon{flex:0 0 auto}.jupyter-wrapper .p-CommandPalette-itemContent,.jupyter-wrapper .lm-CommandPalette-itemContent{flex:1 1 auto;overflow:hidden}.jupyter-wrapper .p-CommandPalette-itemShortcut,.jupyter-wrapper .lm-CommandPalette-itemShortcut{flex:0 0 auto}.jupyter-wrapper .p-CommandPalette-itemLabel,.jupyter-wrapper .lm-CommandPalette-itemLabel{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.jupyter-wrapper .p-DockPanel,.jupyter-wrapper .lm-DockPanel{z-index:0}.jupyter-wrapper .p-DockPanel-widget,.jupyter-wrapper .lm-DockPanel-widget{z-index:0}.jupyter-wrapper .p-DockPanel-tabBar,.jupyter-wrapper .lm-DockPanel-tabBar{z-index:1}.jupyter-wrapper .p-DockPanel-handle,.jupyter-wrapper .lm-DockPanel-handle{z-index:2}.jupyter-wrapper .p-DockPanel-handle.p-mod-hidden,.jupyter-wrapper .lm-DockPanel-handle.lm-mod-hidden{display:none !important}.jupyter-wrapper .p-DockPanel-handle:after,.jupyter-wrapper .lm-DockPanel-handle:after{position:absolute;top:0;left:0;width:100%;height:100%;content:\"\"}.jupyter-wrapper .p-DockPanel-handle[data-orientation=horizontal],.jupyter-wrapper .lm-DockPanel-handle[data-orientation=horizontal]{cursor:ew-resize}.jupyter-wrapper .p-DockPanel-handle[data-orientation=vertical],.jupyter-wrapper .lm-DockPanel-handle[data-orientation=vertical]{cursor:ns-resize}.jupyter-wrapper .p-DockPanel-handle[data-orientation=horizontal]:after,.jupyter-wrapper .lm-DockPanel-handle[data-orientation=horizontal]:after{left:50%;min-width:8px;transform:translateX(-50%)}.jupyter-wrapper .p-DockPanel-handle[data-orientation=vertical]:after,.jupyter-wrapper .lm-DockPanel-handle[data-orientation=vertical]:after{top:50%;min-height:8px;transform:translateY(-50%)}.jupyter-wrapper .p-DockPanel-overlay,.jupyter-wrapper .lm-DockPanel-overlay{z-index:3;box-sizing:border-box;pointer-events:none}.jupyter-wrapper .p-DockPanel-overlay.p-mod-hidden,.jupyter-wrapper .lm-DockPanel-overlay.lm-mod-hidden{display:none !important}.jupyter-wrapper .p-Menu,.jupyter-wrapper .lm-Menu{z-index:10000;position:absolute;white-space:nowrap;overflow-x:hidden;overflow-y:auto;outline:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.jupyter-wrapper .p-Menu-content,.jupyter-wrapper .lm-Menu-content{margin:0;padding:0;display:table;list-style-type:none}.jupyter-wrapper .p-Menu-item,.jupyter-wrapper .lm-Menu-item{display:table-row}.jupyter-wrapper .p-Menu-item.p-mod-hidden,.jupyter-wrapper .p-Menu-item.p-mod-collapsed,.jupyter-wrapper .lm-Menu-item.lm-mod-hidden,.jupyter-wrapper .lm-Menu-item.lm-mod-collapsed{display:none !important}.jupyter-wrapper .p-Menu-itemIcon,.jupyter-wrapper .p-Menu-itemSubmenuIcon,.jupyter-wrapper .lm-Menu-itemIcon,.jupyter-wrapper .lm-Menu-itemSubmenuIcon{display:table-cell;text-align:center}.jupyter-wrapper .p-Menu-itemLabel,.jupyter-wrapper .lm-Menu-itemLabel{display:table-cell;text-align:left}.jupyter-wrapper .p-Menu-itemShortcut,.jupyter-wrapper .lm-Menu-itemShortcut{display:table-cell;text-align:right}.jupyter-wrapper .p-MenuBar,.jupyter-wrapper .lm-MenuBar{outline:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.jupyter-wrapper .p-MenuBar-content,.jupyter-wrapper .lm-MenuBar-content{margin:0;padding:0;display:flex;flex-direction:row;list-style-type:none}.jupyter-wrapper .p--MenuBar-item,.jupyter-wrapper .lm-MenuBar-item{box-sizing:border-box}.jupyter-wrapper .p-MenuBar-itemIcon,.jupyter-wrapper .p-MenuBar-itemLabel,.jupyter-wrapper .lm-MenuBar-itemIcon,.jupyter-wrapper .lm-MenuBar-itemLabel{display:inline-block}.jupyter-wrapper .p-ScrollBar,.jupyter-wrapper .lm-ScrollBar{display:flex;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.jupyter-wrapper .p-ScrollBar[data-orientation=horizontal],.jupyter-wrapper .lm-ScrollBar[data-orientation=horizontal]{flex-direction:row}.jupyter-wrapper .p-ScrollBar[data-orientation=vertical],.jupyter-wrapper .lm-ScrollBar[data-orientation=vertical]{flex-direction:column}.jupyter-wrapper .p-ScrollBar-button,.jupyter-wrapper .lm-ScrollBar-button{box-sizing:border-box;flex:0 0 auto}.jupyter-wrapper .p-ScrollBar-track,.jupyter-wrapper .lm-ScrollBar-track{box-sizing:border-box;position:relative;overflow:hidden;flex:1 1 auto}.jupyter-wrapper .p-ScrollBar-thumb,.jupyter-wrapper .lm-ScrollBar-thumb{box-sizing:border-box;position:absolute}.jupyter-wrapper .p-SplitPanel-child,.jupyter-wrapper .lm-SplitPanel-child{z-index:0}.jupyter-wrapper .p-SplitPanel-handle,.jupyter-wrapper .lm-SplitPanel-handle{z-index:1}.jupyter-wrapper .p-SplitPanel-handle.p-mod-hidden,.jupyter-wrapper .lm-SplitPanel-handle.lm-mod-hidden{display:none !important}.jupyter-wrapper .p-SplitPanel-handle:after,.jupyter-wrapper .lm-SplitPanel-handle:after{position:absolute;top:0;left:0;width:100%;height:100%;content:\"\"}.jupyter-wrapper .p-SplitPanel[data-orientation=horizontal]>.p-SplitPanel-handle,.jupyter-wrapper .lm-SplitPanel[data-orientation=horizontal]>.lm-SplitPanel-handle{cursor:ew-resize}.jupyter-wrapper .p-SplitPanel[data-orientation=vertical]>.p-SplitPanel-handle,.jupyter-wrapper .lm-SplitPanel[data-orientation=vertical]>.lm-SplitPanel-handle{cursor:ns-resize}.jupyter-wrapper .p-SplitPanel[data-orientation=horizontal]>.p-SplitPanel-handle:after,.jupyter-wrapper .lm-SplitPanel[data-orientation=horizontal]>.lm-SplitPanel-handle:after{left:50%;min-width:8px;transform:translateX(-50%)}.jupyter-wrapper .p-SplitPanel[data-orientation=vertical]>.p-SplitPanel-handle:after,.jupyter-wrapper .lm-SplitPanel[data-orientation=vertical]>.lm-SplitPanel-handle:after{top:50%;min-height:8px;transform:translateY(-50%)}.jupyter-wrapper .p-TabBar,.jupyter-wrapper .lm-TabBar{display:flex;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.jupyter-wrapper .p-TabBar[data-orientation=horizontal],.jupyter-wrapper .lm-TabBar[data-orientation=horizontal]{flex-direction:row}.jupyter-wrapper .p-TabBar[data-orientation=vertical],.jupyter-wrapper .lm-TabBar[data-orientation=vertical]{flex-direction:column}.jupyter-wrapper .p-TabBar-content,.jupyter-wrapper .lm-TabBar-content{margin:0;padding:0;display:flex;flex:1 1 auto;list-style-type:none}.jupyter-wrapper .p-TabBar[data-orientation=horizontal]>.p-TabBar-content,.jupyter-wrapper .lm-TabBar[data-orientation=horizontal]>.lm-TabBar-content{flex-direction:row}.jupyter-wrapper .p-TabBar[data-orientation=vertical]>.p-TabBar-content,.jupyter-wrapper .lm-TabBar[data-orientation=vertical]>.lm-TabBar-content{flex-direction:column}.jupyter-wrapper .p-TabBar-tab,.jupyter-wrapper .lm-TabBar-tab{display:flex;flex-direction:row;box-sizing:border-box;overflow:hidden}.jupyter-wrapper .p-TabBar-tabIcon,.jupyter-wrapper .p-TabBar-tabCloseIcon,.jupyter-wrapper .lm-TabBar-tabIcon,.jupyter-wrapper .lm-TabBar-tabCloseIcon{flex:0 0 auto}.jupyter-wrapper .p-TabBar-tabLabel,.jupyter-wrapper .lm-TabBar-tabLabel{flex:1 1 auto;overflow:hidden;white-space:nowrap}.jupyter-wrapper .p-TabBar-tab.p-mod-hidden,.jupyter-wrapper .lm-TabBar-tab.lm-mod-hidden{display:none !important}.jupyter-wrapper .p-TabBar.p-mod-dragging .p-TabBar-tab,.jupyter-wrapper .lm-TabBar.lm-mod-dragging .lm-TabBar-tab{position:relative}.jupyter-wrapper .p-TabBar.p-mod-dragging[data-orientation=horizontal] .p-TabBar-tab,.jupyter-wrapper .lm-TabBar.lm-mod-dragging[data-orientation=horizontal] .lm-TabBar-tab{left:0;transition:left 150ms ease}.jupyter-wrapper .p-TabBar.p-mod-dragging[data-orientation=vertical] .p-TabBar-tab,.jupyter-wrapper .lm-TabBar.lm-mod-dragging[data-orientation=vertical] .lm-TabBar-tab{top:0;transition:top 150ms ease}.jupyter-wrapper .p-TabBar.p-mod-dragging .p-TabBar-tab.p-mod-dragging .lm-TabBar.lm-mod-dragging .lm-TabBar-tab.lm-mod-dragging{transition:none}.jupyter-wrapper .p-TabPanel-tabBar,.jupyter-wrapper .lm-TabPanel-tabBar{z-index:1}.jupyter-wrapper .p-TabPanel-stackedPanel,.jupyter-wrapper .lm-TabPanel-stackedPanel{z-index:0}.jupyter-wrapper ::-moz-selection{background:rgba(125,188,255,.6)}.jupyter-wrapper ::selection{background:rgba(125,188,255,.6)}.jupyter-wrapper .bp3-heading{color:#182026;font-weight:600;margin:0 0 10px;padding:0}.jupyter-wrapper .bp3-dark .bp3-heading{color:#f5f8fa}.jupyter-wrapper h1.bp3-heading,.jupyter-wrapper .bp3-running-text h1{line-height:40px;font-size:36px}.jupyter-wrapper h2.bp3-heading,.jupyter-wrapper .bp3-running-text h2{line-height:32px;font-size:28px}.jupyter-wrapper h3.bp3-heading,.jupyter-wrapper .bp3-running-text h3{line-height:25px;font-size:22px}.jupyter-wrapper h4.bp3-heading,.jupyter-wrapper .bp3-running-text h4{line-height:21px;font-size:18px}.jupyter-wrapper h5.bp3-heading,.jupyter-wrapper .bp3-running-text h5{line-height:19px;font-size:16px}.jupyter-wrapper h6.bp3-heading,.jupyter-wrapper .bp3-running-text h6{line-height:16px;font-size:14px}.jupyter-wrapper .bp3-ui-text{text-transform:none;line-height:1.28581;letter-spacing:0;font-size:14px;font-weight:400}.jupyter-wrapper .bp3-monospace-text{text-transform:none;font-family:monospace}.jupyter-wrapper .bp3-text-muted{color:#5c7080}.jupyter-wrapper .bp3-dark .bp3-text-muted{color:#a7b6c2}.jupyter-wrapper .bp3-text-disabled{color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-dark .bp3-text-disabled{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-text-overflow-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-wrap:normal}.jupyter-wrapper .bp3-running-text{line-height:1.5;font-size:14px}.jupyter-wrapper .bp3-running-text h1{color:#182026;font-weight:600;margin-top:40px;margin-bottom:20px}.jupyter-wrapper .bp3-dark .bp3-running-text h1{color:#f5f8fa}.jupyter-wrapper .bp3-running-text h2{color:#182026;font-weight:600;margin-top:40px;margin-bottom:20px}.jupyter-wrapper .bp3-dark .bp3-running-text h2{color:#f5f8fa}.jupyter-wrapper .bp3-running-text h3{color:#182026;font-weight:600;margin-top:40px;margin-bottom:20px}.jupyter-wrapper .bp3-dark .bp3-running-text h3{color:#f5f8fa}.jupyter-wrapper .bp3-running-text h4{color:#182026;font-weight:600;margin-top:40px;margin-bottom:20px}.jupyter-wrapper .bp3-dark .bp3-running-text h4{color:#f5f8fa}.jupyter-wrapper .bp3-running-text h5{color:#182026;font-weight:600;margin-top:40px;margin-bottom:20px}.jupyter-wrapper .bp3-dark .bp3-running-text h5{color:#f5f8fa}.jupyter-wrapper .bp3-running-text h6{color:#182026;font-weight:600;margin-top:40px;margin-bottom:20px}.jupyter-wrapper .bp3-dark .bp3-running-text h6{color:#f5f8fa}.jupyter-wrapper .bp3-running-text hr{margin:20px 0;border:none;border-bottom:1px solid rgba(16,22,26,.15)}.jupyter-wrapper .bp3-dark .bp3-running-text hr{border-color:rgba(255,255,255,.15)}.jupyter-wrapper .bp3-running-text p{margin:0 0 10px;padding:0}.jupyter-wrapper .bp3-text-large{font-size:16px}.jupyter-wrapper .bp3-text-small{font-size:12px}.jupyter-wrapper a{text-decoration:none;color:#106ba3}.jupyter-wrapper a:hover{cursor:pointer;text-decoration:underline;color:#106ba3}.jupyter-wrapper a .bp3-icon,.jupyter-wrapper a .bp3-icon-standard,.jupyter-wrapper a .bp3-icon-large{color:inherit}.jupyter-wrapper a code,.jupyter-wrapper .bp3-dark a code{color:inherit}.jupyter-wrapper .bp3-dark a,.jupyter-wrapper .bp3-dark a:hover{color:#48aff0}.jupyter-wrapper .bp3-dark a .bp3-icon,.jupyter-wrapper .bp3-dark a .bp3-icon-standard,.jupyter-wrapper .bp3-dark a .bp3-icon-large,.jupyter-wrapper .bp3-dark a:hover .bp3-icon,.jupyter-wrapper .bp3-dark a:hover .bp3-icon-standard,.jupyter-wrapper .bp3-dark a:hover .bp3-icon-large{color:inherit}.jupyter-wrapper .bp3-running-text code,.jupyter-wrapper .bp3-code{text-transform:none;font-family:monospace;border-radius:3px;-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2);background:rgba(255,255,255,.7);padding:2px 5px;color:#5c7080;font-size:smaller}.jupyter-wrapper .bp3-dark .bp3-running-text code,.jupyter-wrapper .bp3-running-text .bp3-dark code,.jupyter-wrapper .bp3-dark .bp3-code{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4);background:rgba(16,22,26,.3);color:#a7b6c2}.jupyter-wrapper .bp3-running-text a>code,.jupyter-wrapper a>.bp3-code{color:#137cbd}.jupyter-wrapper .bp3-dark .bp3-running-text a>code,.jupyter-wrapper .bp3-running-text .bp3-dark a>code,.jupyter-wrapper .bp3-dark a>.bp3-code{color:inherit}.jupyter-wrapper .bp3-running-text pre,.jupyter-wrapper .bp3-code-block{text-transform:none;font-family:monospace;display:block;margin:10px 0;border-radius:3px;-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.15);box-shadow:inset 0 0 0 1px rgba(16,22,26,.15);background:rgba(255,255,255,.7);padding:13px 15px 12px;line-height:1.4;color:#182026;font-size:13px;word-break:break-all;word-wrap:break-word}.jupyter-wrapper .bp3-dark .bp3-running-text pre,.jupyter-wrapper .bp3-running-text .bp3-dark pre,.jupyter-wrapper .bp3-dark .bp3-code-block{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4);background:rgba(16,22,26,.3);color:#f5f8fa}.jupyter-wrapper .bp3-running-text pre>code,.jupyter-wrapper .bp3-code-block>code{-webkit-box-shadow:none;box-shadow:none;background:none;padding:0;color:inherit;font-size:inherit}.jupyter-wrapper .bp3-running-text kbd,.jupyter-wrapper .bp3-key{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;border-radius:3px;-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.1),0 0 0 rgba(16,22,26,0),0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.1),0 0 0 rgba(16,22,26,0),0 1px 1px rgba(16,22,26,.2);background:#fff;min-width:24px;height:24px;padding:3px 6px;vertical-align:middle;line-height:24px;color:#5c7080;font-family:inherit;font-size:12px}.jupyter-wrapper .bp3-running-text kbd .bp3-icon,.jupyter-wrapper .bp3-key .bp3-icon,.jupyter-wrapper .bp3-running-text kbd .bp3-icon-standard,.jupyter-wrapper .bp3-key .bp3-icon-standard,.jupyter-wrapper .bp3-running-text kbd .bp3-icon-large,.jupyter-wrapper .bp3-key .bp3-icon-large{margin-right:5px}.jupyter-wrapper .bp3-dark .bp3-running-text kbd,.jupyter-wrapper .bp3-running-text .bp3-dark kbd,.jupyter-wrapper .bp3-dark .bp3-key{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),0 0 0 rgba(16,22,26,0),0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.2),0 0 0 rgba(16,22,26,0),0 1px 1px rgba(16,22,26,.4);background:#394b59;color:#a7b6c2}.jupyter-wrapper .bp3-running-text blockquote,.jupyter-wrapper .bp3-blockquote{margin:0 0 10px;border-left:solid 4px rgba(167,182,194,.5);padding:0 20px}.jupyter-wrapper .bp3-dark .bp3-running-text blockquote,.jupyter-wrapper .bp3-running-text .bp3-dark blockquote,.jupyter-wrapper .bp3-dark .bp3-blockquote{border-color:rgba(115,134,148,.5)}.jupyter-wrapper .bp3-running-text ul,.jupyter-wrapper .bp3-running-text ol,.jupyter-wrapper .bp3-list{margin:10px 0;padding-left:30px}.jupyter-wrapper .bp3-running-text ul li:not(:last-child),.jupyter-wrapper .bp3-running-text ol li:not(:last-child),.jupyter-wrapper .bp3-list li:not(:last-child){margin-bottom:5px}.jupyter-wrapper .bp3-running-text ul ol,.jupyter-wrapper .bp3-running-text ol ol,.jupyter-wrapper .bp3-list ol,.jupyter-wrapper .bp3-running-text ul ul,.jupyter-wrapper .bp3-running-text ol ul,.jupyter-wrapper .bp3-list ul{margin-top:5px}.jupyter-wrapper .bp3-list-unstyled{margin:0;padding:0;list-style:none}.jupyter-wrapper .bp3-list-unstyled li{padding:0}.jupyter-wrapper .bp3-rtl{text-align:right}.jupyter-wrapper .bp3-dark{color:#f5f8fa}.jupyter-wrapper :focus{outline:rgba(19,124,189,.6) auto 2px;outline-offset:2px;-moz-outline-radius:6px}.jupyter-wrapper .bp3-focus-disabled :focus{outline:none !important}.jupyter-wrapper .bp3-focus-disabled :focus~.bp3-control-indicator{outline:none !important}.jupyter-wrapper .bp3-alert{max-width:400px;padding:20px}.jupyter-wrapper .bp3-alert-body{display:-webkit-box;display:-ms-flexbox;display:flex}.jupyter-wrapper .bp3-alert-body .bp3-icon{margin-top:0;margin-right:20px;font-size:40px}.jupyter-wrapper .bp3-alert-footer{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:reverse;-ms-flex-direction:row-reverse;flex-direction:row-reverse;margin-top:10px}.jupyter-wrapper .bp3-alert-footer .bp3-button{margin-left:10px}.jupyter-wrapper .bp3-breadcrumbs{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin:0;cursor:default;height:30px;padding:0;list-style:none}.jupyter-wrapper .bp3-breadcrumbs>li{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.jupyter-wrapper .bp3-breadcrumbs>li::after{display:block;margin:0 5px;background:url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill-rule='evenodd' clip-rule='evenodd' d='M10.71 7.29l-4-4a1.003 1.003 0 0 0-1.42 1.42L8.59 8 5.3 11.29c-.19.18-.3.43-.3.71a1.003 1.003 0 0 0 1.71.71l4-4c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71z' fill='%235C7080'/%3e%3c/svg%3e\");width:16px;height:16px;content:\"\"}.jupyter-wrapper .bp3-breadcrumbs>li:last-of-type::after{display:none}.jupyter-wrapper .bp3-breadcrumb,.jupyter-wrapper .bp3-breadcrumb-current,.jupyter-wrapper .bp3-breadcrumbs-collapsed{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font-size:16px}.jupyter-wrapper .bp3-breadcrumb,.jupyter-wrapper .bp3-breadcrumbs-collapsed{color:#5c7080}.jupyter-wrapper .bp3-breadcrumb:hover{text-decoration:none}.jupyter-wrapper .bp3-breadcrumb.bp3-disabled{cursor:not-allowed;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-breadcrumb .bp3-icon{margin-right:5px}.jupyter-wrapper .bp3-breadcrumb-current{color:inherit;font-weight:600}.jupyter-wrapper .bp3-breadcrumb-current .bp3-input{vertical-align:baseline;font-size:inherit;font-weight:inherit}.jupyter-wrapper .bp3-breadcrumbs-collapsed{margin-right:2px;border:none;border-radius:3px;background:#ced9e0;cursor:pointer;padding:1px 5px;vertical-align:text-bottom}.jupyter-wrapper .bp3-breadcrumbs-collapsed::before{display:block;background:url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cg fill='%235C7080'%3e%3ccircle cx='2' cy='8.03' r='2'/%3e%3ccircle cx='14' cy='8.03' r='2'/%3e%3ccircle cx='8' cy='8.03' r='2'/%3e%3c/g%3e%3c/svg%3e\") center no-repeat;width:16px;height:16px;content:\"\"}.jupyter-wrapper .bp3-breadcrumbs-collapsed:hover{background:#bfccd6;text-decoration:none;color:#182026}.jupyter-wrapper .bp3-dark .bp3-breadcrumb,.jupyter-wrapper .bp3-dark .bp3-breadcrumbs-collapsed{color:#a7b6c2}.jupyter-wrapper .bp3-dark .bp3-breadcrumbs>li::after{color:#a7b6c2}.jupyter-wrapper .bp3-dark .bp3-breadcrumb.bp3-disabled{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-breadcrumb-current{color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-breadcrumbs-collapsed{background:rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-breadcrumbs-collapsed:hover{background:rgba(16,22,26,.6);color:#f5f8fa}.jupyter-wrapper .bp3-button{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;border:none;border-radius:3px;cursor:pointer;padding:5px 10px;vertical-align:middle;text-align:left;font-size:14px;min-width:30px;min-height:30px}.jupyter-wrapper .bp3-button>*{-webkit-box-flex:0;-ms-flex-positive:0;flex-grow:0;-ms-flex-negative:0;flex-shrink:0}.jupyter-wrapper .bp3-button>.bp3-fill{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-negative:1;flex-shrink:1}.jupyter-wrapper .bp3-button::before,.jupyter-wrapper .bp3-button>*{margin-right:7px}.jupyter-wrapper .bp3-button:empty::before,.jupyter-wrapper .bp3-button>:last-child{margin-right:0}.jupyter-wrapper .bp3-button:empty{padding:0 !important}.jupyter-wrapper .bp3-button:disabled,.jupyter-wrapper .bp3-button.bp3-disabled{cursor:not-allowed}.jupyter-wrapper .bp3-button.bp3-fill{display:-webkit-box;display:-ms-flexbox;display:flex;width:100%}.jupyter-wrapper .bp3-button.bp3-align-right,.jupyter-wrapper .bp3-align-right .bp3-button{text-align:right}.jupyter-wrapper .bp3-button.bp3-align-left,.jupyter-wrapper .bp3-align-left .bp3-button{text-align:left}.jupyter-wrapper .bp3-button:not([class*=bp3-intent-]){-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);background-color:#f5f8fa;background-image:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0.8)), to(rgba(255, 255, 255, 0)));background-image:linear-gradient(to bottom, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0));color:#182026}.jupyter-wrapper .bp3-button:not([class*=bp3-intent-]):hover{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);background-clip:padding-box;background-color:#ebf1f5}.jupyter-wrapper .bp3-button:not([class*=bp3-intent-]):active,.jupyter-wrapper .bp3-button:not([class*=bp3-intent-]).bp3-active{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 1px 2px rgba(16,22,26,.2);background-color:#d8e1e8;background-image:none}.jupyter-wrapper .bp3-button:not([class*=bp3-intent-]):disabled,.jupyter-wrapper .bp3-button:not([class*=bp3-intent-]).bp3-disabled{outline:none;-webkit-box-shadow:none;box-shadow:none;background-color:rgba(206,217,224,.5);background-image:none;cursor:not-allowed;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-button:not([class*=bp3-intent-]):disabled.bp3-active,.jupyter-wrapper .bp3-button:not([class*=bp3-intent-]):disabled.bp3-active:hover,.jupyter-wrapper .bp3-button:not([class*=bp3-intent-]).bp3-disabled.bp3-active,.jupyter-wrapper .bp3-button:not([class*=bp3-intent-]).bp3-disabled.bp3-active:hover{background:rgba(206,217,224,.7)}.jupyter-wrapper .bp3-button.bp3-intent-primary{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);background-color:#137cbd;background-image:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0.1)), to(rgba(255, 255, 255, 0)));background-image:linear-gradient(to bottom, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0));color:#fff}.jupyter-wrapper .bp3-button.bp3-intent-primary:hover,.jupyter-wrapper .bp3-button.bp3-intent-primary:active,.jupyter-wrapper .bp3-button.bp3-intent-primary.bp3-active{color:#fff}.jupyter-wrapper .bp3-button.bp3-intent-primary:hover{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);background-color:#106ba3}.jupyter-wrapper .bp3-button.bp3-intent-primary:active,.jupyter-wrapper .bp3-button.bp3-intent-primary.bp3-active{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 1px 2px rgba(16,22,26,.2);background-color:#0e5a8a;background-image:none}.jupyter-wrapper .bp3-button.bp3-intent-primary:disabled,.jupyter-wrapper .bp3-button.bp3-intent-primary.bp3-disabled{border-color:transparent;-webkit-box-shadow:none;box-shadow:none;background-color:rgba(19,124,189,.5);background-image:none;color:rgba(255,255,255,.6)}.jupyter-wrapper .bp3-button.bp3-intent-success{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);background-color:#0f9960;background-image:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0.1)), to(rgba(255, 255, 255, 0)));background-image:linear-gradient(to bottom, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0));color:#fff}.jupyter-wrapper .bp3-button.bp3-intent-success:hover,.jupyter-wrapper .bp3-button.bp3-intent-success:active,.jupyter-wrapper .bp3-button.bp3-intent-success.bp3-active{color:#fff}.jupyter-wrapper .bp3-button.bp3-intent-success:hover{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);background-color:#0d8050}.jupyter-wrapper .bp3-button.bp3-intent-success:active,.jupyter-wrapper .bp3-button.bp3-intent-success.bp3-active{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 1px 2px rgba(16,22,26,.2);background-color:#0a6640;background-image:none}.jupyter-wrapper .bp3-button.bp3-intent-success:disabled,.jupyter-wrapper .bp3-button.bp3-intent-success.bp3-disabled{border-color:transparent;-webkit-box-shadow:none;box-shadow:none;background-color:rgba(15,153,96,.5);background-image:none;color:rgba(255,255,255,.6)}.jupyter-wrapper .bp3-button.bp3-intent-warning{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);background-color:#d9822b;background-image:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0.1)), to(rgba(255, 255, 255, 0)));background-image:linear-gradient(to bottom, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0));color:#fff}.jupyter-wrapper .bp3-button.bp3-intent-warning:hover,.jupyter-wrapper .bp3-button.bp3-intent-warning:active,.jupyter-wrapper .bp3-button.bp3-intent-warning.bp3-active{color:#fff}.jupyter-wrapper .bp3-button.bp3-intent-warning:hover{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);background-color:#bf7326}.jupyter-wrapper .bp3-button.bp3-intent-warning:active,.jupyter-wrapper .bp3-button.bp3-intent-warning.bp3-active{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 1px 2px rgba(16,22,26,.2);background-color:#a66321;background-image:none}.jupyter-wrapper .bp3-button.bp3-intent-warning:disabled,.jupyter-wrapper .bp3-button.bp3-intent-warning.bp3-disabled{border-color:transparent;-webkit-box-shadow:none;box-shadow:none;background-color:rgba(217,130,43,.5);background-image:none;color:rgba(255,255,255,.6)}.jupyter-wrapper .bp3-button.bp3-intent-danger{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);background-color:#db3737;background-image:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0.1)), to(rgba(255, 255, 255, 0)));background-image:linear-gradient(to bottom, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0));color:#fff}.jupyter-wrapper .bp3-button.bp3-intent-danger:hover,.jupyter-wrapper .bp3-button.bp3-intent-danger:active,.jupyter-wrapper .bp3-button.bp3-intent-danger.bp3-active{color:#fff}.jupyter-wrapper .bp3-button.bp3-intent-danger:hover{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);background-color:#c23030}.jupyter-wrapper .bp3-button.bp3-intent-danger:active,.jupyter-wrapper .bp3-button.bp3-intent-danger.bp3-active{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 1px 2px rgba(16,22,26,.2);background-color:#a82a2a;background-image:none}.jupyter-wrapper .bp3-button.bp3-intent-danger:disabled,.jupyter-wrapper .bp3-button.bp3-intent-danger.bp3-disabled{border-color:transparent;-webkit-box-shadow:none;box-shadow:none;background-color:rgba(219,55,55,.5);background-image:none;color:rgba(255,255,255,.6)}.jupyter-wrapper .bp3-button[class*=bp3-intent-] .bp3-button-spinner .bp3-spinner-head{stroke:#fff}.jupyter-wrapper .bp3-button.bp3-large,.jupyter-wrapper .bp3-large .bp3-button{min-width:40px;min-height:40px;padding:5px 15px;font-size:16px}.jupyter-wrapper .bp3-button.bp3-large::before,.jupyter-wrapper .bp3-button.bp3-large>*,.jupyter-wrapper .bp3-large .bp3-button::before,.jupyter-wrapper .bp3-large .bp3-button>*{margin-right:10px}.jupyter-wrapper .bp3-button.bp3-large:empty::before,.jupyter-wrapper .bp3-button.bp3-large>:last-child,.jupyter-wrapper .bp3-large .bp3-button:empty::before,.jupyter-wrapper .bp3-large .bp3-button>:last-child{margin-right:0}.jupyter-wrapper .bp3-button.bp3-small,.jupyter-wrapper .bp3-small .bp3-button{min-width:24px;min-height:24px;padding:0 7px}.jupyter-wrapper .bp3-button.bp3-loading{position:relative}.jupyter-wrapper .bp3-button.bp3-loading[class*=bp3-icon-]::before{visibility:hidden}.jupyter-wrapper .bp3-button.bp3-loading .bp3-button-spinner{position:absolute;margin:0}.jupyter-wrapper .bp3-button.bp3-loading>:not(.bp3-button-spinner){visibility:hidden}.jupyter-wrapper .bp3-button[class*=bp3-icon-]::before{line-height:1;font-family:\"Icons16\",sans-serif;font-size:16px;font-weight:400;font-style:normal;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;color:#5c7080}.jupyter-wrapper .bp3-button .bp3-icon,.jupyter-wrapper .bp3-button .bp3-icon-standard,.jupyter-wrapper .bp3-button .bp3-icon-large{color:#5c7080}.jupyter-wrapper .bp3-button .bp3-icon.bp3-align-right,.jupyter-wrapper .bp3-button .bp3-icon-standard.bp3-align-right,.jupyter-wrapper .bp3-button .bp3-icon-large.bp3-align-right{margin-left:7px}.jupyter-wrapper .bp3-button .bp3-icon:first-child:last-child,.jupyter-wrapper .bp3-button .bp3-spinner+.bp3-icon:last-child{margin:0 -7px}.jupyter-wrapper .bp3-dark .bp3-button:not([class*=bp3-intent-]){-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.4);background-color:#394b59;background-image:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0.05)), to(rgba(255, 255, 255, 0)));background-image:linear-gradient(to bottom, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0));color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-button:not([class*=bp3-intent-]):hover,.jupyter-wrapper .bp3-dark .bp3-button:not([class*=bp3-intent-]):active,.jupyter-wrapper .bp3-dark .bp3-button:not([class*=bp3-intent-]).bp3-active{color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-button:not([class*=bp3-intent-]):hover{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.4);background-color:#30404d}.jupyter-wrapper .bp3-dark .bp3-button:not([class*=bp3-intent-]):active,.jupyter-wrapper .bp3-dark .bp3-button:not([class*=bp3-intent-]).bp3-active{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.6),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.6),inset 0 1px 2px rgba(16,22,26,.2);background-color:#202b33;background-image:none}.jupyter-wrapper .bp3-dark .bp3-button:not([class*=bp3-intent-]):disabled,.jupyter-wrapper .bp3-dark .bp3-button:not([class*=bp3-intent-]).bp3-disabled{-webkit-box-shadow:none;box-shadow:none;background-color:rgba(57,75,89,.5);background-image:none;color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-button:not([class*=bp3-intent-]):disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-button:not([class*=bp3-intent-]).bp3-disabled.bp3-active{background:rgba(57,75,89,.7)}.jupyter-wrapper .bp3-dark .bp3-button:not([class*=bp3-intent-]) .bp3-button-spinner .bp3-spinner-head{background:rgba(16,22,26,.5);stroke:#8a9ba8}.jupyter-wrapper .bp3-dark .bp3-button:not([class*=bp3-intent-])[class*=bp3-icon-]::before{color:#a7b6c2}.jupyter-wrapper .bp3-dark .bp3-button:not([class*=bp3-intent-]) .bp3-icon,.jupyter-wrapper .bp3-dark .bp3-button:not([class*=bp3-intent-]) .bp3-icon-standard,.jupyter-wrapper .bp3-dark .bp3-button:not([class*=bp3-intent-]) .bp3-icon-large{color:#a7b6c2}.jupyter-wrapper .bp3-dark .bp3-button[class*=bp3-intent-]{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-button[class*=bp3-intent-]:hover{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-button[class*=bp3-intent-]:active,.jupyter-wrapper .bp3-dark .bp3-button[class*=bp3-intent-].bp3-active{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.4),inset 0 1px 2px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-dark .bp3-button[class*=bp3-intent-]:disabled,.jupyter-wrapper .bp3-dark .bp3-button[class*=bp3-intent-].bp3-disabled{-webkit-box-shadow:none;box-shadow:none;background-image:none;color:rgba(255,255,255,.3)}.jupyter-wrapper .bp3-dark .bp3-button[class*=bp3-intent-] .bp3-button-spinner .bp3-spinner-head{stroke:#8a9ba8}.jupyter-wrapper .bp3-button:disabled::before,.jupyter-wrapper .bp3-button:disabled .bp3-icon,.jupyter-wrapper .bp3-button:disabled .bp3-icon-standard,.jupyter-wrapper .bp3-button:disabled .bp3-icon-large,.jupyter-wrapper .bp3-button.bp3-disabled::before,.jupyter-wrapper .bp3-button.bp3-disabled .bp3-icon,.jupyter-wrapper .bp3-button.bp3-disabled .bp3-icon-standard,.jupyter-wrapper .bp3-button.bp3-disabled .bp3-icon-large,.jupyter-wrapper .bp3-button[class*=bp3-intent-]::before,.jupyter-wrapper .bp3-button[class*=bp3-intent-] .bp3-icon,.jupyter-wrapper .bp3-button[class*=bp3-intent-] .bp3-icon-standard,.jupyter-wrapper .bp3-button[class*=bp3-intent-] .bp3-icon-large{color:inherit !important}.jupyter-wrapper .bp3-button.bp3-minimal{-webkit-box-shadow:none;box-shadow:none;background:none}.jupyter-wrapper .bp3-button.bp3-minimal:hover{-webkit-box-shadow:none;box-shadow:none;background:rgba(167,182,194,.3);text-decoration:none;color:#182026}.jupyter-wrapper .bp3-button.bp3-minimal:active,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-active{-webkit-box-shadow:none;box-shadow:none;background:rgba(115,134,148,.3);color:#182026}.jupyter-wrapper .bp3-button.bp3-minimal:disabled,.jupyter-wrapper .bp3-button.bp3-minimal:disabled:hover,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-disabled,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-disabled:hover{background:none;cursor:not-allowed;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-button.bp3-minimal:disabled.bp3-active,.jupyter-wrapper .bp3-button.bp3-minimal:disabled:hover.bp3-active,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-disabled:hover.bp3-active{background:rgba(115,134,148,.3)}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal{-webkit-box-shadow:none;box-shadow:none;background:none;color:inherit}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal:hover,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal:active,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-active{-webkit-box-shadow:none;box-shadow:none;background:none}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal:hover{background:rgba(138,155,168,.15)}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal:active,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-active{background:rgba(138,155,168,.3);color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal:disabled,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal:disabled:hover,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-disabled,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-disabled:hover{background:none;cursor:not-allowed;color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal:disabled:hover.bp3-active,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-disabled:hover.bp3-active{background:rgba(138,155,168,.3)}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-primary{color:#106ba3}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-primary:hover,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-primary:active,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-primary.bp3-active{-webkit-box-shadow:none;box-shadow:none;background:none;color:#106ba3}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-primary:hover{background:rgba(19,124,189,.15);color:#106ba3}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-primary:active,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-primary.bp3-active{background:rgba(19,124,189,.3);color:#106ba3}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-primary:disabled,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-primary.bp3-disabled{background:none;color:rgba(16,107,163,.5)}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-primary:disabled.bp3-active,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-primary.bp3-disabled.bp3-active{background:rgba(19,124,189,.3)}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-primary .bp3-button-spinner .bp3-spinner-head{stroke:#106ba3}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-primary{color:#48aff0}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-primary:hover{background:rgba(19,124,189,.2);color:#48aff0}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-primary:active,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-primary.bp3-active{background:rgba(19,124,189,.3);color:#48aff0}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-primary:disabled,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-primary.bp3-disabled{background:none;color:rgba(72,175,240,.5)}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-primary:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-primary.bp3-disabled.bp3-active{background:rgba(19,124,189,.3)}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-success{color:#0d8050}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-success:hover,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-success:active,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-success.bp3-active{-webkit-box-shadow:none;box-shadow:none;background:none;color:#0d8050}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-success:hover{background:rgba(15,153,96,.15);color:#0d8050}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-success:active,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-success.bp3-active{background:rgba(15,153,96,.3);color:#0d8050}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-success:disabled,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-success.bp3-disabled{background:none;color:rgba(13,128,80,.5)}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-success:disabled.bp3-active,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-success.bp3-disabled.bp3-active{background:rgba(15,153,96,.3)}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-success .bp3-button-spinner .bp3-spinner-head{stroke:#0d8050}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-success{color:#3dcc91}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-success:hover{background:rgba(15,153,96,.2);color:#3dcc91}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-success:active,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-success.bp3-active{background:rgba(15,153,96,.3);color:#3dcc91}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-success:disabled,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-success.bp3-disabled{background:none;color:rgba(61,204,145,.5)}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-success:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-success.bp3-disabled.bp3-active{background:rgba(15,153,96,.3)}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-warning{color:#bf7326}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-warning:hover,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-warning:active,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-warning.bp3-active{-webkit-box-shadow:none;box-shadow:none;background:none;color:#bf7326}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-warning:hover{background:rgba(217,130,43,.15);color:#bf7326}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-warning:active,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-warning.bp3-active{background:rgba(217,130,43,.3);color:#bf7326}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-warning:disabled,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-warning.bp3-disabled{background:none;color:rgba(191,115,38,.5)}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-warning:disabled.bp3-active,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-warning.bp3-disabled.bp3-active{background:rgba(217,130,43,.3)}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-warning .bp3-button-spinner .bp3-spinner-head{stroke:#bf7326}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-warning{color:#ffb366}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-warning:hover{background:rgba(217,130,43,.2);color:#ffb366}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-warning:active,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-warning.bp3-active{background:rgba(217,130,43,.3);color:#ffb366}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-warning:disabled,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-warning.bp3-disabled{background:none;color:rgba(255,179,102,.5)}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-warning:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-warning.bp3-disabled.bp3-active{background:rgba(217,130,43,.3)}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-danger{color:#c23030}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-danger:hover,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-danger:active,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-danger.bp3-active{-webkit-box-shadow:none;box-shadow:none;background:none;color:#c23030}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-danger:hover{background:rgba(219,55,55,.15);color:#c23030}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-danger:active,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-danger.bp3-active{background:rgba(219,55,55,.3);color:#c23030}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-danger:disabled,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-danger.bp3-disabled{background:none;color:rgba(194,48,48,.5)}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-danger:disabled.bp3-active,.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-danger.bp3-disabled.bp3-active{background:rgba(219,55,55,.3)}.jupyter-wrapper .bp3-button.bp3-minimal.bp3-intent-danger .bp3-button-spinner .bp3-spinner-head{stroke:#c23030}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-danger{color:#ff7373}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-danger:hover{background:rgba(219,55,55,.2);color:#ff7373}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-danger:active,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-danger.bp3-active{background:rgba(219,55,55,.3);color:#ff7373}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-danger:disabled,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-danger.bp3-disabled{background:none;color:rgba(255,115,115,.5)}.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-danger:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-button.bp3-minimal.bp3-intent-danger.bp3-disabled.bp3-active{background:rgba(219,55,55,.3)}.jupyter-wrapper a.bp3-button{text-align:center;text-decoration:none;-webkit-transition:none;transition:none}.jupyter-wrapper a.bp3-button,.jupyter-wrapper a.bp3-button:hover,.jupyter-wrapper a.bp3-button:active{color:#182026}.jupyter-wrapper a.bp3-button.bp3-disabled{color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-button-text{-webkit-box-flex:0;-ms-flex:0 1 auto;flex:0 1 auto}.jupyter-wrapper .bp3-button.bp3-align-left .bp3-button-text,.jupyter-wrapper .bp3-button.bp3-align-right .bp3-button-text,.jupyter-wrapper .bp3-button-group.bp3-align-left .bp3-button-text,.jupyter-wrapper .bp3-button-group.bp3-align-right .bp3-button-text{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto}.jupyter-wrapper .bp3-button-group{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex}.jupyter-wrapper .bp3-button-group .bp3-button{-webkit-box-flex:0;-ms-flex:0 0 auto;flex:0 0 auto;position:relative;z-index:4}.jupyter-wrapper .bp3-button-group .bp3-button:focus{z-index:5}.jupyter-wrapper .bp3-button-group .bp3-button:hover{z-index:6}.jupyter-wrapper .bp3-button-group .bp3-button:active,.jupyter-wrapper .bp3-button-group .bp3-button.bp3-active{z-index:7}.jupyter-wrapper .bp3-button-group .bp3-button:disabled,.jupyter-wrapper .bp3-button-group .bp3-button.bp3-disabled{z-index:3}.jupyter-wrapper .bp3-button-group .bp3-button[class*=bp3-intent-]{z-index:9}.jupyter-wrapper .bp3-button-group .bp3-button[class*=bp3-intent-]:focus{z-index:10}.jupyter-wrapper .bp3-button-group .bp3-button[class*=bp3-intent-]:hover{z-index:11}.jupyter-wrapper .bp3-button-group .bp3-button[class*=bp3-intent-]:active,.jupyter-wrapper .bp3-button-group .bp3-button[class*=bp3-intent-].bp3-active{z-index:12}.jupyter-wrapper .bp3-button-group .bp3-button[class*=bp3-intent-]:disabled,.jupyter-wrapper .bp3-button-group .bp3-button[class*=bp3-intent-].bp3-disabled{z-index:8}.jupyter-wrapper .bp3-button-group:not(.bp3-minimal)>.bp3-popover-wrapper:not(:first-child) .bp3-button,.jupyter-wrapper .bp3-button-group:not(.bp3-minimal)>.bp3-button:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.jupyter-wrapper .bp3-button-group:not(.bp3-minimal)>.bp3-popover-wrapper:not(:last-child) .bp3-button,.jupyter-wrapper .bp3-button-group:not(.bp3-minimal)>.bp3-button:not(:last-child){margin-right:-1px;border-top-right-radius:0;border-bottom-right-radius:0}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button{-webkit-box-shadow:none;box-shadow:none;background:none}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button:hover{-webkit-box-shadow:none;box-shadow:none;background:rgba(167,182,194,.3);text-decoration:none;color:#182026}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button:active,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-active{-webkit-box-shadow:none;box-shadow:none;background:rgba(115,134,148,.3);color:#182026}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button:disabled,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button:disabled:hover,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-disabled,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-disabled:hover{background:none;cursor:not-allowed;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button:disabled.bp3-active,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button:disabled:hover.bp3-active,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-disabled:hover.bp3-active{background:rgba(115,134,148,.3)}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button{-webkit-box-shadow:none;box-shadow:none;background:none;color:inherit}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button:hover,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button:active,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-active{-webkit-box-shadow:none;box-shadow:none;background:none}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button:hover{background:rgba(138,155,168,.15)}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button:active,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-active{background:rgba(138,155,168,.3);color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button:disabled,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button:disabled:hover,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-disabled,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-disabled:hover{background:none;cursor:not-allowed;color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button:disabled:hover.bp3-active,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-disabled:hover.bp3-active{background:rgba(138,155,168,.3)}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary{color:#106ba3}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary:hover,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary:active,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary.bp3-active{-webkit-box-shadow:none;box-shadow:none;background:none;color:#106ba3}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary:hover{background:rgba(19,124,189,.15);color:#106ba3}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary:active,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary.bp3-active{background:rgba(19,124,189,.3);color:#106ba3}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary:disabled,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary.bp3-disabled{background:none;color:rgba(16,107,163,.5)}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary:disabled.bp3-active,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary.bp3-disabled.bp3-active{background:rgba(19,124,189,.3)}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary .bp3-button-spinner .bp3-spinner-head{stroke:#106ba3}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary{color:#48aff0}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary:hover{background:rgba(19,124,189,.2);color:#48aff0}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary:active,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary.bp3-active{background:rgba(19,124,189,.3);color:#48aff0}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary:disabled,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary.bp3-disabled{background:none;color:rgba(72,175,240,.5)}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-primary.bp3-disabled.bp3-active{background:rgba(19,124,189,.3)}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success{color:#0d8050}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success:hover,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success:active,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success.bp3-active{-webkit-box-shadow:none;box-shadow:none;background:none;color:#0d8050}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success:hover{background:rgba(15,153,96,.15);color:#0d8050}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success:active,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success.bp3-active{background:rgba(15,153,96,.3);color:#0d8050}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success:disabled,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success.bp3-disabled{background:none;color:rgba(13,128,80,.5)}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success:disabled.bp3-active,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success.bp3-disabled.bp3-active{background:rgba(15,153,96,.3)}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success .bp3-button-spinner .bp3-spinner-head{stroke:#0d8050}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success{color:#3dcc91}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success:hover{background:rgba(15,153,96,.2);color:#3dcc91}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success:active,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success.bp3-active{background:rgba(15,153,96,.3);color:#3dcc91}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success:disabled,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success.bp3-disabled{background:none;color:rgba(61,204,145,.5)}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-success.bp3-disabled.bp3-active{background:rgba(15,153,96,.3)}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning{color:#bf7326}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning:hover,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning:active,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning.bp3-active{-webkit-box-shadow:none;box-shadow:none;background:none;color:#bf7326}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning:hover{background:rgba(217,130,43,.15);color:#bf7326}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning:active,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning.bp3-active{background:rgba(217,130,43,.3);color:#bf7326}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning:disabled,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning.bp3-disabled{background:none;color:rgba(191,115,38,.5)}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning:disabled.bp3-active,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning.bp3-disabled.bp3-active{background:rgba(217,130,43,.3)}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning .bp3-button-spinner .bp3-spinner-head{stroke:#bf7326}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning{color:#ffb366}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning:hover{background:rgba(217,130,43,.2);color:#ffb366}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning:active,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning.bp3-active{background:rgba(217,130,43,.3);color:#ffb366}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning:disabled,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning.bp3-disabled{background:none;color:rgba(255,179,102,.5)}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-warning.bp3-disabled.bp3-active{background:rgba(217,130,43,.3)}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger{color:#c23030}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger:hover,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger:active,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger.bp3-active{-webkit-box-shadow:none;box-shadow:none;background:none;color:#c23030}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger:hover{background:rgba(219,55,55,.15);color:#c23030}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger:active,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger.bp3-active{background:rgba(219,55,55,.3);color:#c23030}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger:disabled,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger.bp3-disabled{background:none;color:rgba(194,48,48,.5)}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger:disabled.bp3-active,.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger.bp3-disabled.bp3-active{background:rgba(219,55,55,.3)}.jupyter-wrapper .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger .bp3-button-spinner .bp3-spinner-head{stroke:#c23030}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger{color:#ff7373}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger:hover{background:rgba(219,55,55,.2);color:#ff7373}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger:active,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger.bp3-active{background:rgba(219,55,55,.3);color:#ff7373}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger:disabled,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger.bp3-disabled{background:none;color:rgba(255,115,115,.5)}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-minimal .bp3-button.bp3-intent-danger.bp3-disabled.bp3-active{background:rgba(219,55,55,.3)}.jupyter-wrapper .bp3-button-group .bp3-popover-wrapper,.jupyter-wrapper .bp3-button-group .bp3-popover-target{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto}.jupyter-wrapper .bp3-button-group.bp3-fill{display:-webkit-box;display:-ms-flexbox;display:flex;width:100%}.jupyter-wrapper .bp3-button-group .bp3-button.bp3-fill,.jupyter-wrapper .bp3-button-group.bp3-fill .bp3-button:not(.bp3-fixed){-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto}.jupyter-wrapper .bp3-button-group.bp3-vertical{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;vertical-align:top}.jupyter-wrapper .bp3-button-group.bp3-vertical.bp3-fill{width:unset;height:100%}.jupyter-wrapper .bp3-button-group.bp3-vertical .bp3-button{margin-right:0 !important;width:100%}.jupyter-wrapper .bp3-button-group.bp3-vertical:not(.bp3-minimal)>.bp3-popover-wrapper:first-child .bp3-button,.jupyter-wrapper .bp3-button-group.bp3-vertical:not(.bp3-minimal)>.bp3-button:first-child{border-radius:3px 3px 0 0}.jupyter-wrapper .bp3-button-group.bp3-vertical:not(.bp3-minimal)>.bp3-popover-wrapper:last-child .bp3-button,.jupyter-wrapper .bp3-button-group.bp3-vertical:not(.bp3-minimal)>.bp3-button:last-child{border-radius:0 0 3px 3px}.jupyter-wrapper .bp3-button-group.bp3-vertical:not(.bp3-minimal)>.bp3-popover-wrapper:not(:last-child) .bp3-button,.jupyter-wrapper .bp3-button-group.bp3-vertical:not(.bp3-minimal)>.bp3-button:not(:last-child){margin-bottom:-1px}.jupyter-wrapper .bp3-button-group.bp3-align-left .bp3-button{text-align:left}.jupyter-wrapper .bp3-dark .bp3-button-group:not(.bp3-minimal)>.bp3-popover-wrapper:not(:last-child) .bp3-button,.jupyter-wrapper .bp3-dark .bp3-button-group:not(.bp3-minimal)>.bp3-button:not(:last-child){margin-right:1px}.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-vertical>.bp3-popover-wrapper:not(:last-child) .bp3-button,.jupyter-wrapper .bp3-dark .bp3-button-group.bp3-vertical>.bp3-button:not(:last-child){margin-bottom:1px}.jupyter-wrapper .bp3-callout{line-height:1.5;font-size:14px;position:relative;border-radius:3px;background-color:rgba(138,155,168,.15);width:100%;padding:10px 12px 9px}.jupyter-wrapper .bp3-callout[class*=bp3-icon-]{padding-left:40px}.jupyter-wrapper .bp3-callout[class*=bp3-icon-]::before{line-height:1;font-family:\"Icons20\",sans-serif;font-size:20px;font-weight:400;font-style:normal;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;position:absolute;top:10px;left:10px;color:#5c7080}.jupyter-wrapper .bp3-callout.bp3-callout-icon{padding-left:40px}.jupyter-wrapper .bp3-callout.bp3-callout-icon>.bp3-icon:first-child{position:absolute;top:10px;left:10px;color:#5c7080}.jupyter-wrapper .bp3-callout .bp3-heading{margin-top:0;margin-bottom:5px;line-height:20px}.jupyter-wrapper .bp3-callout .bp3-heading:last-child{margin-bottom:0}.jupyter-wrapper .bp3-dark .bp3-callout{background-color:rgba(138,155,168,.2)}.jupyter-wrapper .bp3-dark .bp3-callout[class*=bp3-icon-]::before{color:#a7b6c2}.jupyter-wrapper .bp3-callout.bp3-intent-primary{background-color:rgba(19,124,189,.15)}.jupyter-wrapper .bp3-callout.bp3-intent-primary[class*=bp3-icon-]::before,.jupyter-wrapper .bp3-callout.bp3-intent-primary>.bp3-icon:first-child,.jupyter-wrapper .bp3-callout.bp3-intent-primary .bp3-heading{color:#106ba3}.jupyter-wrapper .bp3-dark .bp3-callout.bp3-intent-primary{background-color:rgba(19,124,189,.25)}.jupyter-wrapper .bp3-dark .bp3-callout.bp3-intent-primary[class*=bp3-icon-]::before,.jupyter-wrapper .bp3-dark .bp3-callout.bp3-intent-primary>.bp3-icon:first-child,.jupyter-wrapper .bp3-dark .bp3-callout.bp3-intent-primary .bp3-heading{color:#48aff0}.jupyter-wrapper .bp3-callout.bp3-intent-success{background-color:rgba(15,153,96,.15)}.jupyter-wrapper .bp3-callout.bp3-intent-success[class*=bp3-icon-]::before,.jupyter-wrapper .bp3-callout.bp3-intent-success>.bp3-icon:first-child,.jupyter-wrapper .bp3-callout.bp3-intent-success .bp3-heading{color:#0d8050}.jupyter-wrapper .bp3-dark .bp3-callout.bp3-intent-success{background-color:rgba(15,153,96,.25)}.jupyter-wrapper .bp3-dark .bp3-callout.bp3-intent-success[class*=bp3-icon-]::before,.jupyter-wrapper .bp3-dark .bp3-callout.bp3-intent-success>.bp3-icon:first-child,.jupyter-wrapper .bp3-dark .bp3-callout.bp3-intent-success .bp3-heading{color:#3dcc91}.jupyter-wrapper .bp3-callout.bp3-intent-warning{background-color:rgba(217,130,43,.15)}.jupyter-wrapper .bp3-callout.bp3-intent-warning[class*=bp3-icon-]::before,.jupyter-wrapper .bp3-callout.bp3-intent-warning>.bp3-icon:first-child,.jupyter-wrapper .bp3-callout.bp3-intent-warning .bp3-heading{color:#bf7326}.jupyter-wrapper .bp3-dark .bp3-callout.bp3-intent-warning{background-color:rgba(217,130,43,.25)}.jupyter-wrapper .bp3-dark .bp3-callout.bp3-intent-warning[class*=bp3-icon-]::before,.jupyter-wrapper .bp3-dark .bp3-callout.bp3-intent-warning>.bp3-icon:first-child,.jupyter-wrapper .bp3-dark .bp3-callout.bp3-intent-warning .bp3-heading{color:#ffb366}.jupyter-wrapper .bp3-callout.bp3-intent-danger{background-color:rgba(219,55,55,.15)}.jupyter-wrapper .bp3-callout.bp3-intent-danger[class*=bp3-icon-]::before,.jupyter-wrapper .bp3-callout.bp3-intent-danger>.bp3-icon:first-child,.jupyter-wrapper .bp3-callout.bp3-intent-danger .bp3-heading{color:#c23030}.jupyter-wrapper .bp3-dark .bp3-callout.bp3-intent-danger{background-color:rgba(219,55,55,.25)}.jupyter-wrapper .bp3-dark .bp3-callout.bp3-intent-danger[class*=bp3-icon-]::before,.jupyter-wrapper .bp3-dark .bp3-callout.bp3-intent-danger>.bp3-icon:first-child,.jupyter-wrapper .bp3-dark .bp3-callout.bp3-intent-danger .bp3-heading{color:#ff7373}.jupyter-wrapper .bp3-running-text .bp3-callout{margin:20px 0}.jupyter-wrapper .bp3-card{border-radius:3px;-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.15),0 0 0 rgba(16,22,26,0),0 0 0 rgba(16,22,26,0);box-shadow:0 0 0 1px rgba(16,22,26,.15),0 0 0 rgba(16,22,26,0),0 0 0 rgba(16,22,26,0);background-color:#fff;padding:20px;-webkit-transition:-webkit-transform 200ms cubic-bezier(0.4, 1, 0.75, 0.9),-webkit-box-shadow 200ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:-webkit-transform 200ms cubic-bezier(0.4, 1, 0.75, 0.9),-webkit-box-shadow 200ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:transform 200ms cubic-bezier(0.4, 1, 0.75, 0.9),box-shadow 200ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:transform 200ms cubic-bezier(0.4, 1, 0.75, 0.9),box-shadow 200ms cubic-bezier(0.4, 1, 0.75, 0.9),-webkit-transform 200ms cubic-bezier(0.4, 1, 0.75, 0.9),-webkit-box-shadow 200ms cubic-bezier(0.4, 1, 0.75, 0.9)}.jupyter-wrapper .bp3-card.bp3-dark,.jupyter-wrapper .bp3-dark .bp3-card{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4),0 0 0 rgba(16,22,26,0),0 0 0 rgba(16,22,26,0);box-shadow:0 0 0 1px rgba(16,22,26,.4),0 0 0 rgba(16,22,26,0),0 0 0 rgba(16,22,26,0);background-color:#30404d}.jupyter-wrapper .bp3-elevation-0{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.15),0 0 0 rgba(16,22,26,0),0 0 0 rgba(16,22,26,0);box-shadow:0 0 0 1px rgba(16,22,26,.15),0 0 0 rgba(16,22,26,0),0 0 0 rgba(16,22,26,0)}.jupyter-wrapper .bp3-elevation-0.bp3-dark,.jupyter-wrapper .bp3-dark .bp3-elevation-0{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4),0 0 0 rgba(16,22,26,0),0 0 0 rgba(16,22,26,0);box-shadow:0 0 0 1px rgba(16,22,26,.4),0 0 0 rgba(16,22,26,0),0 0 0 rgba(16,22,26,0)}.jupyter-wrapper .bp3-elevation-1{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.1),0 0 0 rgba(16,22,26,0),0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.1),0 0 0 rgba(16,22,26,0),0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-elevation-1.bp3-dark,.jupyter-wrapper .bp3-dark .bp3-elevation-1{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),0 0 0 rgba(16,22,26,0),0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.2),0 0 0 rgba(16,22,26,0),0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-elevation-2{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.1),0 1px 1px rgba(16,22,26,.2),0 2px 6px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.1),0 1px 1px rgba(16,22,26,.2),0 2px 6px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-elevation-2.bp3-dark,.jupyter-wrapper .bp3-dark .bp3-elevation-2{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),0 1px 1px rgba(16,22,26,.4),0 2px 6px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.2),0 1px 1px rgba(16,22,26,.4),0 2px 6px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-elevation-3{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.1),0 2px 4px rgba(16,22,26,.2),0 8px 24px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.1),0 2px 4px rgba(16,22,26,.2),0 8px 24px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-elevation-3.bp3-dark,.jupyter-wrapper .bp3-dark .bp3-elevation-3{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),0 2px 4px rgba(16,22,26,.4),0 8px 24px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.2),0 2px 4px rgba(16,22,26,.4),0 8px 24px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-elevation-4{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.1),0 4px 8px rgba(16,22,26,.2),0 18px 46px 6px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.1),0 4px 8px rgba(16,22,26,.2),0 18px 46px 6px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-elevation-4.bp3-dark,.jupyter-wrapper .bp3-dark .bp3-elevation-4{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),0 4px 8px rgba(16,22,26,.4),0 18px 46px 6px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.2),0 4px 8px rgba(16,22,26,.4),0 18px 46px 6px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-card.bp3-interactive:hover{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.1),0 2px 4px rgba(16,22,26,.2),0 8px 24px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.1),0 2px 4px rgba(16,22,26,.2),0 8px 24px rgba(16,22,26,.2);cursor:pointer}.jupyter-wrapper .bp3-card.bp3-interactive:hover.bp3-dark,.jupyter-wrapper .bp3-dark .bp3-card.bp3-interactive:hover{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),0 2px 4px rgba(16,22,26,.4),0 8px 24px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.2),0 2px 4px rgba(16,22,26,.4),0 8px 24px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-card.bp3-interactive:active{opacity:.9;-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.1),0 0 0 rgba(16,22,26,0),0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.1),0 0 0 rgba(16,22,26,0),0 1px 1px rgba(16,22,26,.2);-webkit-transition-duration:0;transition-duration:0}.jupyter-wrapper .bp3-card.bp3-interactive:active.bp3-dark,.jupyter-wrapper .bp3-dark .bp3-card.bp3-interactive:active{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),0 0 0 rgba(16,22,26,0),0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.2),0 0 0 rgba(16,22,26,0),0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-collapse{height:0;overflow-y:hidden;-webkit-transition:height 200ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:height 200ms cubic-bezier(0.4, 1, 0.75, 0.9)}.jupyter-wrapper .bp3-collapse .bp3-collapse-body{-webkit-transition:-webkit-transform 200ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:-webkit-transform 200ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:transform 200ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:transform 200ms cubic-bezier(0.4, 1, 0.75, 0.9),-webkit-transform 200ms cubic-bezier(0.4, 1, 0.75, 0.9)}.jupyter-wrapper .bp3-collapse .bp3-collapse-body[aria-hidden=true]{display:none}.jupyter-wrapper .bp3-context-menu .bp3-popover-target{display:block}.jupyter-wrapper .bp3-context-menu-popover-target{position:fixed}.jupyter-wrapper .bp3-divider{margin:5px;border-right:1px solid rgba(16,22,26,.15);border-bottom:1px solid rgba(16,22,26,.15)}.jupyter-wrapper .bp3-dark .bp3-divider{border-color:rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dialog-container{opacity:1;-webkit-transform:scale(1);transform:scale(1);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:100%;min-height:100%;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.jupyter-wrapper .bp3-dialog-container.bp3-overlay-enter>.bp3-dialog,.jupyter-wrapper .bp3-dialog-container.bp3-overlay-appear>.bp3-dialog{opacity:0;-webkit-transform:scale(0.5);transform:scale(0.5)}.jupyter-wrapper .bp3-dialog-container.bp3-overlay-enter-active>.bp3-dialog,.jupyter-wrapper .bp3-dialog-container.bp3-overlay-appear-active>.bp3-dialog{opacity:1;-webkit-transform:scale(1);transform:scale(1);-webkit-transition-property:opacity,-webkit-transform;transition-property:opacity,-webkit-transform;transition-property:opacity,transform;transition-property:opacity,transform,-webkit-transform;-webkit-transition-duration:300ms;transition-duration:300ms;-webkit-transition-timing-function:cubic-bezier(0.54, 1.12, 0.38, 1.11);transition-timing-function:cubic-bezier(0.54, 1.12, 0.38, 1.11);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-dialog-container.bp3-overlay-exit>.bp3-dialog{opacity:1;-webkit-transform:scale(1);transform:scale(1)}.jupyter-wrapper .bp3-dialog-container.bp3-overlay-exit-active>.bp3-dialog{opacity:0;-webkit-transform:scale(0.5);transform:scale(0.5);-webkit-transition-property:opacity,-webkit-transform;transition-property:opacity,-webkit-transform;transition-property:opacity,transform;transition-property:opacity,transform,-webkit-transform;-webkit-transition-duration:300ms;transition-duration:300ms;-webkit-transition-timing-function:cubic-bezier(0.54, 1.12, 0.38, 1.11);transition-timing-function:cubic-bezier(0.54, 1.12, 0.38, 1.11);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-dialog{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;margin:30px 0;border-radius:6px;-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.1),0 4px 8px rgba(16,22,26,.2),0 18px 46px 6px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.1),0 4px 8px rgba(16,22,26,.2),0 18px 46px 6px rgba(16,22,26,.2);background:#ebf1f5;width:500px;padding-bottom:20px;pointer-events:all;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text}.jupyter-wrapper .bp3-dialog:focus{outline:0}.jupyter-wrapper .bp3-dialog.bp3-dark,.jupyter-wrapper .bp3-dark .bp3-dialog{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),0 4px 8px rgba(16,22,26,.4),0 18px 46px 6px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.2),0 4px 8px rgba(16,22,26,.4),0 18px 46px 6px rgba(16,22,26,.4);background:#293742;color:#f5f8fa}.jupyter-wrapper .bp3-dialog-header{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:0 0 auto;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:6px 6px 0 0;-webkit-box-shadow:0 1px 0 rgba(16,22,26,.15);box-shadow:0 1px 0 rgba(16,22,26,.15);background:#fff;min-height:40px;padding-right:5px;padding-left:20px}.jupyter-wrapper .bp3-dialog-header .bp3-icon-large,.jupyter-wrapper .bp3-dialog-header .bp3-icon{-webkit-box-flex:0;-ms-flex:0 0 auto;flex:0 0 auto;margin-right:10px;color:#5c7080}.jupyter-wrapper .bp3-dialog-header .bp3-heading{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-wrap:normal;-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;margin:0;line-height:inherit}.jupyter-wrapper .bp3-dialog-header .bp3-heading:last-child{margin-right:20px}.jupyter-wrapper .bp3-dark .bp3-dialog-header{-webkit-box-shadow:0 1px 0 rgba(16,22,26,.4);box-shadow:0 1px 0 rgba(16,22,26,.4);background:#30404d}.jupyter-wrapper .bp3-dark .bp3-dialog-header .bp3-icon-large,.jupyter-wrapper .bp3-dark .bp3-dialog-header .bp3-icon{color:#a7b6c2}.jupyter-wrapper .bp3-dialog-body{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;margin:20px;line-height:18px}.jupyter-wrapper .bp3-dialog-footer{-webkit-box-flex:0;-ms-flex:0 0 auto;flex:0 0 auto;margin:0 20px}.jupyter-wrapper .bp3-dialog-footer-actions{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end}.jupyter-wrapper .bp3-dialog-footer-actions .bp3-button{margin-left:10px}.jupyter-wrapper .bp3-drawer{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;margin:0;-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.1),0 4px 8px rgba(16,22,26,.2),0 18px 46px 6px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.1),0 4px 8px rgba(16,22,26,.2),0 18px 46px 6px rgba(16,22,26,.2);background:#fff;padding:0}.jupyter-wrapper .bp3-drawer:focus{outline:0}.jupyter-wrapper .bp3-drawer.bp3-position-top{top:0;right:0;left:0;height:50%}.jupyter-wrapper .bp3-drawer.bp3-position-top.bp3-overlay-enter,.jupyter-wrapper .bp3-drawer.bp3-position-top.bp3-overlay-appear{-webkit-transform:translateY(-100%);transform:translateY(-100%)}.jupyter-wrapper .bp3-drawer.bp3-position-top.bp3-overlay-enter-active,.jupyter-wrapper .bp3-drawer.bp3-position-top.bp3-overlay-appear-active{-webkit-transform:translateY(0);transform:translateY(0);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:200ms;transition-duration:200ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-drawer.bp3-position-top.bp3-overlay-exit{-webkit-transform:translateY(0);transform:translateY(0)}.jupyter-wrapper .bp3-drawer.bp3-position-top.bp3-overlay-exit-active{-webkit-transform:translateY(-100%);transform:translateY(-100%);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:100ms;transition-duration:100ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-drawer.bp3-position-bottom{right:0;bottom:0;left:0;height:50%}.jupyter-wrapper .bp3-drawer.bp3-position-bottom.bp3-overlay-enter,.jupyter-wrapper .bp3-drawer.bp3-position-bottom.bp3-overlay-appear{-webkit-transform:translateY(100%);transform:translateY(100%)}.jupyter-wrapper .bp3-drawer.bp3-position-bottom.bp3-overlay-enter-active,.jupyter-wrapper .bp3-drawer.bp3-position-bottom.bp3-overlay-appear-active{-webkit-transform:translateY(0);transform:translateY(0);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:200ms;transition-duration:200ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-drawer.bp3-position-bottom.bp3-overlay-exit{-webkit-transform:translateY(0);transform:translateY(0)}.jupyter-wrapper .bp3-drawer.bp3-position-bottom.bp3-overlay-exit-active{-webkit-transform:translateY(100%);transform:translateY(100%);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:100ms;transition-duration:100ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-drawer.bp3-position-left{top:0;bottom:0;left:0;width:50%}.jupyter-wrapper .bp3-drawer.bp3-position-left.bp3-overlay-enter,.jupyter-wrapper .bp3-drawer.bp3-position-left.bp3-overlay-appear{-webkit-transform:translateX(-100%);transform:translateX(-100%)}.jupyter-wrapper .bp3-drawer.bp3-position-left.bp3-overlay-enter-active,.jupyter-wrapper .bp3-drawer.bp3-position-left.bp3-overlay-appear-active{-webkit-transform:translateX(0);transform:translateX(0);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:200ms;transition-duration:200ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-drawer.bp3-position-left.bp3-overlay-exit{-webkit-transform:translateX(0);transform:translateX(0)}.jupyter-wrapper .bp3-drawer.bp3-position-left.bp3-overlay-exit-active{-webkit-transform:translateX(-100%);transform:translateX(-100%);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:100ms;transition-duration:100ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-drawer.bp3-position-right{top:0;right:0;bottom:0;width:50%}.jupyter-wrapper .bp3-drawer.bp3-position-right.bp3-overlay-enter,.jupyter-wrapper .bp3-drawer.bp3-position-right.bp3-overlay-appear{-webkit-transform:translateX(100%);transform:translateX(100%)}.jupyter-wrapper .bp3-drawer.bp3-position-right.bp3-overlay-enter-active,.jupyter-wrapper .bp3-drawer.bp3-position-right.bp3-overlay-appear-active{-webkit-transform:translateX(0);transform:translateX(0);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:200ms;transition-duration:200ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-drawer.bp3-position-right.bp3-overlay-exit{-webkit-transform:translateX(0);transform:translateX(0)}.jupyter-wrapper .bp3-drawer.bp3-position-right.bp3-overlay-exit-active{-webkit-transform:translateX(100%);transform:translateX(100%);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:100ms;transition-duration:100ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-drawer:not(.bp3-position-top):not(.bp3-position-bottom):not(.bp3-position-left):not(.bp3-position-right):not(.bp3-vertical){top:0;right:0;bottom:0;width:50%}.jupyter-wrapper .bp3-drawer:not(.bp3-position-top):not(.bp3-position-bottom):not(.bp3-position-left):not(.bp3-position-right):not(.bp3-vertical).bp3-overlay-enter,.jupyter-wrapper .bp3-drawer:not(.bp3-position-top):not(.bp3-position-bottom):not(.bp3-position-left):not(.bp3-position-right):not(.bp3-vertical).bp3-overlay-appear{-webkit-transform:translateX(100%);transform:translateX(100%)}.jupyter-wrapper .bp3-drawer:not(.bp3-position-top):not(.bp3-position-bottom):not(.bp3-position-left):not(.bp3-position-right):not(.bp3-vertical).bp3-overlay-enter-active,.jupyter-wrapper .bp3-drawer:not(.bp3-position-top):not(.bp3-position-bottom):not(.bp3-position-left):not(.bp3-position-right):not(.bp3-vertical).bp3-overlay-appear-active{-webkit-transform:translateX(0);transform:translateX(0);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:200ms;transition-duration:200ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-drawer:not(.bp3-position-top):not(.bp3-position-bottom):not(.bp3-position-left):not(.bp3-position-right):not(.bp3-vertical).bp3-overlay-exit{-webkit-transform:translateX(0);transform:translateX(0)}.jupyter-wrapper .bp3-drawer:not(.bp3-position-top):not(.bp3-position-bottom):not(.bp3-position-left):not(.bp3-position-right):not(.bp3-vertical).bp3-overlay-exit-active{-webkit-transform:translateX(100%);transform:translateX(100%);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:100ms;transition-duration:100ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-drawer:not(.bp3-position-top):not(.bp3-position-bottom):not(.bp3-position-left):not(.bp3-position-right).bp3-vertical{right:0;bottom:0;left:0;height:50%}.jupyter-wrapper .bp3-drawer:not(.bp3-position-top):not(.bp3-position-bottom):not(.bp3-position-left):not(.bp3-position-right).bp3-vertical.bp3-overlay-enter,.jupyter-wrapper .bp3-drawer:not(.bp3-position-top):not(.bp3-position-bottom):not(.bp3-position-left):not(.bp3-position-right).bp3-vertical.bp3-overlay-appear{-webkit-transform:translateY(100%);transform:translateY(100%)}.jupyter-wrapper .bp3-drawer:not(.bp3-position-top):not(.bp3-position-bottom):not(.bp3-position-left):not(.bp3-position-right).bp3-vertical.bp3-overlay-enter-active,.jupyter-wrapper .bp3-drawer:not(.bp3-position-top):not(.bp3-position-bottom):not(.bp3-position-left):not(.bp3-position-right).bp3-vertical.bp3-overlay-appear-active{-webkit-transform:translateY(0);transform:translateY(0);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:200ms;transition-duration:200ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-drawer:not(.bp3-position-top):not(.bp3-position-bottom):not(.bp3-position-left):not(.bp3-position-right).bp3-vertical.bp3-overlay-exit{-webkit-transform:translateY(0);transform:translateY(0)}.jupyter-wrapper .bp3-drawer:not(.bp3-position-top):not(.bp3-position-bottom):not(.bp3-position-left):not(.bp3-position-right).bp3-vertical.bp3-overlay-exit-active{-webkit-transform:translateY(100%);transform:translateY(100%);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:100ms;transition-duration:100ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-drawer.bp3-dark,.jupyter-wrapper .bp3-dark .bp3-drawer{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),0 4px 8px rgba(16,22,26,.4),0 18px 46px 6px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.2),0 4px 8px rgba(16,22,26,.4),0 18px 46px 6px rgba(16,22,26,.4);background:#30404d;color:#f5f8fa}.jupyter-wrapper .bp3-drawer-header{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:0 0 auto;-webkit-box-align:center;-ms-flex-align:center;align-items:center;position:relative;border-radius:0;-webkit-box-shadow:0 1px 0 rgba(16,22,26,.15);box-shadow:0 1px 0 rgba(16,22,26,.15);min-height:40px;padding:5px;padding-left:20px}.jupyter-wrapper .bp3-drawer-header .bp3-icon-large,.jupyter-wrapper .bp3-drawer-header .bp3-icon{-webkit-box-flex:0;-ms-flex:0 0 auto;flex:0 0 auto;margin-right:10px;color:#5c7080}.jupyter-wrapper .bp3-drawer-header .bp3-heading{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-wrap:normal;-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;margin:0;line-height:inherit}.jupyter-wrapper .bp3-drawer-header .bp3-heading:last-child{margin-right:20px}.jupyter-wrapper .bp3-dark .bp3-drawer-header{-webkit-box-shadow:0 1px 0 rgba(16,22,26,.4);box-shadow:0 1px 0 rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-drawer-header .bp3-icon-large,.jupyter-wrapper .bp3-dark .bp3-drawer-header .bp3-icon{color:#a7b6c2}.jupyter-wrapper .bp3-drawer-body{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;overflow:auto;line-height:18px}.jupyter-wrapper .bp3-drawer-footer{-webkit-box-flex:0;-ms-flex:0 0 auto;flex:0 0 auto;position:relative;-webkit-box-shadow:inset 0 1px 0 rgba(16,22,26,.15);box-shadow:inset 0 1px 0 rgba(16,22,26,.15);padding:10px 20px}.jupyter-wrapper .bp3-dark .bp3-drawer-footer{-webkit-box-shadow:inset 0 1px 0 rgba(16,22,26,.4);box-shadow:inset 0 1px 0 rgba(16,22,26,.4)}.jupyter-wrapper .bp3-editable-text{display:inline-block;position:relative;cursor:text;max-width:100%;vertical-align:top;white-space:nowrap}.jupyter-wrapper .bp3-editable-text::before{position:absolute;top:-3px;right:-3px;bottom:-3px;left:-3px;border-radius:3px;content:\"\";-webkit-transition:background-color 100ms cubic-bezier(0.4, 1, 0.75, 0.9),-webkit-box-shadow 100ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:background-color 100ms cubic-bezier(0.4, 1, 0.75, 0.9),-webkit-box-shadow 100ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:background-color 100ms cubic-bezier(0.4, 1, 0.75, 0.9),box-shadow 100ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:background-color 100ms cubic-bezier(0.4, 1, 0.75, 0.9),box-shadow 100ms cubic-bezier(0.4, 1, 0.75, 0.9),-webkit-box-shadow 100ms cubic-bezier(0.4, 1, 0.75, 0.9)}.jupyter-wrapper .bp3-editable-text:hover::before{-webkit-box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px rgba(16,22,26,.15);box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px rgba(16,22,26,.15)}.jupyter-wrapper .bp3-editable-text.bp3-editable-text-editing::before{-webkit-box-shadow:0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 1px 1px rgba(16,22,26,.2);background-color:#fff}.jupyter-wrapper .bp3-editable-text.bp3-disabled::before{-webkit-box-shadow:none;box-shadow:none}.jupyter-wrapper .bp3-editable-text.bp3-intent-primary .bp3-editable-text-input,.jupyter-wrapper .bp3-editable-text.bp3-intent-primary .bp3-editable-text-content{color:#137cbd}.jupyter-wrapper .bp3-editable-text.bp3-intent-primary:hover::before{-webkit-box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px rgba(19,124,189,.4);box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px rgba(19,124,189,.4)}.jupyter-wrapper .bp3-editable-text.bp3-intent-primary.bp3-editable-text-editing::before{-webkit-box-shadow:0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-editable-text.bp3-intent-success .bp3-editable-text-input,.jupyter-wrapper .bp3-editable-text.bp3-intent-success .bp3-editable-text-content{color:#0f9960}.jupyter-wrapper .bp3-editable-text.bp3-intent-success:hover::before{-webkit-box-shadow:0 0 0 0 rgba(15,153,96,0),0 0 0 0 rgba(15,153,96,0),inset 0 0 0 1px rgba(15,153,96,.4);box-shadow:0 0 0 0 rgba(15,153,96,0),0 0 0 0 rgba(15,153,96,0),inset 0 0 0 1px rgba(15,153,96,.4)}.jupyter-wrapper .bp3-editable-text.bp3-intent-success.bp3-editable-text-editing::before{-webkit-box-shadow:0 0 0 1px #0f9960,0 0 0 3px rgba(15,153,96,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #0f9960,0 0 0 3px rgba(15,153,96,.3),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-editable-text.bp3-intent-warning .bp3-editable-text-input,.jupyter-wrapper .bp3-editable-text.bp3-intent-warning .bp3-editable-text-content{color:#d9822b}.jupyter-wrapper .bp3-editable-text.bp3-intent-warning:hover::before{-webkit-box-shadow:0 0 0 0 rgba(217,130,43,0),0 0 0 0 rgba(217,130,43,0),inset 0 0 0 1px rgba(217,130,43,.4);box-shadow:0 0 0 0 rgba(217,130,43,0),0 0 0 0 rgba(217,130,43,0),inset 0 0 0 1px rgba(217,130,43,.4)}.jupyter-wrapper .bp3-editable-text.bp3-intent-warning.bp3-editable-text-editing::before{-webkit-box-shadow:0 0 0 1px #d9822b,0 0 0 3px rgba(217,130,43,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #d9822b,0 0 0 3px rgba(217,130,43,.3),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-editable-text.bp3-intent-danger .bp3-editable-text-input,.jupyter-wrapper .bp3-editable-text.bp3-intent-danger .bp3-editable-text-content{color:#db3737}.jupyter-wrapper .bp3-editable-text.bp3-intent-danger:hover::before{-webkit-box-shadow:0 0 0 0 rgba(219,55,55,0),0 0 0 0 rgba(219,55,55,0),inset 0 0 0 1px rgba(219,55,55,.4);box-shadow:0 0 0 0 rgba(219,55,55,0),0 0 0 0 rgba(219,55,55,0),inset 0 0 0 1px rgba(219,55,55,.4)}.jupyter-wrapper .bp3-editable-text.bp3-intent-danger.bp3-editable-text-editing::before{-webkit-box-shadow:0 0 0 1px #db3737,0 0 0 3px rgba(219,55,55,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #db3737,0 0 0 3px rgba(219,55,55,.3),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-dark .bp3-editable-text:hover::before{-webkit-box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px rgba(255,255,255,.15);box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px rgba(255,255,255,.15)}.jupyter-wrapper .bp3-dark .bp3-editable-text.bp3-editable-text-editing::before{-webkit-box-shadow:0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);background-color:rgba(16,22,26,.3)}.jupyter-wrapper .bp3-dark .bp3-editable-text.bp3-disabled::before{-webkit-box-shadow:none;box-shadow:none}.jupyter-wrapper .bp3-dark .bp3-editable-text.bp3-intent-primary .bp3-editable-text-content{color:#48aff0}.jupyter-wrapper .bp3-dark .bp3-editable-text.bp3-intent-primary:hover::before{-webkit-box-shadow:0 0 0 0 rgba(72,175,240,0),0 0 0 0 rgba(72,175,240,0),inset 0 0 0 1px rgba(72,175,240,.4);box-shadow:0 0 0 0 rgba(72,175,240,0),0 0 0 0 rgba(72,175,240,0),inset 0 0 0 1px rgba(72,175,240,.4)}.jupyter-wrapper .bp3-dark .bp3-editable-text.bp3-intent-primary.bp3-editable-text-editing::before{-webkit-box-shadow:0 0 0 1px #48aff0,0 0 0 3px rgba(72,175,240,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px #48aff0,0 0 0 3px rgba(72,175,240,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-editable-text.bp3-intent-success .bp3-editable-text-content{color:#3dcc91}.jupyter-wrapper .bp3-dark .bp3-editable-text.bp3-intent-success:hover::before{-webkit-box-shadow:0 0 0 0 rgba(61,204,145,0),0 0 0 0 rgba(61,204,145,0),inset 0 0 0 1px rgba(61,204,145,.4);box-shadow:0 0 0 0 rgba(61,204,145,0),0 0 0 0 rgba(61,204,145,0),inset 0 0 0 1px rgba(61,204,145,.4)}.jupyter-wrapper .bp3-dark .bp3-editable-text.bp3-intent-success.bp3-editable-text-editing::before{-webkit-box-shadow:0 0 0 1px #3dcc91,0 0 0 3px rgba(61,204,145,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px #3dcc91,0 0 0 3px rgba(61,204,145,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-editable-text.bp3-intent-warning .bp3-editable-text-content{color:#ffb366}.jupyter-wrapper .bp3-dark .bp3-editable-text.bp3-intent-warning:hover::before{-webkit-box-shadow:0 0 0 0 rgba(255,179,102,0),0 0 0 0 rgba(255,179,102,0),inset 0 0 0 1px rgba(255,179,102,.4);box-shadow:0 0 0 0 rgba(255,179,102,0),0 0 0 0 rgba(255,179,102,0),inset 0 0 0 1px rgba(255,179,102,.4)}.jupyter-wrapper .bp3-dark .bp3-editable-text.bp3-intent-warning.bp3-editable-text-editing::before{-webkit-box-shadow:0 0 0 1px #ffb366,0 0 0 3px rgba(255,179,102,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px #ffb366,0 0 0 3px rgba(255,179,102,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-editable-text.bp3-intent-danger .bp3-editable-text-content{color:#ff7373}.jupyter-wrapper .bp3-dark .bp3-editable-text.bp3-intent-danger:hover::before{-webkit-box-shadow:0 0 0 0 rgba(255,115,115,0),0 0 0 0 rgba(255,115,115,0),inset 0 0 0 1px rgba(255,115,115,.4);box-shadow:0 0 0 0 rgba(255,115,115,0),0 0 0 0 rgba(255,115,115,0),inset 0 0 0 1px rgba(255,115,115,.4)}.jupyter-wrapper .bp3-dark .bp3-editable-text.bp3-intent-danger.bp3-editable-text-editing::before{-webkit-box-shadow:0 0 0 1px #ff7373,0 0 0 3px rgba(255,115,115,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px #ff7373,0 0 0 3px rgba(255,115,115,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-editable-text-input,.jupyter-wrapper .bp3-editable-text-content{display:inherit;position:relative;min-width:inherit;max-width:inherit;vertical-align:top;text-transform:inherit;letter-spacing:inherit;color:inherit;font:inherit;resize:none}.jupyter-wrapper .bp3-editable-text-input{border:none;-webkit-box-shadow:none;box-shadow:none;background:none;width:100%;padding:0;white-space:pre-wrap}.jupyter-wrapper .bp3-editable-text-input::-webkit-input-placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-editable-text-input::-moz-placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-editable-text-input:-ms-input-placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-editable-text-input::-ms-input-placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-editable-text-input::placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-editable-text-input:focus{outline:none}.jupyter-wrapper .bp3-editable-text-input::-ms-clear{display:none}.jupyter-wrapper .bp3-editable-text-content{overflow:hidden;padding-right:2px;text-overflow:ellipsis;white-space:pre}.jupyter-wrapper .bp3-editable-text-editing>.bp3-editable-text-content{position:absolute;left:0;visibility:hidden}.jupyter-wrapper .bp3-editable-text-placeholder>.bp3-editable-text-content{color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-dark .bp3-editable-text-placeholder>.bp3-editable-text-content{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-editable-text.bp3-multiline{display:block}.jupyter-wrapper .bp3-editable-text.bp3-multiline .bp3-editable-text-content{overflow:auto;white-space:pre-wrap;word-wrap:break-word}.jupyter-wrapper .bp3-control-group{-webkit-transform:translateZ(0);transform:translateZ(0);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch}.jupyter-wrapper .bp3-control-group>*{-webkit-box-flex:0;-ms-flex-positive:0;flex-grow:0;-ms-flex-negative:0;flex-shrink:0}.jupyter-wrapper .bp3-control-group>.bp3-fill{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-negative:1;flex-shrink:1}.jupyter-wrapper .bp3-control-group .bp3-button,.jupyter-wrapper .bp3-control-group .bp3-html-select,.jupyter-wrapper .bp3-control-group .bp3-input,.jupyter-wrapper .bp3-control-group .bp3-select{position:relative}.jupyter-wrapper .bp3-control-group .bp3-input{z-index:2;border-radius:inherit}.jupyter-wrapper .bp3-control-group .bp3-input:focus{z-index:14;border-radius:3px}.jupyter-wrapper .bp3-control-group .bp3-input[class*=bp3-intent]{z-index:13}.jupyter-wrapper .bp3-control-group .bp3-input[class*=bp3-intent]:focus{z-index:15}.jupyter-wrapper .bp3-control-group .bp3-input[readonly],.jupyter-wrapper .bp3-control-group .bp3-input:disabled,.jupyter-wrapper .bp3-control-group .bp3-input.bp3-disabled{z-index:1}.jupyter-wrapper .bp3-control-group .bp3-input-group[class*=bp3-intent] .bp3-input{z-index:13}.jupyter-wrapper .bp3-control-group .bp3-input-group[class*=bp3-intent] .bp3-input:focus{z-index:15}.jupyter-wrapper .bp3-control-group .bp3-button,.jupyter-wrapper .bp3-control-group .bp3-html-select select,.jupyter-wrapper .bp3-control-group .bp3-select select{-webkit-transform:translateZ(0);transform:translateZ(0);z-index:4;border-radius:inherit}.jupyter-wrapper .bp3-control-group .bp3-button:focus,.jupyter-wrapper .bp3-control-group .bp3-html-select select:focus,.jupyter-wrapper .bp3-control-group .bp3-select select:focus{z-index:5}.jupyter-wrapper .bp3-control-group .bp3-button:hover,.jupyter-wrapper .bp3-control-group .bp3-html-select select:hover,.jupyter-wrapper .bp3-control-group .bp3-select select:hover{z-index:6}.jupyter-wrapper .bp3-control-group .bp3-button:active,.jupyter-wrapper .bp3-control-group .bp3-html-select select:active,.jupyter-wrapper .bp3-control-group .bp3-select select:active{z-index:7}.jupyter-wrapper .bp3-control-group .bp3-button[readonly],.jupyter-wrapper .bp3-control-group .bp3-button:disabled,.jupyter-wrapper .bp3-control-group .bp3-button.bp3-disabled,.jupyter-wrapper .bp3-control-group .bp3-html-select select[readonly],.jupyter-wrapper .bp3-control-group .bp3-html-select select:disabled,.jupyter-wrapper .bp3-control-group .bp3-html-select select.bp3-disabled,.jupyter-wrapper .bp3-control-group .bp3-select select[readonly],.jupyter-wrapper .bp3-control-group .bp3-select select:disabled,.jupyter-wrapper .bp3-control-group .bp3-select select.bp3-disabled{z-index:3}.jupyter-wrapper .bp3-control-group .bp3-button[class*=bp3-intent],.jupyter-wrapper .bp3-control-group .bp3-html-select select[class*=bp3-intent],.jupyter-wrapper .bp3-control-group .bp3-select select[class*=bp3-intent]{z-index:9}.jupyter-wrapper .bp3-control-group .bp3-button[class*=bp3-intent]:focus,.jupyter-wrapper .bp3-control-group .bp3-html-select select[class*=bp3-intent]:focus,.jupyter-wrapper .bp3-control-group .bp3-select select[class*=bp3-intent]:focus{z-index:10}.jupyter-wrapper .bp3-control-group .bp3-button[class*=bp3-intent]:hover,.jupyter-wrapper .bp3-control-group .bp3-html-select select[class*=bp3-intent]:hover,.jupyter-wrapper .bp3-control-group .bp3-select select[class*=bp3-intent]:hover{z-index:11}.jupyter-wrapper .bp3-control-group .bp3-button[class*=bp3-intent]:active,.jupyter-wrapper .bp3-control-group .bp3-html-select select[class*=bp3-intent]:active,.jupyter-wrapper .bp3-control-group .bp3-select select[class*=bp3-intent]:active{z-index:12}.jupyter-wrapper .bp3-control-group .bp3-button[class*=bp3-intent][readonly],.jupyter-wrapper .bp3-control-group .bp3-button[class*=bp3-intent]:disabled,.jupyter-wrapper .bp3-control-group .bp3-button[class*=bp3-intent].bp3-disabled,.jupyter-wrapper .bp3-control-group .bp3-html-select select[class*=bp3-intent][readonly],.jupyter-wrapper .bp3-control-group .bp3-html-select select[class*=bp3-intent]:disabled,.jupyter-wrapper .bp3-control-group .bp3-html-select select[class*=bp3-intent].bp3-disabled,.jupyter-wrapper .bp3-control-group .bp3-select select[class*=bp3-intent][readonly],.jupyter-wrapper .bp3-control-group .bp3-select select[class*=bp3-intent]:disabled,.jupyter-wrapper .bp3-control-group .bp3-select select[class*=bp3-intent].bp3-disabled{z-index:8}.jupyter-wrapper .bp3-control-group .bp3-input-group>.bp3-icon,.jupyter-wrapper .bp3-control-group .bp3-input-group>.bp3-button,.jupyter-wrapper .bp3-control-group .bp3-input-group>.bp3-input-action{z-index:16}.jupyter-wrapper .bp3-control-group .bp3-select::after,.jupyter-wrapper .bp3-control-group .bp3-html-select::after,.jupyter-wrapper .bp3-control-group .bp3-select>.bp3-icon,.jupyter-wrapper .bp3-control-group .bp3-html-select>.bp3-icon{z-index:17}.jupyter-wrapper .bp3-control-group:not(.bp3-vertical)>*{margin-right:-1px}.jupyter-wrapper .bp3-dark .bp3-control-group:not(.bp3-vertical)>*{margin-right:0}.jupyter-wrapper .bp3-dark .bp3-control-group:not(.bp3-vertical)>.bp3-button+.bp3-button{margin-left:1px}.jupyter-wrapper .bp3-control-group .bp3-popover-wrapper,.jupyter-wrapper .bp3-control-group .bp3-popover-target{border-radius:inherit}.jupyter-wrapper .bp3-control-group>:first-child{border-radius:3px 0 0 3px}.jupyter-wrapper .bp3-control-group>:last-child{margin-right:0;border-radius:0 3px 3px 0}.jupyter-wrapper .bp3-control-group>:only-child{margin-right:0;border-radius:3px}.jupyter-wrapper .bp3-control-group .bp3-input-group .bp3-button{border-radius:3px}.jupyter-wrapper .bp3-control-group>.bp3-fill{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto}.jupyter-wrapper .bp3-control-group.bp3-fill>*:not(.bp3-fixed){-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto}.jupyter-wrapper .bp3-control-group.bp3-vertical{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.jupyter-wrapper .bp3-control-group.bp3-vertical>*{margin-top:-1px}.jupyter-wrapper .bp3-control-group.bp3-vertical>:first-child{margin-top:0;border-radius:3px 3px 0 0}.jupyter-wrapper .bp3-control-group.bp3-vertical>:last-child{border-radius:0 0 3px 3px}.jupyter-wrapper .bp3-control{display:block;position:relative;margin-bottom:10px;cursor:pointer;text-transform:none}.jupyter-wrapper .bp3-control input:checked~.bp3-control-indicator{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);background-color:#137cbd;background-image:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0.1)), to(rgba(255, 255, 255, 0)));background-image:linear-gradient(to bottom, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0));color:#fff}.jupyter-wrapper .bp3-control:hover input:checked~.bp3-control-indicator{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);background-color:#106ba3}.jupyter-wrapper .bp3-control input:not(:disabled):active:checked~.bp3-control-indicator{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 1px 2px rgba(16,22,26,.2);background:#0e5a8a}.jupyter-wrapper .bp3-control input:disabled:checked~.bp3-control-indicator{-webkit-box-shadow:none;box-shadow:none;background:rgba(19,124,189,.5)}.jupyter-wrapper .bp3-dark .bp3-control input:checked~.bp3-control-indicator{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-control:hover input:checked~.bp3-control-indicator{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.4);background-color:#106ba3}.jupyter-wrapper .bp3-dark .bp3-control input:not(:disabled):active:checked~.bp3-control-indicator{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.4),inset 0 1px 2px rgba(16,22,26,.2);background-color:#0e5a8a}.jupyter-wrapper .bp3-dark .bp3-control input:disabled:checked~.bp3-control-indicator{-webkit-box-shadow:none;box-shadow:none;background:rgba(14,90,138,.5)}.jupyter-wrapper .bp3-control:not(.bp3-align-right){padding-left:26px}.jupyter-wrapper .bp3-control:not(.bp3-align-right) .bp3-control-indicator{margin-left:-26px}.jupyter-wrapper .bp3-control.bp3-align-right{padding-right:26px}.jupyter-wrapper .bp3-control.bp3-align-right .bp3-control-indicator{margin-right:-26px}.jupyter-wrapper .bp3-control.bp3-disabled{cursor:not-allowed;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-control.bp3-inline{display:inline-block;margin-right:20px}.jupyter-wrapper .bp3-control input{position:absolute;top:0;left:0;opacity:0;z-index:-1}.jupyter-wrapper .bp3-control .bp3-control-indicator{display:inline-block;position:relative;margin-top:-3px;margin-right:10px;border:none;-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);background-clip:padding-box;background-color:#f5f8fa;background-image:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0.8)), to(rgba(255, 255, 255, 0)));background-image:linear-gradient(to bottom, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0));cursor:pointer;width:1em;height:1em;vertical-align:middle;font-size:16px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.jupyter-wrapper .bp3-control .bp3-control-indicator::before{display:block;width:1em;height:1em;content:\"\"}.jupyter-wrapper .bp3-control:hover .bp3-control-indicator{background-color:#ebf1f5}.jupyter-wrapper .bp3-control input:not(:disabled):active~.bp3-control-indicator{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 1px 2px rgba(16,22,26,.2);background:#d8e1e8}.jupyter-wrapper .bp3-control input:disabled~.bp3-control-indicator{-webkit-box-shadow:none;box-shadow:none;background:rgba(206,217,224,.5);cursor:not-allowed}.jupyter-wrapper .bp3-control input:focus~.bp3-control-indicator{outline:rgba(19,124,189,.6) auto 2px;outline-offset:2px;-moz-outline-radius:6px}.jupyter-wrapper .bp3-control.bp3-align-right .bp3-control-indicator{float:right;margin-top:1px;margin-left:10px}.jupyter-wrapper .bp3-control.bp3-large{font-size:16px}.jupyter-wrapper .bp3-control.bp3-large:not(.bp3-align-right){padding-left:30px}.jupyter-wrapper .bp3-control.bp3-large:not(.bp3-align-right) .bp3-control-indicator{margin-left:-30px}.jupyter-wrapper .bp3-control.bp3-large.bp3-align-right{padding-right:30px}.jupyter-wrapper .bp3-control.bp3-large.bp3-align-right .bp3-control-indicator{margin-right:-30px}.jupyter-wrapper .bp3-control.bp3-large .bp3-control-indicator{font-size:20px}.jupyter-wrapper .bp3-control.bp3-large.bp3-align-right .bp3-control-indicator{margin-top:0}.jupyter-wrapper .bp3-control.bp3-checkbox input:indeterminate~.bp3-control-indicator{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);background-color:#137cbd;background-image:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0.1)), to(rgba(255, 255, 255, 0)));background-image:linear-gradient(to bottom, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0));color:#fff}.jupyter-wrapper .bp3-control.bp3-checkbox:hover input:indeterminate~.bp3-control-indicator{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 -1px 0 rgba(16,22,26,.2);background-color:#106ba3}.jupyter-wrapper .bp3-control.bp3-checkbox input:not(:disabled):active:indeterminate~.bp3-control-indicator{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4),inset 0 1px 2px rgba(16,22,26,.2);background:#0e5a8a}.jupyter-wrapper .bp3-control.bp3-checkbox input:disabled:indeterminate~.bp3-control-indicator{-webkit-box-shadow:none;box-shadow:none;background:rgba(19,124,189,.5)}.jupyter-wrapper .bp3-dark .bp3-control.bp3-checkbox input:indeterminate~.bp3-control-indicator{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-control.bp3-checkbox:hover input:indeterminate~.bp3-control-indicator{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.4);background-color:#106ba3}.jupyter-wrapper .bp3-dark .bp3-control.bp3-checkbox input:not(:disabled):active:indeterminate~.bp3-control-indicator{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.4),inset 0 1px 2px rgba(16,22,26,.2);background-color:#0e5a8a}.jupyter-wrapper .bp3-dark .bp3-control.bp3-checkbox input:disabled:indeterminate~.bp3-control-indicator{-webkit-box-shadow:none;box-shadow:none;background:rgba(14,90,138,.5)}.jupyter-wrapper .bp3-control.bp3-checkbox .bp3-control-indicator{border-radius:3px}.jupyter-wrapper .bp3-control.bp3-checkbox input:checked~.bp3-control-indicator::before{background-image:url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill-rule='evenodd' clip-rule='evenodd' d='M12 5c-.28 0-.53.11-.71.29L7 9.59l-2.29-2.3a1.003 1.003 0 0 0-1.42 1.42l3 3c.18.18.43.29.71.29s.53-.11.71-.29l5-5A1.003 1.003 0 0 0 12 5z' fill='white'/%3e%3c/svg%3e\")}.jupyter-wrapper .bp3-control.bp3-checkbox input:indeterminate~.bp3-control-indicator::before{background-image:url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill-rule='evenodd' clip-rule='evenodd' d='M11 7H5c-.55 0-1 .45-1 1s.45 1 1 1h6c.55 0 1-.45 1-1s-.45-1-1-1z' fill='white'/%3e%3c/svg%3e\")}.jupyter-wrapper .bp3-control.bp3-radio .bp3-control-indicator{border-radius:50%}.jupyter-wrapper .bp3-control.bp3-radio input:checked~.bp3-control-indicator::before{background-image:radial-gradient(#ffffff, #ffffff 28%, transparent 32%)}.jupyter-wrapper .bp3-control.bp3-radio input:checked:disabled~.bp3-control-indicator::before{opacity:.5}.jupyter-wrapper .bp3-control.bp3-radio input:focus~.bp3-control-indicator{-moz-outline-radius:16px}.jupyter-wrapper .bp3-control.bp3-switch input~.bp3-control-indicator{background:rgba(167,182,194,.5)}.jupyter-wrapper .bp3-control.bp3-switch:hover input~.bp3-control-indicator{background:rgba(115,134,148,.5)}.jupyter-wrapper .bp3-control.bp3-switch input:not(:disabled):active~.bp3-control-indicator{background:rgba(92,112,128,.5)}.jupyter-wrapper .bp3-control.bp3-switch input:disabled~.bp3-control-indicator{background:rgba(206,217,224,.5)}.jupyter-wrapper .bp3-control.bp3-switch input:disabled~.bp3-control-indicator::before{background:rgba(255,255,255,.8)}.jupyter-wrapper .bp3-control.bp3-switch input:checked~.bp3-control-indicator{background:#137cbd}.jupyter-wrapper .bp3-control.bp3-switch:hover input:checked~.bp3-control-indicator{background:#106ba3}.jupyter-wrapper .bp3-control.bp3-switch input:checked:not(:disabled):active~.bp3-control-indicator{background:#0e5a8a}.jupyter-wrapper .bp3-control.bp3-switch input:checked:disabled~.bp3-control-indicator{background:rgba(19,124,189,.5)}.jupyter-wrapper .bp3-control.bp3-switch input:checked:disabled~.bp3-control-indicator::before{background:rgba(255,255,255,.8)}.jupyter-wrapper .bp3-control.bp3-switch:not(.bp3-align-right){padding-left:38px}.jupyter-wrapper .bp3-control.bp3-switch:not(.bp3-align-right) .bp3-control-indicator{margin-left:-38px}.jupyter-wrapper .bp3-control.bp3-switch.bp3-align-right{padding-right:38px}.jupyter-wrapper .bp3-control.bp3-switch.bp3-align-right .bp3-control-indicator{margin-right:-38px}.jupyter-wrapper .bp3-control.bp3-switch .bp3-control-indicator{border:none;border-radius:1.75em;-webkit-box-shadow:none !important;box-shadow:none !important;width:auto;min-width:1.75em;-webkit-transition:background-color 100ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:background-color 100ms cubic-bezier(0.4, 1, 0.75, 0.9)}.jupyter-wrapper .bp3-control.bp3-switch .bp3-control-indicator::before{position:absolute;left:0;margin:2px;border-radius:50%;-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.2),0 1px 1px rgba(16,22,26,.2);background:#fff;width:calc(1em - 4px);height:calc(1em - 4px);-webkit-transition:left 100ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:left 100ms cubic-bezier(0.4, 1, 0.75, 0.9)}.jupyter-wrapper .bp3-control.bp3-switch input:checked~.bp3-control-indicator::before{left:calc(100% - 1em)}.jupyter-wrapper .bp3-control.bp3-switch.bp3-large:not(.bp3-align-right){padding-left:45px}.jupyter-wrapper .bp3-control.bp3-switch.bp3-large:not(.bp3-align-right) .bp3-control-indicator{margin-left:-45px}.jupyter-wrapper .bp3-control.bp3-switch.bp3-large.bp3-align-right{padding-right:45px}.jupyter-wrapper .bp3-control.bp3-switch.bp3-large.bp3-align-right .bp3-control-indicator{margin-right:-45px}.jupyter-wrapper .bp3-dark .bp3-control.bp3-switch input~.bp3-control-indicator{background:rgba(16,22,26,.5)}.jupyter-wrapper .bp3-dark .bp3-control.bp3-switch:hover input~.bp3-control-indicator{background:rgba(16,22,26,.7)}.jupyter-wrapper .bp3-dark .bp3-control.bp3-switch input:not(:disabled):active~.bp3-control-indicator{background:rgba(16,22,26,.9)}.jupyter-wrapper .bp3-dark .bp3-control.bp3-switch input:disabled~.bp3-control-indicator{background:rgba(57,75,89,.5)}.jupyter-wrapper .bp3-dark .bp3-control.bp3-switch input:disabled~.bp3-control-indicator::before{background:rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-control.bp3-switch input:checked~.bp3-control-indicator{background:#137cbd}.jupyter-wrapper .bp3-dark .bp3-control.bp3-switch:hover input:checked~.bp3-control-indicator{background:#106ba3}.jupyter-wrapper .bp3-dark .bp3-control.bp3-switch input:checked:not(:disabled):active~.bp3-control-indicator{background:#0e5a8a}.jupyter-wrapper .bp3-dark .bp3-control.bp3-switch input:checked:disabled~.bp3-control-indicator{background:rgba(14,90,138,.5)}.jupyter-wrapper .bp3-dark .bp3-control.bp3-switch input:checked:disabled~.bp3-control-indicator::before{background:rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-control.bp3-switch .bp3-control-indicator::before{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.4);background:#394b59}.jupyter-wrapper .bp3-dark .bp3-control.bp3-switch input:checked~.bp3-control-indicator::before{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-control.bp3-switch .bp3-switch-inner-text{text-align:center;font-size:.7em}.jupyter-wrapper .bp3-control.bp3-switch .bp3-control-indicator-child:first-child{visibility:hidden;margin-right:1.2em;margin-left:.5em;line-height:0}.jupyter-wrapper .bp3-control.bp3-switch .bp3-control-indicator-child:last-child{visibility:visible;margin-right:.5em;margin-left:1.2em;line-height:1em}.jupyter-wrapper .bp3-control.bp3-switch input:checked~.bp3-control-indicator .bp3-control-indicator-child:first-child{visibility:visible;line-height:1em}.jupyter-wrapper .bp3-control.bp3-switch input:checked~.bp3-control-indicator .bp3-control-indicator-child:last-child{visibility:hidden;line-height:0}.jupyter-wrapper .bp3-dark .bp3-control{color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-control.bp3-disabled{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-control .bp3-control-indicator{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.4);background-color:#394b59;background-image:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0.05)), to(rgba(255, 255, 255, 0)));background-image:linear-gradient(to bottom, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0))}.jupyter-wrapper .bp3-dark .bp3-control:hover .bp3-control-indicator{background-color:#30404d}.jupyter-wrapper .bp3-dark .bp3-control input:not(:disabled):active~.bp3-control-indicator{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.6),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.6),inset 0 1px 2px rgba(16,22,26,.2);background:#202b33}.jupyter-wrapper .bp3-dark .bp3-control input:disabled~.bp3-control-indicator{-webkit-box-shadow:none;box-shadow:none;background:rgba(57,75,89,.5);cursor:not-allowed}.jupyter-wrapper .bp3-dark .bp3-control.bp3-checkbox input:disabled:checked~.bp3-control-indicator,.jupyter-wrapper .bp3-dark .bp3-control.bp3-checkbox input:disabled:indeterminate~.bp3-control-indicator{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-file-input{display:inline-block;position:relative;cursor:pointer;height:30px}.jupyter-wrapper .bp3-file-input input{opacity:0;margin:0;min-width:200px}.jupyter-wrapper .bp3-file-input input:disabled+.bp3-file-upload-input,.jupyter-wrapper .bp3-file-input input.bp3-disabled+.bp3-file-upload-input{-webkit-box-shadow:none;box-shadow:none;background:rgba(206,217,224,.5);cursor:not-allowed;color:rgba(92,112,128,.6);resize:none}.jupyter-wrapper .bp3-file-input input:disabled+.bp3-file-upload-input::after,.jupyter-wrapper .bp3-file-input input.bp3-disabled+.bp3-file-upload-input::after{outline:none;-webkit-box-shadow:none;box-shadow:none;background-color:rgba(206,217,224,.5);background-image:none;cursor:not-allowed;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-file-input input:disabled+.bp3-file-upload-input::after.bp3-active,.jupyter-wrapper .bp3-file-input input:disabled+.bp3-file-upload-input::after.bp3-active:hover,.jupyter-wrapper .bp3-file-input input.bp3-disabled+.bp3-file-upload-input::after.bp3-active,.jupyter-wrapper .bp3-file-input input.bp3-disabled+.bp3-file-upload-input::after.bp3-active:hover{background:rgba(206,217,224,.7)}.jupyter-wrapper .bp3-dark .bp3-file-input input:disabled+.bp3-file-upload-input,.jupyter-wrapper .bp3-dark .bp3-file-input input.bp3-disabled+.bp3-file-upload-input{-webkit-box-shadow:none;box-shadow:none;background:rgba(57,75,89,.5);color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-file-input input:disabled+.bp3-file-upload-input::after,.jupyter-wrapper .bp3-dark .bp3-file-input input.bp3-disabled+.bp3-file-upload-input::after{-webkit-box-shadow:none;box-shadow:none;background-color:rgba(57,75,89,.5);background-image:none;color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-file-input input:disabled+.bp3-file-upload-input::after.bp3-active,.jupyter-wrapper .bp3-dark .bp3-file-input input.bp3-disabled+.bp3-file-upload-input::after.bp3-active{background:rgba(57,75,89,.7)}.jupyter-wrapper .bp3-file-input.bp3-file-input-has-selection .bp3-file-upload-input{color:#182026}.jupyter-wrapper .bp3-dark .bp3-file-input.bp3-file-input-has-selection .bp3-file-upload-input{color:#f5f8fa}.jupyter-wrapper .bp3-file-input.bp3-fill{width:100%}.jupyter-wrapper .bp3-file-input.bp3-large,.jupyter-wrapper .bp3-large .bp3-file-input{height:40px}.jupyter-wrapper .bp3-file-input .bp3-file-upload-input-custom-text::after{content:attr(bp3-button-text)}.jupyter-wrapper .bp3-file-upload-input{outline:none;border:none;border-radius:3px;-webkit-box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2);background:#fff;height:30px;padding:0 10px;vertical-align:middle;line-height:30px;color:#182026;font-size:14px;font-weight:400;-webkit-transition:-webkit-box-shadow 100ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:-webkit-box-shadow 100ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:box-shadow 100ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:box-shadow 100ms cubic-bezier(0.4, 1, 0.75, 0.9),-webkit-box-shadow 100ms cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-appearance:none;-moz-appearance:none;appearance:none;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-wrap:normal;position:absolute;top:0;right:0;left:0;padding-right:80px;color:rgba(92,112,128,.6);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.jupyter-wrapper .bp3-file-upload-input::-webkit-input-placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-file-upload-input::-moz-placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-file-upload-input:-ms-input-placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-file-upload-input::-ms-input-placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-file-upload-input::placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-file-upload-input:focus,.jupyter-wrapper .bp3-file-upload-input.bp3-active{-webkit-box-shadow:0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-file-upload-input[type=search],.jupyter-wrapper .bp3-file-upload-input.bp3-round{border-radius:30px;-webkit-box-sizing:border-box;box-sizing:border-box;padding-left:10px}.jupyter-wrapper .bp3-file-upload-input[readonly]{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.15);box-shadow:inset 0 0 0 1px rgba(16,22,26,.15)}.jupyter-wrapper .bp3-file-upload-input:disabled,.jupyter-wrapper .bp3-file-upload-input.bp3-disabled{-webkit-box-shadow:none;box-shadow:none;background:rgba(206,217,224,.5);cursor:not-allowed;color:rgba(92,112,128,.6);resize:none}.jupyter-wrapper .bp3-file-upload-input::after{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);background-color:#f5f8fa;background-image:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0.8)), to(rgba(255, 255, 255, 0)));background-image:linear-gradient(to bottom, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0));color:#182026;min-width:24px;min-height:24px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-wrap:normal;position:absolute;top:0;right:0;margin:3px;border-radius:3px;width:70px;text-align:center;line-height:24px;content:\"Browse\"}.jupyter-wrapper .bp3-file-upload-input::after:hover{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);background-clip:padding-box;background-color:#ebf1f5}.jupyter-wrapper .bp3-file-upload-input::after:active,.jupyter-wrapper .bp3-file-upload-input::after.bp3-active{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 1px 2px rgba(16,22,26,.2);background-color:#d8e1e8;background-image:none}.jupyter-wrapper .bp3-file-upload-input::after:disabled,.jupyter-wrapper .bp3-file-upload-input::after.bp3-disabled{outline:none;-webkit-box-shadow:none;box-shadow:none;background-color:rgba(206,217,224,.5);background-image:none;cursor:not-allowed;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-file-upload-input::after:disabled.bp3-active,.jupyter-wrapper .bp3-file-upload-input::after:disabled.bp3-active:hover,.jupyter-wrapper .bp3-file-upload-input::after.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-file-upload-input::after.bp3-disabled.bp3-active:hover{background:rgba(206,217,224,.7)}.jupyter-wrapper .bp3-file-upload-input:hover::after{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);background-clip:padding-box;background-color:#ebf1f5}.jupyter-wrapper .bp3-file-upload-input:active::after{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 1px 2px rgba(16,22,26,.2);background-color:#d8e1e8;background-image:none}.jupyter-wrapper .bp3-large .bp3-file-upload-input{height:40px;line-height:40px;font-size:16px;padding-right:95px}.jupyter-wrapper .bp3-large .bp3-file-upload-input[type=search],.jupyter-wrapper .bp3-large .bp3-file-upload-input.bp3-round{padding:0 15px}.jupyter-wrapper .bp3-large .bp3-file-upload-input::after{min-width:30px;min-height:30px;margin:5px;width:85px;line-height:30px}.jupyter-wrapper .bp3-dark .bp3-file-upload-input{-webkit-box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);background:rgba(16,22,26,.3);color:#f5f8fa;color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-file-upload-input::-webkit-input-placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-file-upload-input::-moz-placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-file-upload-input:-ms-input-placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-file-upload-input::-ms-input-placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-file-upload-input::placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-file-upload-input:focus{-webkit-box-shadow:0 0 0 1px #137cbd,0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px #137cbd,0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-file-upload-input[readonly]{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-file-upload-input:disabled,.jupyter-wrapper .bp3-dark .bp3-file-upload-input.bp3-disabled{-webkit-box-shadow:none;box-shadow:none;background:rgba(57,75,89,.5);color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-file-upload-input::after{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.4);background-color:#394b59;background-image:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0.05)), to(rgba(255, 255, 255, 0)));background-image:linear-gradient(to bottom, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0));color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-file-upload-input::after:hover,.jupyter-wrapper .bp3-dark .bp3-file-upload-input::after:active,.jupyter-wrapper .bp3-dark .bp3-file-upload-input::after.bp3-active{color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-file-upload-input::after:hover{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.4);background-color:#30404d}.jupyter-wrapper .bp3-dark .bp3-file-upload-input::after:active,.jupyter-wrapper .bp3-dark .bp3-file-upload-input::after.bp3-active{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.6),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.6),inset 0 1px 2px rgba(16,22,26,.2);background-color:#202b33;background-image:none}.jupyter-wrapper .bp3-dark .bp3-file-upload-input::after:disabled,.jupyter-wrapper .bp3-dark .bp3-file-upload-input::after.bp3-disabled{-webkit-box-shadow:none;box-shadow:none;background-color:rgba(57,75,89,.5);background-image:none;color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-file-upload-input::after:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-file-upload-input::after.bp3-disabled.bp3-active{background:rgba(57,75,89,.7)}.jupyter-wrapper .bp3-dark .bp3-file-upload-input::after .bp3-button-spinner .bp3-spinner-head{background:rgba(16,22,26,.5);stroke:#8a9ba8}.jupyter-wrapper .bp3-dark .bp3-file-upload-input:hover::after{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.4);background-color:#30404d}.jupyter-wrapper .bp3-dark .bp3-file-upload-input:active::after{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.6),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.6),inset 0 1px 2px rgba(16,22,26,.2);background-color:#202b33;background-image:none}.jupyter-wrapper .bp3-file-upload-input::after{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1)}.jupyter-wrapper .bp3-form-group{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;margin:0 0 15px}.jupyter-wrapper .bp3-form-group label.bp3-label{margin-bottom:5px}.jupyter-wrapper .bp3-form-group .bp3-control{margin-top:7px}.jupyter-wrapper .bp3-form-group .bp3-form-helper-text{margin-top:5px;color:#5c7080;font-size:12px}.jupyter-wrapper .bp3-form-group.bp3-intent-primary .bp3-form-helper-text{color:#106ba3}.jupyter-wrapper .bp3-form-group.bp3-intent-success .bp3-form-helper-text{color:#0d8050}.jupyter-wrapper .bp3-form-group.bp3-intent-warning .bp3-form-helper-text{color:#bf7326}.jupyter-wrapper .bp3-form-group.bp3-intent-danger .bp3-form-helper-text{color:#c23030}.jupyter-wrapper .bp3-form-group.bp3-inline{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.jupyter-wrapper .bp3-form-group.bp3-inline.bp3-large label.bp3-label{margin:0 10px 0 0;line-height:40px}.jupyter-wrapper .bp3-form-group.bp3-inline label.bp3-label{margin:0 10px 0 0;line-height:30px}.jupyter-wrapper .bp3-form-group.bp3-disabled .bp3-label,.jupyter-wrapper .bp3-form-group.bp3-disabled .bp3-text-muted,.jupyter-wrapper .bp3-form-group.bp3-disabled .bp3-form-helper-text{color:rgba(92,112,128,.6) !important}.jupyter-wrapper .bp3-dark .bp3-form-group.bp3-intent-primary .bp3-form-helper-text{color:#48aff0}.jupyter-wrapper .bp3-dark .bp3-form-group.bp3-intent-success .bp3-form-helper-text{color:#3dcc91}.jupyter-wrapper .bp3-dark .bp3-form-group.bp3-intent-warning .bp3-form-helper-text{color:#ffb366}.jupyter-wrapper .bp3-dark .bp3-form-group.bp3-intent-danger .bp3-form-helper-text{color:#ff7373}.jupyter-wrapper .bp3-dark .bp3-form-group .bp3-form-helper-text{color:#a7b6c2}.jupyter-wrapper .bp3-dark .bp3-form-group.bp3-disabled .bp3-label,.jupyter-wrapper .bp3-dark .bp3-form-group.bp3-disabled .bp3-text-muted,.jupyter-wrapper .bp3-dark .bp3-form-group.bp3-disabled .bp3-form-helper-text{color:rgba(167,182,194,.6) !important}.jupyter-wrapper .bp3-input-group{display:block;position:relative}.jupyter-wrapper .bp3-input-group .bp3-input{position:relative;width:100%}.jupyter-wrapper .bp3-input-group .bp3-input:not(:first-child){padding-left:30px}.jupyter-wrapper .bp3-input-group .bp3-input:not(:last-child){padding-right:30px}.jupyter-wrapper .bp3-input-group .bp3-input-action,.jupyter-wrapper .bp3-input-group>.bp3-button,.jupyter-wrapper .bp3-input-group>.bp3-icon{position:absolute;top:0}.jupyter-wrapper .bp3-input-group .bp3-input-action:first-child,.jupyter-wrapper .bp3-input-group>.bp3-button:first-child,.jupyter-wrapper .bp3-input-group>.bp3-icon:first-child{left:0}.jupyter-wrapper .bp3-input-group .bp3-input-action:last-child,.jupyter-wrapper .bp3-input-group>.bp3-button:last-child,.jupyter-wrapper .bp3-input-group>.bp3-icon:last-child{right:0}.jupyter-wrapper .bp3-input-group .bp3-button{min-width:24px;min-height:24px;margin:3px;padding:0 7px}.jupyter-wrapper .bp3-input-group .bp3-button:empty{padding:0}.jupyter-wrapper .bp3-input-group>.bp3-icon{z-index:1;color:#5c7080}.jupyter-wrapper .bp3-input-group>.bp3-icon:empty{line-height:1;font-family:\"Icons16\",sans-serif;font-size:16px;font-weight:400;font-style:normal;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}.jupyter-wrapper .bp3-input-group>.bp3-icon,.jupyter-wrapper .bp3-input-group .bp3-input-action>.bp3-spinner{margin:7px}.jupyter-wrapper .bp3-input-group .bp3-tag{margin:5px}.jupyter-wrapper .bp3-input-group .bp3-input:not(:focus)+.bp3-button.bp3-minimal:not(:hover):not(:focus),.jupyter-wrapper .bp3-input-group .bp3-input:not(:focus)+.bp3-input-action .bp3-button.bp3-minimal:not(:hover):not(:focus){color:#5c7080}.jupyter-wrapper .bp3-dark .bp3-input-group .bp3-input:not(:focus)+.bp3-button.bp3-minimal:not(:hover):not(:focus),.jupyter-wrapper .bp3-dark .bp3-input-group .bp3-input:not(:focus)+.bp3-input-action .bp3-button.bp3-minimal:not(:hover):not(:focus){color:#a7b6c2}.jupyter-wrapper .bp3-input-group .bp3-input:not(:focus)+.bp3-button.bp3-minimal:not(:hover):not(:focus) .bp3-icon,.jupyter-wrapper .bp3-input-group .bp3-input:not(:focus)+.bp3-button.bp3-minimal:not(:hover):not(:focus) .bp3-icon-standard,.jupyter-wrapper .bp3-input-group .bp3-input:not(:focus)+.bp3-button.bp3-minimal:not(:hover):not(:focus) .bp3-icon-large,.jupyter-wrapper .bp3-input-group .bp3-input:not(:focus)+.bp3-input-action .bp3-button.bp3-minimal:not(:hover):not(:focus) .bp3-icon,.jupyter-wrapper .bp3-input-group .bp3-input:not(:focus)+.bp3-input-action .bp3-button.bp3-minimal:not(:hover):not(:focus) .bp3-icon-standard,.jupyter-wrapper .bp3-input-group .bp3-input:not(:focus)+.bp3-input-action .bp3-button.bp3-minimal:not(:hover):not(:focus) .bp3-icon-large{color:#5c7080}.jupyter-wrapper .bp3-input-group .bp3-input:not(:focus)+.bp3-button.bp3-minimal:disabled,.jupyter-wrapper .bp3-input-group .bp3-input:not(:focus)+.bp3-input-action .bp3-button.bp3-minimal:disabled{color:rgba(92,112,128,.6) !important}.jupyter-wrapper .bp3-input-group .bp3-input:not(:focus)+.bp3-button.bp3-minimal:disabled .bp3-icon,.jupyter-wrapper .bp3-input-group .bp3-input:not(:focus)+.bp3-button.bp3-minimal:disabled .bp3-icon-standard,.jupyter-wrapper .bp3-input-group .bp3-input:not(:focus)+.bp3-button.bp3-minimal:disabled .bp3-icon-large,.jupyter-wrapper .bp3-input-group .bp3-input:not(:focus)+.bp3-input-action .bp3-button.bp3-minimal:disabled .bp3-icon,.jupyter-wrapper .bp3-input-group .bp3-input:not(:focus)+.bp3-input-action .bp3-button.bp3-minimal:disabled .bp3-icon-standard,.jupyter-wrapper .bp3-input-group .bp3-input:not(:focus)+.bp3-input-action .bp3-button.bp3-minimal:disabled .bp3-icon-large{color:rgba(92,112,128,.6) !important}.jupyter-wrapper .bp3-input-group.bp3-disabled{cursor:not-allowed}.jupyter-wrapper .bp3-input-group.bp3-disabled .bp3-icon{color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-input-group.bp3-large .bp3-button{min-width:30px;min-height:30px;margin:5px}.jupyter-wrapper .bp3-input-group.bp3-large>.bp3-icon,.jupyter-wrapper .bp3-input-group.bp3-large .bp3-input-action>.bp3-spinner{margin:12px}.jupyter-wrapper .bp3-input-group.bp3-large .bp3-input{height:40px;line-height:40px;font-size:16px}.jupyter-wrapper .bp3-input-group.bp3-large .bp3-input[type=search],.jupyter-wrapper .bp3-input-group.bp3-large .bp3-input.bp3-round{padding:0 15px}.jupyter-wrapper .bp3-input-group.bp3-large .bp3-input:not(:first-child){padding-left:40px}.jupyter-wrapper .bp3-input-group.bp3-large .bp3-input:not(:last-child){padding-right:40px}.jupyter-wrapper .bp3-input-group.bp3-small .bp3-button{min-width:20px;min-height:20px;margin:2px}.jupyter-wrapper .bp3-input-group.bp3-small .bp3-tag{min-width:20px;min-height:20px;margin:2px}.jupyter-wrapper .bp3-input-group.bp3-small>.bp3-icon,.jupyter-wrapper .bp3-input-group.bp3-small .bp3-input-action>.bp3-spinner{margin:4px}.jupyter-wrapper .bp3-input-group.bp3-small .bp3-input{height:24px;padding-right:8px;padding-left:8px;line-height:24px;font-size:12px}.jupyter-wrapper .bp3-input-group.bp3-small .bp3-input[type=search],.jupyter-wrapper .bp3-input-group.bp3-small .bp3-input.bp3-round{padding:0 12px}.jupyter-wrapper .bp3-input-group.bp3-small .bp3-input:not(:first-child){padding-left:24px}.jupyter-wrapper .bp3-input-group.bp3-small .bp3-input:not(:last-child){padding-right:24px}.jupyter-wrapper .bp3-input-group.bp3-fill{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;width:100%}.jupyter-wrapper .bp3-input-group.bp3-round .bp3-button,.jupyter-wrapper .bp3-input-group.bp3-round .bp3-input,.jupyter-wrapper .bp3-input-group.bp3-round .bp3-tag{border-radius:30px}.jupyter-wrapper .bp3-dark .bp3-input-group .bp3-icon{color:#a7b6c2}.jupyter-wrapper .bp3-dark .bp3-input-group.bp3-disabled .bp3-icon{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-input-group.bp3-intent-primary .bp3-input{-webkit-box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px #137cbd,inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px #137cbd,inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-input-group.bp3-intent-primary .bp3-input:focus{-webkit-box-shadow:0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-input-group.bp3-intent-primary .bp3-input[readonly]{-webkit-box-shadow:inset 0 0 0 1px #137cbd;box-shadow:inset 0 0 0 1px #137cbd}.jupyter-wrapper .bp3-input-group.bp3-intent-primary .bp3-input:disabled,.jupyter-wrapper .bp3-input-group.bp3-intent-primary .bp3-input.bp3-disabled{-webkit-box-shadow:none;box-shadow:none}.jupyter-wrapper .bp3-input-group.bp3-intent-primary>.bp3-icon{color:#106ba3}.jupyter-wrapper .bp3-dark .bp3-input-group.bp3-intent-primary>.bp3-icon{color:#48aff0}.jupyter-wrapper .bp3-input-group.bp3-intent-success .bp3-input{-webkit-box-shadow:0 0 0 0 rgba(15,153,96,0),0 0 0 0 rgba(15,153,96,0),inset 0 0 0 1px #0f9960,inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 0 rgba(15,153,96,0),0 0 0 0 rgba(15,153,96,0),inset 0 0 0 1px #0f9960,inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-input-group.bp3-intent-success .bp3-input:focus{-webkit-box-shadow:0 0 0 1px #0f9960,0 0 0 3px rgba(15,153,96,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #0f9960,0 0 0 3px rgba(15,153,96,.3),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-input-group.bp3-intent-success .bp3-input[readonly]{-webkit-box-shadow:inset 0 0 0 1px #0f9960;box-shadow:inset 0 0 0 1px #0f9960}.jupyter-wrapper .bp3-input-group.bp3-intent-success .bp3-input:disabled,.jupyter-wrapper .bp3-input-group.bp3-intent-success .bp3-input.bp3-disabled{-webkit-box-shadow:none;box-shadow:none}.jupyter-wrapper .bp3-input-group.bp3-intent-success>.bp3-icon{color:#0d8050}.jupyter-wrapper .bp3-dark .bp3-input-group.bp3-intent-success>.bp3-icon{color:#3dcc91}.jupyter-wrapper .bp3-input-group.bp3-intent-warning .bp3-input{-webkit-box-shadow:0 0 0 0 rgba(217,130,43,0),0 0 0 0 rgba(217,130,43,0),inset 0 0 0 1px #d9822b,inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 0 rgba(217,130,43,0),0 0 0 0 rgba(217,130,43,0),inset 0 0 0 1px #d9822b,inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-input-group.bp3-intent-warning .bp3-input:focus{-webkit-box-shadow:0 0 0 1px #d9822b,0 0 0 3px rgba(217,130,43,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #d9822b,0 0 0 3px rgba(217,130,43,.3),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-input-group.bp3-intent-warning .bp3-input[readonly]{-webkit-box-shadow:inset 0 0 0 1px #d9822b;box-shadow:inset 0 0 0 1px #d9822b}.jupyter-wrapper .bp3-input-group.bp3-intent-warning .bp3-input:disabled,.jupyter-wrapper .bp3-input-group.bp3-intent-warning .bp3-input.bp3-disabled{-webkit-box-shadow:none;box-shadow:none}.jupyter-wrapper .bp3-input-group.bp3-intent-warning>.bp3-icon{color:#bf7326}.jupyter-wrapper .bp3-dark .bp3-input-group.bp3-intent-warning>.bp3-icon{color:#ffb366}.jupyter-wrapper .bp3-input-group.bp3-intent-danger .bp3-input{-webkit-box-shadow:0 0 0 0 rgba(219,55,55,0),0 0 0 0 rgba(219,55,55,0),inset 0 0 0 1px #db3737,inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 0 rgba(219,55,55,0),0 0 0 0 rgba(219,55,55,0),inset 0 0 0 1px #db3737,inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-input-group.bp3-intent-danger .bp3-input:focus{-webkit-box-shadow:0 0 0 1px #db3737,0 0 0 3px rgba(219,55,55,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #db3737,0 0 0 3px rgba(219,55,55,.3),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-input-group.bp3-intent-danger .bp3-input[readonly]{-webkit-box-shadow:inset 0 0 0 1px #db3737;box-shadow:inset 0 0 0 1px #db3737}.jupyter-wrapper .bp3-input-group.bp3-intent-danger .bp3-input:disabled,.jupyter-wrapper .bp3-input-group.bp3-intent-danger .bp3-input.bp3-disabled{-webkit-box-shadow:none;box-shadow:none}.jupyter-wrapper .bp3-input-group.bp3-intent-danger>.bp3-icon{color:#c23030}.jupyter-wrapper .bp3-dark .bp3-input-group.bp3-intent-danger>.bp3-icon{color:#ff7373}.jupyter-wrapper .bp3-input{outline:none;border:none;border-radius:3px;-webkit-box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2);background:#fff;height:30px;padding:0 10px;vertical-align:middle;line-height:30px;color:#182026;font-size:14px;font-weight:400;-webkit-transition:-webkit-box-shadow 100ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:-webkit-box-shadow 100ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:box-shadow 100ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:box-shadow 100ms cubic-bezier(0.4, 1, 0.75, 0.9),-webkit-box-shadow 100ms cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-appearance:none;-moz-appearance:none;appearance:none}.jupyter-wrapper .bp3-input::-webkit-input-placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-input::-moz-placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-input:-ms-input-placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-input::-ms-input-placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-input::placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-input:focus,.jupyter-wrapper .bp3-input.bp3-active{-webkit-box-shadow:0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-input[type=search],.jupyter-wrapper .bp3-input.bp3-round{border-radius:30px;-webkit-box-sizing:border-box;box-sizing:border-box;padding-left:10px}.jupyter-wrapper .bp3-input[readonly]{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.15);box-shadow:inset 0 0 0 1px rgba(16,22,26,.15)}.jupyter-wrapper .bp3-input:disabled,.jupyter-wrapper .bp3-input.bp3-disabled{-webkit-box-shadow:none;box-shadow:none;background:rgba(206,217,224,.5);cursor:not-allowed;color:rgba(92,112,128,.6);resize:none}.jupyter-wrapper .bp3-input.bp3-large{height:40px;line-height:40px;font-size:16px}.jupyter-wrapper .bp3-input.bp3-large[type=search],.jupyter-wrapper .bp3-input.bp3-large.bp3-round{padding:0 15px}.jupyter-wrapper .bp3-input.bp3-small{height:24px;padding-right:8px;padding-left:8px;line-height:24px;font-size:12px}.jupyter-wrapper .bp3-input.bp3-small[type=search],.jupyter-wrapper .bp3-input.bp3-small.bp3-round{padding:0 12px}.jupyter-wrapper .bp3-input.bp3-fill{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;width:100%}.jupyter-wrapper .bp3-dark .bp3-input{-webkit-box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);background:rgba(16,22,26,.3);color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-input::-webkit-input-placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-input::-moz-placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-input:-ms-input-placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-input::-ms-input-placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-input::placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-input:focus{-webkit-box-shadow:0 0 0 1px #137cbd,0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px #137cbd,0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-input[readonly]{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-input:disabled,.jupyter-wrapper .bp3-dark .bp3-input.bp3-disabled{-webkit-box-shadow:none;box-shadow:none;background:rgba(57,75,89,.5);color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-input.bp3-intent-primary{-webkit-box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px #137cbd,inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px #137cbd,inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-input.bp3-intent-primary:focus{-webkit-box-shadow:0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-input.bp3-intent-primary[readonly]{-webkit-box-shadow:inset 0 0 0 1px #137cbd;box-shadow:inset 0 0 0 1px #137cbd}.jupyter-wrapper .bp3-input.bp3-intent-primary:disabled,.jupyter-wrapper .bp3-input.bp3-intent-primary.bp3-disabled{-webkit-box-shadow:none;box-shadow:none}.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-primary{-webkit-box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px #137cbd,inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px #137cbd,inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-primary:focus{-webkit-box-shadow:0 0 0 1px #137cbd,0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px #137cbd,0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-primary[readonly]{-webkit-box-shadow:inset 0 0 0 1px #137cbd;box-shadow:inset 0 0 0 1px #137cbd}.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-primary:disabled,.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-primary.bp3-disabled{-webkit-box-shadow:none;box-shadow:none}.jupyter-wrapper .bp3-input.bp3-intent-success{-webkit-box-shadow:0 0 0 0 rgba(15,153,96,0),0 0 0 0 rgba(15,153,96,0),inset 0 0 0 1px #0f9960,inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 0 rgba(15,153,96,0),0 0 0 0 rgba(15,153,96,0),inset 0 0 0 1px #0f9960,inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-input.bp3-intent-success:focus{-webkit-box-shadow:0 0 0 1px #0f9960,0 0 0 3px rgba(15,153,96,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #0f9960,0 0 0 3px rgba(15,153,96,.3),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-input.bp3-intent-success[readonly]{-webkit-box-shadow:inset 0 0 0 1px #0f9960;box-shadow:inset 0 0 0 1px #0f9960}.jupyter-wrapper .bp3-input.bp3-intent-success:disabled,.jupyter-wrapper .bp3-input.bp3-intent-success.bp3-disabled{-webkit-box-shadow:none;box-shadow:none}.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-success{-webkit-box-shadow:0 0 0 0 rgba(15,153,96,0),0 0 0 0 rgba(15,153,96,0),0 0 0 0 rgba(15,153,96,0),inset 0 0 0 1px #0f9960,inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 0 rgba(15,153,96,0),0 0 0 0 rgba(15,153,96,0),0 0 0 0 rgba(15,153,96,0),inset 0 0 0 1px #0f9960,inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-success:focus{-webkit-box-shadow:0 0 0 1px #0f9960,0 0 0 1px #0f9960,0 0 0 3px rgba(15,153,96,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px #0f9960,0 0 0 1px #0f9960,0 0 0 3px rgba(15,153,96,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-success[readonly]{-webkit-box-shadow:inset 0 0 0 1px #0f9960;box-shadow:inset 0 0 0 1px #0f9960}.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-success:disabled,.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-success.bp3-disabled{-webkit-box-shadow:none;box-shadow:none}.jupyter-wrapper .bp3-input.bp3-intent-warning{-webkit-box-shadow:0 0 0 0 rgba(217,130,43,0),0 0 0 0 rgba(217,130,43,0),inset 0 0 0 1px #d9822b,inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 0 rgba(217,130,43,0),0 0 0 0 rgba(217,130,43,0),inset 0 0 0 1px #d9822b,inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-input.bp3-intent-warning:focus{-webkit-box-shadow:0 0 0 1px #d9822b,0 0 0 3px rgba(217,130,43,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #d9822b,0 0 0 3px rgba(217,130,43,.3),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-input.bp3-intent-warning[readonly]{-webkit-box-shadow:inset 0 0 0 1px #d9822b;box-shadow:inset 0 0 0 1px #d9822b}.jupyter-wrapper .bp3-input.bp3-intent-warning:disabled,.jupyter-wrapper .bp3-input.bp3-intent-warning.bp3-disabled{-webkit-box-shadow:none;box-shadow:none}.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-warning{-webkit-box-shadow:0 0 0 0 rgba(217,130,43,0),0 0 0 0 rgba(217,130,43,0),0 0 0 0 rgba(217,130,43,0),inset 0 0 0 1px #d9822b,inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 0 rgba(217,130,43,0),0 0 0 0 rgba(217,130,43,0),0 0 0 0 rgba(217,130,43,0),inset 0 0 0 1px #d9822b,inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-warning:focus{-webkit-box-shadow:0 0 0 1px #d9822b,0 0 0 1px #d9822b,0 0 0 3px rgba(217,130,43,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px #d9822b,0 0 0 1px #d9822b,0 0 0 3px rgba(217,130,43,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-warning[readonly]{-webkit-box-shadow:inset 0 0 0 1px #d9822b;box-shadow:inset 0 0 0 1px #d9822b}.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-warning:disabled,.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-warning.bp3-disabled{-webkit-box-shadow:none;box-shadow:none}.jupyter-wrapper .bp3-input.bp3-intent-danger{-webkit-box-shadow:0 0 0 0 rgba(219,55,55,0),0 0 0 0 rgba(219,55,55,0),inset 0 0 0 1px #db3737,inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 0 rgba(219,55,55,0),0 0 0 0 rgba(219,55,55,0),inset 0 0 0 1px #db3737,inset 0 0 0 1px rgba(16,22,26,.15),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-input.bp3-intent-danger:focus{-webkit-box-shadow:0 0 0 1px #db3737,0 0 0 3px rgba(219,55,55,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #db3737,0 0 0 3px rgba(219,55,55,.3),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-input.bp3-intent-danger[readonly]{-webkit-box-shadow:inset 0 0 0 1px #db3737;box-shadow:inset 0 0 0 1px #db3737}.jupyter-wrapper .bp3-input.bp3-intent-danger:disabled,.jupyter-wrapper .bp3-input.bp3-intent-danger.bp3-disabled{-webkit-box-shadow:none;box-shadow:none}.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-danger{-webkit-box-shadow:0 0 0 0 rgba(219,55,55,0),0 0 0 0 rgba(219,55,55,0),0 0 0 0 rgba(219,55,55,0),inset 0 0 0 1px #db3737,inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 0 rgba(219,55,55,0),0 0 0 0 rgba(219,55,55,0),0 0 0 0 rgba(219,55,55,0),inset 0 0 0 1px #db3737,inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-danger:focus{-webkit-box-shadow:0 0 0 1px #db3737,0 0 0 1px #db3737,0 0 0 3px rgba(219,55,55,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px #db3737,0 0 0 1px #db3737,0 0 0 3px rgba(219,55,55,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-danger[readonly]{-webkit-box-shadow:inset 0 0 0 1px #db3737;box-shadow:inset 0 0 0 1px #db3737}.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-danger:disabled,.jupyter-wrapper .bp3-dark .bp3-input.bp3-intent-danger.bp3-disabled{-webkit-box-shadow:none;box-shadow:none}.jupyter-wrapper .bp3-input::-ms-clear{display:none}.jupyter-wrapper textarea.bp3-input{max-width:100%;padding:10px}.jupyter-wrapper textarea.bp3-input,.jupyter-wrapper textarea.bp3-input.bp3-large,.jupyter-wrapper textarea.bp3-input.bp3-small{height:auto;line-height:inherit}.jupyter-wrapper textarea.bp3-input.bp3-small{padding:8px}.jupyter-wrapper .bp3-dark textarea.bp3-input{-webkit-box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),0 0 0 0 rgba(19,124,189,0),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);background:rgba(16,22,26,.3);color:#f5f8fa}.jupyter-wrapper .bp3-dark textarea.bp3-input::-webkit-input-placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark textarea.bp3-input::-moz-placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark textarea.bp3-input:-ms-input-placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark textarea.bp3-input::-ms-input-placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark textarea.bp3-input::placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark textarea.bp3-input:focus{-webkit-box-shadow:0 0 0 1px #137cbd,0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px #137cbd,0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark textarea.bp3-input[readonly]{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.4);box-shadow:inset 0 0 0 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark textarea.bp3-input:disabled,.jupyter-wrapper .bp3-dark textarea.bp3-input.bp3-disabled{-webkit-box-shadow:none;box-shadow:none;background:rgba(57,75,89,.5);color:rgba(167,182,194,.6)}.jupyter-wrapper label.bp3-label{display:block;margin-top:0;margin-bottom:15px}.jupyter-wrapper label.bp3-label .bp3-html-select,.jupyter-wrapper label.bp3-label .bp3-input,.jupyter-wrapper label.bp3-label .bp3-select,.jupyter-wrapper label.bp3-label .bp3-slider,.jupyter-wrapper label.bp3-label .bp3-popover-wrapper{display:block;margin-top:5px;text-transform:none}.jupyter-wrapper label.bp3-label .bp3-button-group{margin-top:5px}.jupyter-wrapper label.bp3-label .bp3-select select,.jupyter-wrapper label.bp3-label .bp3-html-select select{width:100%;vertical-align:top;font-weight:400}.jupyter-wrapper label.bp3-label.bp3-disabled,.jupyter-wrapper label.bp3-label.bp3-disabled .bp3-text-muted{color:rgba(92,112,128,.6)}.jupyter-wrapper label.bp3-label.bp3-inline{line-height:30px}.jupyter-wrapper label.bp3-label.bp3-inline .bp3-html-select,.jupyter-wrapper label.bp3-label.bp3-inline .bp3-input,.jupyter-wrapper label.bp3-label.bp3-inline .bp3-input-group,.jupyter-wrapper label.bp3-label.bp3-inline .bp3-select,.jupyter-wrapper label.bp3-label.bp3-inline .bp3-popover-wrapper{display:inline-block;margin:0 0 0 5px;vertical-align:top}.jupyter-wrapper label.bp3-label.bp3-inline .bp3-button-group{margin:0 0 0 5px}.jupyter-wrapper label.bp3-label.bp3-inline .bp3-input-group .bp3-input{margin-left:0}.jupyter-wrapper label.bp3-label.bp3-inline.bp3-large{line-height:40px}.jupyter-wrapper label.bp3-label:not(.bp3-inline) .bp3-popover-target{display:block}.jupyter-wrapper .bp3-dark label.bp3-label{color:#f5f8fa}.jupyter-wrapper .bp3-dark label.bp3-label.bp3-disabled,.jupyter-wrapper .bp3-dark label.bp3-label.bp3-disabled .bp3-text-muted{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-numeric-input .bp3-button-group.bp3-vertical>.bp3-button{-webkit-box-flex:1;-ms-flex:1 1 14px;flex:1 1 14px;width:30px;min-height:0;padding:0}.jupyter-wrapper .bp3-numeric-input .bp3-button-group.bp3-vertical>.bp3-button:first-child{border-radius:0 3px 0 0}.jupyter-wrapper .bp3-numeric-input .bp3-button-group.bp3-vertical>.bp3-button:last-child{border-radius:0 0 3px 0}.jupyter-wrapper .bp3-numeric-input .bp3-button-group.bp3-vertical:first-child>.bp3-button:first-child{border-radius:3px 0 0 0}.jupyter-wrapper .bp3-numeric-input .bp3-button-group.bp3-vertical:first-child>.bp3-button:last-child{border-radius:0 0 0 3px}.jupyter-wrapper .bp3-numeric-input.bp3-large .bp3-button-group.bp3-vertical>.bp3-button{width:40px}.jupyter-wrapper form{display:block}.jupyter-wrapper .bp3-html-select select,.jupyter-wrapper .bp3-select select{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;border:none;border-radius:3px;cursor:pointer;padding:5px 10px;vertical-align:middle;text-align:left;font-size:14px;-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);background-color:#f5f8fa;background-image:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0.8)), to(rgba(255, 255, 255, 0)));background-image:linear-gradient(to bottom, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0));color:#182026;border-radius:3px;width:100%;height:30px;padding:0 25px 0 10px;-moz-appearance:none;-webkit-appearance:none}.jupyter-wrapper .bp3-html-select select>*,.jupyter-wrapper .bp3-select select>*{-webkit-box-flex:0;-ms-flex-positive:0;flex-grow:0;-ms-flex-negative:0;flex-shrink:0}.jupyter-wrapper .bp3-html-select select>.bp3-fill,.jupyter-wrapper .bp3-select select>.bp3-fill{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-negative:1;flex-shrink:1}.jupyter-wrapper .bp3-html-select select::before,.jupyter-wrapper .bp3-select select::before,.jupyter-wrapper .bp3-html-select select>*,.jupyter-wrapper .bp3-select select>*{margin-right:7px}.jupyter-wrapper .bp3-html-select select:empty::before,.jupyter-wrapper .bp3-select select:empty::before,.jupyter-wrapper .bp3-html-select select>:last-child,.jupyter-wrapper .bp3-select select>:last-child{margin-right:0}.jupyter-wrapper .bp3-html-select select:hover,.jupyter-wrapper .bp3-select select:hover{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);background-clip:padding-box;background-color:#ebf1f5}.jupyter-wrapper .bp3-html-select select:active,.jupyter-wrapper .bp3-select select:active,.jupyter-wrapper .bp3-html-select select.bp3-active,.jupyter-wrapper .bp3-select select.bp3-active{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 1px 2px rgba(16,22,26,.2);background-color:#d8e1e8;background-image:none}.jupyter-wrapper .bp3-html-select select:disabled,.jupyter-wrapper .bp3-select select:disabled,.jupyter-wrapper .bp3-html-select select.bp3-disabled,.jupyter-wrapper .bp3-select select.bp3-disabled{outline:none;-webkit-box-shadow:none;box-shadow:none;background-color:rgba(206,217,224,.5);background-image:none;cursor:not-allowed;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-html-select select:disabled.bp3-active,.jupyter-wrapper .bp3-select select:disabled.bp3-active,.jupyter-wrapper .bp3-html-select select:disabled.bp3-active:hover,.jupyter-wrapper .bp3-select select:disabled.bp3-active:hover,.jupyter-wrapper .bp3-html-select select.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-select select.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-html-select select.bp3-disabled.bp3-active:hover,.jupyter-wrapper .bp3-select select.bp3-disabled.bp3-active:hover{background:rgba(206,217,224,.7)}.jupyter-wrapper .bp3-html-select.bp3-minimal select,.jupyter-wrapper .bp3-select.bp3-minimal select{-webkit-box-shadow:none;box-shadow:none;background:none}.jupyter-wrapper .bp3-html-select.bp3-minimal select:hover,.jupyter-wrapper .bp3-select.bp3-minimal select:hover{-webkit-box-shadow:none;box-shadow:none;background:rgba(167,182,194,.3);text-decoration:none;color:#182026}.jupyter-wrapper .bp3-html-select.bp3-minimal select:active,.jupyter-wrapper .bp3-select.bp3-minimal select:active,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-active{-webkit-box-shadow:none;box-shadow:none;background:rgba(115,134,148,.3);color:#182026}.jupyter-wrapper .bp3-html-select.bp3-minimal select:disabled,.jupyter-wrapper .bp3-select.bp3-minimal select:disabled,.jupyter-wrapper .bp3-html-select.bp3-minimal select:disabled:hover,.jupyter-wrapper .bp3-select.bp3-minimal select:disabled:hover,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-disabled,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-disabled,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-disabled:hover,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-disabled:hover{background:none;cursor:not-allowed;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-html-select.bp3-minimal select:disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select:disabled.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal select:disabled:hover.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select:disabled:hover.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-disabled:hover.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-disabled:hover.bp3-active{background:rgba(115,134,148,.3)}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select{-webkit-box-shadow:none;box-shadow:none;background:none;color:inherit}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select:hover,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select:hover,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select:hover,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select:hover,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select:active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select:active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select:active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select:active,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-active{-webkit-box-shadow:none;box-shadow:none;background:none}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select:hover,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select:hover,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select:hover,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select:hover{background:rgba(138,155,168,.15)}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select:active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select:active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select:active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select:active,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-active{background:rgba(138,155,168,.3);color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select:disabled,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select:disabled,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select:disabled,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select:disabled,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select:disabled:hover,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select:disabled:hover,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select:disabled:hover,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select:disabled:hover,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-disabled,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-disabled,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-disabled,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-disabled,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-disabled:hover,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-disabled:hover,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-disabled:hover,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-disabled:hover{background:none;cursor:not-allowed;color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select:disabled.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select:disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select:disabled:hover.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select:disabled:hover.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select:disabled:hover.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select:disabled:hover.bp3-active,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-disabled:hover.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-disabled:hover.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-disabled:hover.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-disabled:hover.bp3-active{background:rgba(138,155,168,.3)}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-primary,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-primary{color:#106ba3}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-primary:hover,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-primary:hover,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-primary:active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-primary:active,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-primary.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-primary.bp3-active{-webkit-box-shadow:none;box-shadow:none;background:none;color:#106ba3}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-primary:hover,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-primary:hover{background:rgba(19,124,189,.15);color:#106ba3}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-primary:active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-primary:active,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-primary.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-primary.bp3-active{background:rgba(19,124,189,.3);color:#106ba3}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-primary:disabled,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-primary:disabled,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-primary.bp3-disabled,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-primary.bp3-disabled{background:none;color:rgba(16,107,163,.5)}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-primary:disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-primary:disabled.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-primary.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-primary.bp3-disabled.bp3-active{background:rgba(19,124,189,.3)}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-primary .bp3-button-spinner .bp3-spinner-head,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-primary .bp3-button-spinner .bp3-spinner-head{stroke:#106ba3}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-primary,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-primary,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-primary,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-primary{color:#48aff0}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-primary:hover,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-primary:hover,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-primary:hover,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-primary:hover{background:rgba(19,124,189,.2);color:#48aff0}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-primary:active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-primary:active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-primary:active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-primary:active,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-primary.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-primary.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-primary.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-primary.bp3-active{background:rgba(19,124,189,.3);color:#48aff0}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-primary:disabled,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-primary:disabled,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-primary:disabled,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-primary:disabled,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-primary.bp3-disabled,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-primary.bp3-disabled,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-primary.bp3-disabled,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-primary.bp3-disabled{background:none;color:rgba(72,175,240,.5)}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-primary:disabled.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-primary:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-primary:disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-primary:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-primary.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-primary.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-primary.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-primary.bp3-disabled.bp3-active{background:rgba(19,124,189,.3)}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-success,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-success{color:#0d8050}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-success:hover,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-success:hover,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-success:active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-success:active,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-success.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-success.bp3-active{-webkit-box-shadow:none;box-shadow:none;background:none;color:#0d8050}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-success:hover,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-success:hover{background:rgba(15,153,96,.15);color:#0d8050}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-success:active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-success:active,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-success.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-success.bp3-active{background:rgba(15,153,96,.3);color:#0d8050}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-success:disabled,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-success:disabled,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-success.bp3-disabled,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-success.bp3-disabled{background:none;color:rgba(13,128,80,.5)}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-success:disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-success:disabled.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-success.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-success.bp3-disabled.bp3-active{background:rgba(15,153,96,.3)}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-success .bp3-button-spinner .bp3-spinner-head,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-success .bp3-button-spinner .bp3-spinner-head{stroke:#0d8050}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-success,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-success,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-success,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-success{color:#3dcc91}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-success:hover,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-success:hover,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-success:hover,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-success:hover{background:rgba(15,153,96,.2);color:#3dcc91}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-success:active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-success:active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-success:active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-success:active,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-success.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-success.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-success.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-success.bp3-active{background:rgba(15,153,96,.3);color:#3dcc91}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-success:disabled,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-success:disabled,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-success:disabled,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-success:disabled,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-success.bp3-disabled,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-success.bp3-disabled,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-success.bp3-disabled,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-success.bp3-disabled{background:none;color:rgba(61,204,145,.5)}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-success:disabled.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-success:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-success:disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-success:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-success.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-success.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-success.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-success.bp3-disabled.bp3-active{background:rgba(15,153,96,.3)}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-warning,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-warning{color:#bf7326}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-warning:hover,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-warning:hover,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-warning:active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-warning:active,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-warning.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-warning.bp3-active{-webkit-box-shadow:none;box-shadow:none;background:none;color:#bf7326}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-warning:hover,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-warning:hover{background:rgba(217,130,43,.15);color:#bf7326}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-warning:active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-warning:active,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-warning.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-warning.bp3-active{background:rgba(217,130,43,.3);color:#bf7326}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-warning:disabled,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-warning:disabled,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-warning.bp3-disabled,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-warning.bp3-disabled{background:none;color:rgba(191,115,38,.5)}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-warning:disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-warning:disabled.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-warning.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-warning.bp3-disabled.bp3-active{background:rgba(217,130,43,.3)}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-warning .bp3-button-spinner .bp3-spinner-head,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-warning .bp3-button-spinner .bp3-spinner-head{stroke:#bf7326}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-warning,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-warning,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-warning,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-warning{color:#ffb366}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-warning:hover,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-warning:hover,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-warning:hover,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-warning:hover{background:rgba(217,130,43,.2);color:#ffb366}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-warning:active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-warning:active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-warning:active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-warning:active,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-warning.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-warning.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-warning.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-warning.bp3-active{background:rgba(217,130,43,.3);color:#ffb366}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-warning:disabled,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-warning:disabled,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-warning:disabled,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-warning:disabled,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-warning.bp3-disabled,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-warning.bp3-disabled,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-warning.bp3-disabled,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-warning.bp3-disabled{background:none;color:rgba(255,179,102,.5)}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-warning:disabled.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-warning:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-warning:disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-warning:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-warning.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-warning.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-warning.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-warning.bp3-disabled.bp3-active{background:rgba(217,130,43,.3)}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-danger,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-danger{color:#c23030}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-danger:hover,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-danger:hover,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-danger:active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-danger:active,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-danger.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-danger.bp3-active{-webkit-box-shadow:none;box-shadow:none;background:none;color:#c23030}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-danger:hover,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-danger:hover{background:rgba(219,55,55,.15);color:#c23030}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-danger:active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-danger:active,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-danger.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-danger.bp3-active{background:rgba(219,55,55,.3);color:#c23030}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-danger:disabled,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-danger:disabled,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-danger.bp3-disabled,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-danger.bp3-disabled{background:none;color:rgba(194,48,48,.5)}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-danger:disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-danger:disabled.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-danger.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-danger.bp3-disabled.bp3-active{background:rgba(219,55,55,.3)}.jupyter-wrapper .bp3-html-select.bp3-minimal select.bp3-intent-danger .bp3-button-spinner .bp3-spinner-head,.jupyter-wrapper .bp3-select.bp3-minimal select.bp3-intent-danger .bp3-button-spinner .bp3-spinner-head{stroke:#c23030}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-danger,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-danger,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-danger,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-danger{color:#ff7373}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-danger:hover,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-danger:hover,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-danger:hover,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-danger:hover{background:rgba(219,55,55,.2);color:#ff7373}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-danger:active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-danger:active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-danger:active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-danger:active,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-danger.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-danger.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-danger.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-danger.bp3-active{background:rgba(219,55,55,.3);color:#ff7373}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-danger:disabled,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-danger:disabled,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-danger:disabled,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-danger:disabled,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-danger.bp3-disabled,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-danger.bp3-disabled,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-danger.bp3-disabled,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-danger.bp3-disabled{background:none;color:rgba(255,115,115,.5)}.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-danger:disabled.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-danger:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-danger:disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-danger:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-html-select.bp3-minimal select.bp3-intent-danger.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-html-select.bp3-minimal .bp3-dark select.bp3-intent-danger.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select.bp3-minimal select.bp3-intent-danger.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-select.bp3-minimal .bp3-dark select.bp3-intent-danger.bp3-disabled.bp3-active{background:rgba(219,55,55,.3)}.jupyter-wrapper .bp3-html-select.bp3-large select,.jupyter-wrapper .bp3-select.bp3-large select{height:40px;padding-right:35px;font-size:16px}.jupyter-wrapper .bp3-dark .bp3-html-select select,.jupyter-wrapper .bp3-dark .bp3-select select{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.4);background-color:#394b59;background-image:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0.05)), to(rgba(255, 255, 255, 0)));background-image:linear-gradient(to bottom, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0));color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-html-select select:hover,.jupyter-wrapper .bp3-dark .bp3-select select:hover,.jupyter-wrapper .bp3-dark .bp3-html-select select:active,.jupyter-wrapper .bp3-dark .bp3-select select:active,.jupyter-wrapper .bp3-dark .bp3-html-select select.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select select.bp3-active{color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-html-select select:hover,.jupyter-wrapper .bp3-dark .bp3-select select:hover{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.4);background-color:#30404d}.jupyter-wrapper .bp3-dark .bp3-html-select select:active,.jupyter-wrapper .bp3-dark .bp3-select select:active,.jupyter-wrapper .bp3-dark .bp3-html-select select.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select select.bp3-active{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.6),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.6),inset 0 1px 2px rgba(16,22,26,.2);background-color:#202b33;background-image:none}.jupyter-wrapper .bp3-dark .bp3-html-select select:disabled,.jupyter-wrapper .bp3-dark .bp3-select select:disabled,.jupyter-wrapper .bp3-dark .bp3-html-select select.bp3-disabled,.jupyter-wrapper .bp3-dark .bp3-select select.bp3-disabled{-webkit-box-shadow:none;box-shadow:none;background-color:rgba(57,75,89,.5);background-image:none;color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-html-select select:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select select:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-html-select select.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-select select.bp3-disabled.bp3-active{background:rgba(57,75,89,.7)}.jupyter-wrapper .bp3-dark .bp3-html-select select .bp3-button-spinner .bp3-spinner-head,.jupyter-wrapper .bp3-dark .bp3-select select .bp3-button-spinner .bp3-spinner-head{background:rgba(16,22,26,.5);stroke:#8a9ba8}.jupyter-wrapper .bp3-html-select select:disabled,.jupyter-wrapper .bp3-select select:disabled{-webkit-box-shadow:none;box-shadow:none;background-color:rgba(206,217,224,.5);cursor:not-allowed;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-html-select .bp3-icon,.jupyter-wrapper .bp3-select .bp3-icon,.jupyter-wrapper .bp3-select::after{position:absolute;top:7px;right:7px;color:#5c7080;pointer-events:none}.jupyter-wrapper .bp3-html-select .bp3-disabled.bp3-icon,.jupyter-wrapper .bp3-select .bp3-disabled.bp3-icon,.jupyter-wrapper .bp3-disabled.bp3-select::after{color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-html-select,.jupyter-wrapper .bp3-select{display:inline-block;position:relative;vertical-align:middle;letter-spacing:normal}.jupyter-wrapper .bp3-html-select select::-ms-expand,.jupyter-wrapper .bp3-select select::-ms-expand{display:none}.jupyter-wrapper .bp3-html-select .bp3-icon,.jupyter-wrapper .bp3-select .bp3-icon{color:#5c7080}.jupyter-wrapper .bp3-html-select .bp3-icon:hover,.jupyter-wrapper .bp3-select .bp3-icon:hover{color:#182026}.jupyter-wrapper .bp3-dark .bp3-html-select .bp3-icon,.jupyter-wrapper .bp3-dark .bp3-select .bp3-icon{color:#a7b6c2}.jupyter-wrapper .bp3-dark .bp3-html-select .bp3-icon:hover,.jupyter-wrapper .bp3-dark .bp3-select .bp3-icon:hover{color:#f5f8fa}.jupyter-wrapper .bp3-html-select.bp3-large::after,.jupyter-wrapper .bp3-html-select.bp3-large .bp3-icon,.jupyter-wrapper .bp3-select.bp3-large::after,.jupyter-wrapper .bp3-select.bp3-large .bp3-icon{top:12px;right:12px}.jupyter-wrapper .bp3-html-select.bp3-fill,.jupyter-wrapper .bp3-html-select.bp3-fill select,.jupyter-wrapper .bp3-select.bp3-fill,.jupyter-wrapper .bp3-select.bp3-fill select{width:100%}.jupyter-wrapper .bp3-dark .bp3-html-select option,.jupyter-wrapper .bp3-dark .bp3-select option{background-color:#30404d;color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-html-select::after,.jupyter-wrapper .bp3-dark .bp3-select::after{color:#a7b6c2}.jupyter-wrapper .bp3-select::after{line-height:1;font-family:\"Icons16\",sans-serif;font-size:16px;font-weight:400;font-style:normal;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;content:\"\ue6c6\"}.jupyter-wrapper .bp3-running-text table,.jupyter-wrapper table.bp3-html-table{border-spacing:0;font-size:14px}.jupyter-wrapper .bp3-running-text table th,.jupyter-wrapper table.bp3-html-table th,.jupyter-wrapper .bp3-running-text table td,.jupyter-wrapper table.bp3-html-table td{padding:11px;vertical-align:top;text-align:left}.jupyter-wrapper .bp3-running-text table th,.jupyter-wrapper table.bp3-html-table th{color:#182026;font-weight:600}.jupyter-wrapper .bp3-running-text table td,.jupyter-wrapper table.bp3-html-table td{color:#182026}.jupyter-wrapper .bp3-running-text table tbody tr:first-child th,.jupyter-wrapper table.bp3-html-table tbody tr:first-child th,.jupyter-wrapper .bp3-running-text table tbody tr:first-child td,.jupyter-wrapper table.bp3-html-table tbody tr:first-child td{-webkit-box-shadow:inset 0 1px 0 0 rgba(16,22,26,.15);box-shadow:inset 0 1px 0 0 rgba(16,22,26,.15)}.jupyter-wrapper .bp3-dark .bp3-running-text table th,.jupyter-wrapper .bp3-running-text .bp3-dark table th,.jupyter-wrapper .bp3-dark table.bp3-html-table th{color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-running-text table td,.jupyter-wrapper .bp3-running-text .bp3-dark table td,.jupyter-wrapper .bp3-dark table.bp3-html-table td{color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-running-text table tbody tr:first-child th,.jupyter-wrapper .bp3-running-text .bp3-dark table tbody tr:first-child th,.jupyter-wrapper .bp3-dark table.bp3-html-table tbody tr:first-child th,.jupyter-wrapper .bp3-dark .bp3-running-text table tbody tr:first-child td,.jupyter-wrapper .bp3-running-text .bp3-dark table tbody tr:first-child td,.jupyter-wrapper .bp3-dark table.bp3-html-table tbody tr:first-child td{-webkit-box-shadow:inset 0 1px 0 0 rgba(255,255,255,.15);box-shadow:inset 0 1px 0 0 rgba(255,255,255,.15)}.jupyter-wrapper table.bp3-html-table.bp3-html-table-condensed th,.jupyter-wrapper table.bp3-html-table.bp3-html-table-condensed td,.jupyter-wrapper table.bp3-html-table.bp3-small th,.jupyter-wrapper table.bp3-html-table.bp3-small td{padding-top:6px;padding-bottom:6px}.jupyter-wrapper table.bp3-html-table.bp3-html-table-striped tbody tr:nth-child(odd) td{background:rgba(191,204,214,.15)}.jupyter-wrapper table.bp3-html-table.bp3-html-table-bordered th:not(:first-child){-webkit-box-shadow:inset 1px 0 0 0 rgba(16,22,26,.15);box-shadow:inset 1px 0 0 0 rgba(16,22,26,.15)}.jupyter-wrapper table.bp3-html-table.bp3-html-table-bordered tbody tr td{-webkit-box-shadow:inset 0 1px 0 0 rgba(16,22,26,.15);box-shadow:inset 0 1px 0 0 rgba(16,22,26,.15)}.jupyter-wrapper table.bp3-html-table.bp3-html-table-bordered tbody tr td:not(:first-child){-webkit-box-shadow:inset 1px 1px 0 0 rgba(16,22,26,.15);box-shadow:inset 1px 1px 0 0 rgba(16,22,26,.15)}.jupyter-wrapper table.bp3-html-table.bp3-html-table-bordered.bp3-html-table-striped tbody tr:not(:first-child) td{-webkit-box-shadow:none;box-shadow:none}.jupyter-wrapper table.bp3-html-table.bp3-html-table-bordered.bp3-html-table-striped tbody tr:not(:first-child) td:not(:first-child){-webkit-box-shadow:inset 1px 0 0 0 rgba(16,22,26,.15);box-shadow:inset 1px 0 0 0 rgba(16,22,26,.15)}.jupyter-wrapper table.bp3-html-table.bp3-interactive tbody tr:hover td{background-color:rgba(191,204,214,.3);cursor:pointer}.jupyter-wrapper table.bp3-html-table.bp3-interactive tbody tr:active td{background-color:rgba(191,204,214,.4)}.jupyter-wrapper .bp3-dark table.bp3-html-table.bp3-html-table-striped tbody tr:nth-child(odd) td{background:rgba(92,112,128,.15)}.jupyter-wrapper .bp3-dark table.bp3-html-table.bp3-html-table-bordered th:not(:first-child){-webkit-box-shadow:inset 1px 0 0 0 rgba(255,255,255,.15);box-shadow:inset 1px 0 0 0 rgba(255,255,255,.15)}.jupyter-wrapper .bp3-dark table.bp3-html-table.bp3-html-table-bordered tbody tr td{-webkit-box-shadow:inset 0 1px 0 0 rgba(255,255,255,.15);box-shadow:inset 0 1px 0 0 rgba(255,255,255,.15)}.jupyter-wrapper .bp3-dark table.bp3-html-table.bp3-html-table-bordered tbody tr td:not(:first-child){-webkit-box-shadow:inset 1px 1px 0 0 rgba(255,255,255,.15);box-shadow:inset 1px 1px 0 0 rgba(255,255,255,.15)}.jupyter-wrapper .bp3-dark table.bp3-html-table.bp3-html-table-bordered.bp3-html-table-striped tbody tr:not(:first-child) td{-webkit-box-shadow:inset 1px 0 0 0 rgba(255,255,255,.15);box-shadow:inset 1px 0 0 0 rgba(255,255,255,.15)}.jupyter-wrapper .bp3-dark table.bp3-html-table.bp3-html-table-bordered.bp3-html-table-striped tbody tr:not(:first-child) td:first-child{-webkit-box-shadow:none;box-shadow:none}.jupyter-wrapper .bp3-dark table.bp3-html-table.bp3-interactive tbody tr:hover td{background-color:rgba(92,112,128,.3);cursor:pointer}.jupyter-wrapper .bp3-dark table.bp3-html-table.bp3-interactive tbody tr:active td{background-color:rgba(92,112,128,.4)}.jupyter-wrapper .bp3-key-combo{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.jupyter-wrapper .bp3-key-combo>*{-webkit-box-flex:0;-ms-flex-positive:0;flex-grow:0;-ms-flex-negative:0;flex-shrink:0}.jupyter-wrapper .bp3-key-combo>.bp3-fill{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-negative:1;flex-shrink:1}.jupyter-wrapper .bp3-key-combo::before,.jupyter-wrapper .bp3-key-combo>*{margin-right:5px}.jupyter-wrapper .bp3-key-combo:empty::before,.jupyter-wrapper .bp3-key-combo>:last-child{margin-right:0}.jupyter-wrapper .bp3-hotkey-dialog{top:40px;padding-bottom:0}.jupyter-wrapper .bp3-hotkey-dialog .bp3-dialog-body{margin:0;padding:0}.jupyter-wrapper .bp3-hotkey-dialog .bp3-hotkey-label{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1}.jupyter-wrapper .bp3-hotkey-column{margin:auto;max-height:80vh;overflow-y:auto;padding:30px}.jupyter-wrapper .bp3-hotkey-column .bp3-heading{margin-bottom:20px}.jupyter-wrapper .bp3-hotkey-column .bp3-heading:not(:first-child){margin-top:40px}.jupyter-wrapper .bp3-hotkey{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;margin-right:0;margin-left:0}.jupyter-wrapper .bp3-hotkey:not(:last-child){margin-bottom:10px}.jupyter-wrapper .bp3-icon{display:inline-block;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:0 0 auto;vertical-align:text-bottom}.jupyter-wrapper .bp3-icon:not(:empty)::before{content:\"\" !important;content:unset !important}.jupyter-wrapper .bp3-icon>svg{display:block}.jupyter-wrapper .bp3-icon>svg:not([fill]){fill:currentColor}.jupyter-wrapper .bp3-icon.bp3-intent-primary,.jupyter-wrapper .bp3-icon-standard.bp3-intent-primary,.jupyter-wrapper .bp3-icon-large.bp3-intent-primary{color:#106ba3}.jupyter-wrapper .bp3-dark .bp3-icon.bp3-intent-primary,.jupyter-wrapper .bp3-dark .bp3-icon-standard.bp3-intent-primary,.jupyter-wrapper .bp3-dark .bp3-icon-large.bp3-intent-primary{color:#48aff0}.jupyter-wrapper .bp3-icon.bp3-intent-success,.jupyter-wrapper .bp3-icon-standard.bp3-intent-success,.jupyter-wrapper .bp3-icon-large.bp3-intent-success{color:#0d8050}.jupyter-wrapper .bp3-dark .bp3-icon.bp3-intent-success,.jupyter-wrapper .bp3-dark .bp3-icon-standard.bp3-intent-success,.jupyter-wrapper .bp3-dark .bp3-icon-large.bp3-intent-success{color:#3dcc91}.jupyter-wrapper .bp3-icon.bp3-intent-warning,.jupyter-wrapper .bp3-icon-standard.bp3-intent-warning,.jupyter-wrapper .bp3-icon-large.bp3-intent-warning{color:#bf7326}.jupyter-wrapper .bp3-dark .bp3-icon.bp3-intent-warning,.jupyter-wrapper .bp3-dark .bp3-icon-standard.bp3-intent-warning,.jupyter-wrapper .bp3-dark .bp3-icon-large.bp3-intent-warning{color:#ffb366}.jupyter-wrapper .bp3-icon.bp3-intent-danger,.jupyter-wrapper .bp3-icon-standard.bp3-intent-danger,.jupyter-wrapper .bp3-icon-large.bp3-intent-danger{color:#c23030}.jupyter-wrapper .bp3-dark .bp3-icon.bp3-intent-danger,.jupyter-wrapper .bp3-dark .bp3-icon-standard.bp3-intent-danger,.jupyter-wrapper .bp3-dark .bp3-icon-large.bp3-intent-danger{color:#ff7373}.jupyter-wrapper span.bp3-icon-standard{line-height:1;font-family:\"Icons16\",sans-serif;font-size:16px;font-weight:400;font-style:normal;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:inline-block}.jupyter-wrapper span.bp3-icon-large{line-height:1;font-family:\"Icons20\",sans-serif;font-size:20px;font-weight:400;font-style:normal;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:inline-block}.jupyter-wrapper span.bp3-icon:empty{line-height:1;font-family:\"Icons20\";font-size:inherit;font-weight:400;font-style:normal}.jupyter-wrapper span.bp3-icon:empty::before{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}.jupyter-wrapper .bp3-icon-add::before{content:\"\ue63e\"}.jupyter-wrapper .bp3-icon-add-column-left::before{content:\"\ue6f9\"}.jupyter-wrapper .bp3-icon-add-column-right::before{content:\"\ue6fa\"}.jupyter-wrapper .bp3-icon-add-row-bottom::before{content:\"\ue6f8\"}.jupyter-wrapper .bp3-icon-add-row-top::before{content:\"\ue6f7\"}.jupyter-wrapper .bp3-icon-add-to-artifact::before{content:\"\ue67c\"}.jupyter-wrapper .bp3-icon-add-to-folder::before{content:\"\ue6d2\"}.jupyter-wrapper .bp3-icon-airplane::before{content:\"\ue74b\"}.jupyter-wrapper .bp3-icon-align-center::before{content:\"\ue603\"}.jupyter-wrapper .bp3-icon-align-justify::before{content:\"\ue605\"}.jupyter-wrapper .bp3-icon-align-left::before{content:\"\ue602\"}.jupyter-wrapper .bp3-icon-align-right::before{content:\"\ue604\"}.jupyter-wrapper .bp3-icon-alignment-bottom::before{content:\"\ue727\"}.jupyter-wrapper .bp3-icon-alignment-horizontal-center::before{content:\"\ue726\"}.jupyter-wrapper .bp3-icon-alignment-left::before{content:\"\ue722\"}.jupyter-wrapper .bp3-icon-alignment-right::before{content:\"\ue724\"}.jupyter-wrapper .bp3-icon-alignment-top::before{content:\"\ue725\"}.jupyter-wrapper .bp3-icon-alignment-vertical-center::before{content:\"\ue723\"}.jupyter-wrapper .bp3-icon-annotation::before{content:\"\ue6f0\"}.jupyter-wrapper .bp3-icon-application::before{content:\"\ue735\"}.jupyter-wrapper .bp3-icon-applications::before{content:\"\ue621\"}.jupyter-wrapper .bp3-icon-archive::before{content:\"\ue907\"}.jupyter-wrapper .bp3-icon-arrow-bottom-left::before{content:\"\u2199\"}.jupyter-wrapper .bp3-icon-arrow-bottom-right::before{content:\"\u2198\"}.jupyter-wrapper .bp3-icon-arrow-down::before{content:\"\u2193\"}.jupyter-wrapper .bp3-icon-arrow-left::before{content:\"\u2190\"}.jupyter-wrapper .bp3-icon-arrow-right::before{content:\"\u2192\"}.jupyter-wrapper .bp3-icon-arrow-top-left::before{content:\"\u2196\"}.jupyter-wrapper .bp3-icon-arrow-top-right::before{content:\"\u2197\"}.jupyter-wrapper .bp3-icon-arrow-up::before{content:\"\u2191\"}.jupyter-wrapper .bp3-icon-arrows-horizontal::before{content:\"\u2194\"}.jupyter-wrapper .bp3-icon-arrows-vertical::before{content:\"\u2195\"}.jupyter-wrapper .bp3-icon-asterisk::before{content:\"*\"}.jupyter-wrapper .bp3-icon-automatic-updates::before{content:\"\ue65f\"}.jupyter-wrapper .bp3-icon-badge::before{content:\"\ue6e3\"}.jupyter-wrapper .bp3-icon-ban-circle::before{content:\"\ue69d\"}.jupyter-wrapper .bp3-icon-bank-account::before{content:\"\ue76f\"}.jupyter-wrapper .bp3-icon-barcode::before{content:\"\ue676\"}.jupyter-wrapper .bp3-icon-blank::before{content:\"\ue900\"}.jupyter-wrapper .bp3-icon-blocked-person::before{content:\"\ue768\"}.jupyter-wrapper .bp3-icon-bold::before{content:\"\ue606\"}.jupyter-wrapper .bp3-icon-book::before{content:\"\ue6b8\"}.jupyter-wrapper .bp3-icon-bookmark::before{content:\"\ue61a\"}.jupyter-wrapper .bp3-icon-box::before{content:\"\ue6bf\"}.jupyter-wrapper .bp3-icon-briefcase::before{content:\"\ue674\"}.jupyter-wrapper .bp3-icon-bring-data::before{content:\"\ue90a\"}.jupyter-wrapper .bp3-icon-build::before{content:\"\ue72d\"}.jupyter-wrapper .bp3-icon-calculator::before{content:\"\ue70b\"}.jupyter-wrapper .bp3-icon-calendar::before{content:\"\ue62b\"}.jupyter-wrapper .bp3-icon-camera::before{content:\"\ue69e\"}.jupyter-wrapper .bp3-icon-caret-down::before{content:\"\u2304\"}.jupyter-wrapper .bp3-icon-caret-left::before{content:\"\u2329\"}.jupyter-wrapper .bp3-icon-caret-right::before{content:\"\u232a\"}.jupyter-wrapper .bp3-icon-caret-up::before{content:\"\u2303\"}.jupyter-wrapper .bp3-icon-cell-tower::before{content:\"\ue770\"}.jupyter-wrapper .bp3-icon-changes::before{content:\"\ue623\"}.jupyter-wrapper .bp3-icon-chart::before{content:\"\ue67e\"}.jupyter-wrapper .bp3-icon-chat::before{content:\"\ue689\"}.jupyter-wrapper .bp3-icon-chevron-backward::before{content:\"\ue6df\"}.jupyter-wrapper .bp3-icon-chevron-down::before{content:\"\ue697\"}.jupyter-wrapper .bp3-icon-chevron-forward::before{content:\"\ue6e0\"}.jupyter-wrapper .bp3-icon-chevron-left::before{content:\"\ue694\"}.jupyter-wrapper .bp3-icon-chevron-right::before{content:\"\ue695\"}.jupyter-wrapper .bp3-icon-chevron-up::before{content:\"\ue696\"}.jupyter-wrapper .bp3-icon-circle::before{content:\"\ue66a\"}.jupyter-wrapper .bp3-icon-circle-arrow-down::before{content:\"\ue68e\"}.jupyter-wrapper .bp3-icon-circle-arrow-left::before{content:\"\ue68c\"}.jupyter-wrapper .bp3-icon-circle-arrow-right::before{content:\"\ue68b\"}.jupyter-wrapper .bp3-icon-circle-arrow-up::before{content:\"\ue68d\"}.jupyter-wrapper .bp3-icon-citation::before{content:\"\ue61b\"}.jupyter-wrapper .bp3-icon-clean::before{content:\"\ue7c5\"}.jupyter-wrapper .bp3-icon-clipboard::before{content:\"\ue61d\"}.jupyter-wrapper .bp3-icon-cloud::before{content:\"\u2601\"}.jupyter-wrapper .bp3-icon-cloud-download::before{content:\"\ue690\"}.jupyter-wrapper .bp3-icon-cloud-upload::before{content:\"\ue691\"}.jupyter-wrapper .bp3-icon-code::before{content:\"\ue661\"}.jupyter-wrapper .bp3-icon-code-block::before{content:\"\ue6c5\"}.jupyter-wrapper .bp3-icon-cog::before{content:\"\ue645\"}.jupyter-wrapper .bp3-icon-collapse-all::before{content:\"\ue763\"}.jupyter-wrapper .bp3-icon-column-layout::before{content:\"\ue6da\"}.jupyter-wrapper .bp3-icon-comment::before{content:\"\ue68a\"}.jupyter-wrapper .bp3-icon-comparison::before{content:\"\ue637\"}.jupyter-wrapper .bp3-icon-compass::before{content:\"\ue79c\"}.jupyter-wrapper .bp3-icon-compressed::before{content:\"\ue6c0\"}.jupyter-wrapper .bp3-icon-confirm::before{content:\"\ue639\"}.jupyter-wrapper .bp3-icon-console::before{content:\"\ue79b\"}.jupyter-wrapper .bp3-icon-contrast::before{content:\"\ue6cb\"}.jupyter-wrapper .bp3-icon-control::before{content:\"\ue67f\"}.jupyter-wrapper .bp3-icon-credit-card::before{content:\"\ue649\"}.jupyter-wrapper .bp3-icon-cross::before{content:\"\u2717\"}.jupyter-wrapper .bp3-icon-crown::before{content:\"\ue7b4\"}.jupyter-wrapper .bp3-icon-cube::before{content:\"\ue7c8\"}.jupyter-wrapper .bp3-icon-cube-add::before{content:\"\ue7c9\"}.jupyter-wrapper .bp3-icon-cube-remove::before{content:\"\ue7d0\"}.jupyter-wrapper .bp3-icon-curved-range-chart::before{content:\"\ue71b\"}.jupyter-wrapper .bp3-icon-cut::before{content:\"\ue6ef\"}.jupyter-wrapper .bp3-icon-dashboard::before{content:\"\ue751\"}.jupyter-wrapper .bp3-icon-data-lineage::before{content:\"\ue908\"}.jupyter-wrapper .bp3-icon-database::before{content:\"\ue683\"}.jupyter-wrapper .bp3-icon-delete::before{content:\"\ue644\"}.jupyter-wrapper .bp3-icon-delta::before{content:\"\u0394\"}.jupyter-wrapper .bp3-icon-derive-column::before{content:\"\ue739\"}.jupyter-wrapper .bp3-icon-desktop::before{content:\"\ue6af\"}.jupyter-wrapper .bp3-icon-diagram-tree::before{content:\"\ue7b3\"}.jupyter-wrapper .bp3-icon-direction-left::before{content:\"\ue681\"}.jupyter-wrapper .bp3-icon-direction-right::before{content:\"\ue682\"}.jupyter-wrapper .bp3-icon-disable::before{content:\"\ue600\"}.jupyter-wrapper .bp3-icon-document::before{content:\"\ue630\"}.jupyter-wrapper .bp3-icon-document-open::before{content:\"\ue71e\"}.jupyter-wrapper .bp3-icon-document-share::before{content:\"\ue71f\"}.jupyter-wrapper .bp3-icon-dollar::before{content:\"$\"}.jupyter-wrapper .bp3-icon-dot::before{content:\"\u2022\"}.jupyter-wrapper .bp3-icon-double-caret-horizontal::before{content:\"\ue6c7\"}.jupyter-wrapper .bp3-icon-double-caret-vertical::before{content:\"\ue6c6\"}.jupyter-wrapper .bp3-icon-double-chevron-down::before{content:\"\ue703\"}.jupyter-wrapper .bp3-icon-double-chevron-left::before{content:\"\ue6ff\"}.jupyter-wrapper .bp3-icon-double-chevron-right::before{content:\"\ue701\"}.jupyter-wrapper .bp3-icon-double-chevron-up::before{content:\"\ue702\"}.jupyter-wrapper .bp3-icon-doughnut-chart::before{content:\"\ue6ce\"}.jupyter-wrapper .bp3-icon-download::before{content:\"\ue62f\"}.jupyter-wrapper .bp3-icon-drag-handle-horizontal::before{content:\"\ue716\"}.jupyter-wrapper .bp3-icon-drag-handle-vertical::before{content:\"\ue715\"}.jupyter-wrapper .bp3-icon-draw::before{content:\"\ue66b\"}.jupyter-wrapper .bp3-icon-drive-time::before{content:\"\ue615\"}.jupyter-wrapper .bp3-icon-duplicate::before{content:\"\ue69c\"}.jupyter-wrapper .bp3-icon-edit::before{content:\"\u270e\"}.jupyter-wrapper .bp3-icon-eject::before{content:\"\u23cf\"}.jupyter-wrapper .bp3-icon-endorsed::before{content:\"\ue75f\"}.jupyter-wrapper .bp3-icon-envelope::before{content:\"\u2709\"}.jupyter-wrapper .bp3-icon-equals::before{content:\"\ue7d9\"}.jupyter-wrapper .bp3-icon-eraser::before{content:\"\ue773\"}.jupyter-wrapper .bp3-icon-error::before{content:\"\ue648\"}.jupyter-wrapper .bp3-icon-euro::before{content:\"\u20ac\"}.jupyter-wrapper .bp3-icon-exchange::before{content:\"\ue636\"}.jupyter-wrapper .bp3-icon-exclude-row::before{content:\"\ue6ea\"}.jupyter-wrapper .bp3-icon-expand-all::before{content:\"\ue764\"}.jupyter-wrapper .bp3-icon-export::before{content:\"\ue633\"}.jupyter-wrapper .bp3-icon-eye-off::before{content:\"\ue6cc\"}.jupyter-wrapper .bp3-icon-eye-on::before{content:\"\ue75a\"}.jupyter-wrapper .bp3-icon-eye-open::before{content:\"\ue66f\"}.jupyter-wrapper .bp3-icon-fast-backward::before{content:\"\ue6a8\"}.jupyter-wrapper .bp3-icon-fast-forward::before{content:\"\ue6ac\"}.jupyter-wrapper .bp3-icon-feed::before{content:\"\ue656\"}.jupyter-wrapper .bp3-icon-feed-subscribed::before{content:\"\ue78f\"}.jupyter-wrapper .bp3-icon-film::before{content:\"\ue6a1\"}.jupyter-wrapper .bp3-icon-filter::before{content:\"\ue638\"}.jupyter-wrapper .bp3-icon-filter-keep::before{content:\"\ue78c\"}.jupyter-wrapper .bp3-icon-filter-list::before{content:\"\ue6ee\"}.jupyter-wrapper .bp3-icon-filter-open::before{content:\"\ue7d7\"}.jupyter-wrapper .bp3-icon-filter-remove::before{content:\"\ue78d\"}.jupyter-wrapper .bp3-icon-flag::before{content:\"\u2691\"}.jupyter-wrapper .bp3-icon-flame::before{content:\"\ue7a9\"}.jupyter-wrapper .bp3-icon-flash::before{content:\"\ue6b3\"}.jupyter-wrapper .bp3-icon-floppy-disk::before{content:\"\ue6b7\"}.jupyter-wrapper .bp3-icon-flow-branch::before{content:\"\ue7c1\"}.jupyter-wrapper .bp3-icon-flow-end::before{content:\"\ue7c4\"}.jupyter-wrapper .bp3-icon-flow-linear::before{content:\"\ue7c0\"}.jupyter-wrapper .bp3-icon-flow-review::before{content:\"\ue7c2\"}.jupyter-wrapper .bp3-icon-flow-review-branch::before{content:\"\ue7c3\"}.jupyter-wrapper .bp3-icon-flows::before{content:\"\ue659\"}.jupyter-wrapper .bp3-icon-folder-close::before{content:\"\ue652\"}.jupyter-wrapper .bp3-icon-folder-new::before{content:\"\ue7b0\"}.jupyter-wrapper .bp3-icon-folder-open::before{content:\"\ue651\"}.jupyter-wrapper .bp3-icon-folder-shared::before{content:\"\ue653\"}.jupyter-wrapper .bp3-icon-folder-shared-open::before{content:\"\ue670\"}.jupyter-wrapper .bp3-icon-follower::before{content:\"\ue760\"}.jupyter-wrapper .bp3-icon-following::before{content:\"\ue761\"}.jupyter-wrapper .bp3-icon-font::before{content:\"\ue6b4\"}.jupyter-wrapper .bp3-icon-fork::before{content:\"\ue63a\"}.jupyter-wrapper .bp3-icon-form::before{content:\"\ue795\"}.jupyter-wrapper .bp3-icon-full-circle::before{content:\"\ue685\"}.jupyter-wrapper .bp3-icon-full-stacked-chart::before{content:\"\ue75e\"}.jupyter-wrapper .bp3-icon-fullscreen::before{content:\"\ue699\"}.jupyter-wrapper .bp3-icon-function::before{content:\"\ue6e5\"}.jupyter-wrapper .bp3-icon-gantt-chart::before{content:\"\ue6f4\"}.jupyter-wrapper .bp3-icon-geolocation::before{content:\"\ue640\"}.jupyter-wrapper .bp3-icon-geosearch::before{content:\"\ue613\"}.jupyter-wrapper .bp3-icon-git-branch::before{content:\"\ue72a\"}.jupyter-wrapper .bp3-icon-git-commit::before{content:\"\ue72b\"}.jupyter-wrapper .bp3-icon-git-merge::before{content:\"\ue729\"}.jupyter-wrapper .bp3-icon-git-new-branch::before{content:\"\ue749\"}.jupyter-wrapper .bp3-icon-git-pull::before{content:\"\ue728\"}.jupyter-wrapper .bp3-icon-git-push::before{content:\"\ue72c\"}.jupyter-wrapper .bp3-icon-git-repo::before{content:\"\ue748\"}.jupyter-wrapper .bp3-icon-glass::before{content:\"\ue6b1\"}.jupyter-wrapper .bp3-icon-globe::before{content:\"\ue666\"}.jupyter-wrapper .bp3-icon-globe-network::before{content:\"\ue7b5\"}.jupyter-wrapper .bp3-icon-graph::before{content:\"\ue673\"}.jupyter-wrapper .bp3-icon-graph-remove::before{content:\"\ue609\"}.jupyter-wrapper .bp3-icon-greater-than::before{content:\"\ue7e1\"}.jupyter-wrapper .bp3-icon-greater-than-or-equal-to::before{content:\"\ue7e2\"}.jupyter-wrapper .bp3-icon-grid::before{content:\"\ue6d0\"}.jupyter-wrapper .bp3-icon-grid-view::before{content:\"\ue6e4\"}.jupyter-wrapper .bp3-icon-group-objects::before{content:\"\ue60a\"}.jupyter-wrapper .bp3-icon-grouped-bar-chart::before{content:\"\ue75d\"}.jupyter-wrapper .bp3-icon-hand::before{content:\"\ue6de\"}.jupyter-wrapper .bp3-icon-hand-down::before{content:\"\ue6bb\"}.jupyter-wrapper .bp3-icon-hand-left::before{content:\"\ue6bc\"}.jupyter-wrapper .bp3-icon-hand-right::before{content:\"\ue6b9\"}.jupyter-wrapper .bp3-icon-hand-up::before{content:\"\ue6ba\"}.jupyter-wrapper .bp3-icon-header::before{content:\"\ue6b5\"}.jupyter-wrapper .bp3-icon-header-one::before{content:\"\ue793\"}.jupyter-wrapper .bp3-icon-header-two::before{content:\"\ue794\"}.jupyter-wrapper .bp3-icon-headset::before{content:\"\ue6dc\"}.jupyter-wrapper .bp3-icon-heart::before{content:\"\u2665\"}.jupyter-wrapper .bp3-icon-heart-broken::before{content:\"\ue7a2\"}.jupyter-wrapper .bp3-icon-heat-grid::before{content:\"\ue6f3\"}.jupyter-wrapper .bp3-icon-heatmap::before{content:\"\ue614\"}.jupyter-wrapper .bp3-icon-help::before{content:\"?\"}.jupyter-wrapper .bp3-icon-helper-management::before{content:\"\ue66d\"}.jupyter-wrapper .bp3-icon-highlight::before{content:\"\ue6ed\"}.jupyter-wrapper .bp3-icon-history::before{content:\"\ue64a\"}.jupyter-wrapper .bp3-icon-home::before{content:\"\u2302\"}.jupyter-wrapper .bp3-icon-horizontal-bar-chart::before{content:\"\ue70c\"}.jupyter-wrapper .bp3-icon-horizontal-bar-chart-asc::before{content:\"\ue75c\"}.jupyter-wrapper .bp3-icon-horizontal-bar-chart-desc::before{content:\"\ue71d\"}.jupyter-wrapper .bp3-icon-horizontal-distribution::before{content:\"\ue720\"}.jupyter-wrapper .bp3-icon-id-number::before{content:\"\ue771\"}.jupyter-wrapper .bp3-icon-image-rotate-left::before{content:\"\ue73a\"}.jupyter-wrapper .bp3-icon-image-rotate-right::before{content:\"\ue73b\"}.jupyter-wrapper .bp3-icon-import::before{content:\"\ue632\"}.jupyter-wrapper .bp3-icon-inbox::before{content:\"\ue629\"}.jupyter-wrapper .bp3-icon-inbox-filtered::before{content:\"\ue7d1\"}.jupyter-wrapper .bp3-icon-inbox-geo::before{content:\"\ue7d2\"}.jupyter-wrapper .bp3-icon-inbox-search::before{content:\"\ue7d3\"}.jupyter-wrapper .bp3-icon-inbox-update::before{content:\"\ue7d4\"}.jupyter-wrapper .bp3-icon-info-sign::before{content:\"\u2139\"}.jupyter-wrapper .bp3-icon-inheritance::before{content:\"\ue7d5\"}.jupyter-wrapper .bp3-icon-inner-join::before{content:\"\ue7a3\"}.jupyter-wrapper .bp3-icon-insert::before{content:\"\ue66c\"}.jupyter-wrapper .bp3-icon-intersection::before{content:\"\ue765\"}.jupyter-wrapper .bp3-icon-ip-address::before{content:\"\ue772\"}.jupyter-wrapper .bp3-icon-issue::before{content:\"\ue774\"}.jupyter-wrapper .bp3-icon-issue-closed::before{content:\"\ue776\"}.jupyter-wrapper .bp3-icon-issue-new::before{content:\"\ue775\"}.jupyter-wrapper .bp3-icon-italic::before{content:\"\ue607\"}.jupyter-wrapper .bp3-icon-join-table::before{content:\"\ue738\"}.jupyter-wrapper .bp3-icon-key::before{content:\"\ue78e\"}.jupyter-wrapper .bp3-icon-key-backspace::before{content:\"\ue707\"}.jupyter-wrapper .bp3-icon-key-command::before{content:\"\ue705\"}.jupyter-wrapper .bp3-icon-key-control::before{content:\"\ue704\"}.jupyter-wrapper .bp3-icon-key-delete::before{content:\"\ue708\"}.jupyter-wrapper .bp3-icon-key-enter::before{content:\"\ue70a\"}.jupyter-wrapper .bp3-icon-key-escape::before{content:\"\ue709\"}.jupyter-wrapper .bp3-icon-key-option::before{content:\"\ue742\"}.jupyter-wrapper .bp3-icon-key-shift::before{content:\"\ue706\"}.jupyter-wrapper .bp3-icon-key-tab::before{content:\"\ue757\"}.jupyter-wrapper .bp3-icon-known-vehicle::before{content:\"\ue73c\"}.jupyter-wrapper .bp3-icon-label::before{content:\"\ue665\"}.jupyter-wrapper .bp3-icon-layer::before{content:\"\ue6cf\"}.jupyter-wrapper .bp3-icon-layers::before{content:\"\ue618\"}.jupyter-wrapper .bp3-icon-layout::before{content:\"\ue60c\"}.jupyter-wrapper .bp3-icon-layout-auto::before{content:\"\ue60d\"}.jupyter-wrapper .bp3-icon-layout-balloon::before{content:\"\ue6d3\"}.jupyter-wrapper .bp3-icon-layout-circle::before{content:\"\ue60e\"}.jupyter-wrapper .bp3-icon-layout-grid::before{content:\"\ue610\"}.jupyter-wrapper .bp3-icon-layout-group-by::before{content:\"\ue611\"}.jupyter-wrapper .bp3-icon-layout-hierarchy::before{content:\"\ue60f\"}.jupyter-wrapper .bp3-icon-layout-linear::before{content:\"\ue6c3\"}.jupyter-wrapper .bp3-icon-layout-skew-grid::before{content:\"\ue612\"}.jupyter-wrapper .bp3-icon-layout-sorted-clusters::before{content:\"\ue6d4\"}.jupyter-wrapper .bp3-icon-learning::before{content:\"\ue904\"}.jupyter-wrapper .bp3-icon-left-join::before{content:\"\ue7a4\"}.jupyter-wrapper .bp3-icon-less-than::before{content:\"\ue7e3\"}.jupyter-wrapper .bp3-icon-less-than-or-equal-to::before{content:\"\ue7e4\"}.jupyter-wrapper .bp3-icon-lifesaver::before{content:\"\ue7c7\"}.jupyter-wrapper .bp3-icon-lightbulb::before{content:\"\ue6b0\"}.jupyter-wrapper .bp3-icon-link::before{content:\"\ue62d\"}.jupyter-wrapper .bp3-icon-list::before{content:\"\u2630\"}.jupyter-wrapper .bp3-icon-list-columns::before{content:\"\ue7b9\"}.jupyter-wrapper .bp3-icon-list-detail-view::before{content:\"\ue743\"}.jupyter-wrapper .bp3-icon-locate::before{content:\"\ue619\"}.jupyter-wrapper .bp3-icon-lock::before{content:\"\ue625\"}.jupyter-wrapper .bp3-icon-log-in::before{content:\"\ue69a\"}.jupyter-wrapper .bp3-icon-log-out::before{content:\"\ue64c\"}.jupyter-wrapper .bp3-icon-manual::before{content:\"\ue6f6\"}.jupyter-wrapper .bp3-icon-manually-entered-data::before{content:\"\ue74a\"}.jupyter-wrapper .bp3-icon-map::before{content:\"\ue662\"}.jupyter-wrapper .bp3-icon-map-create::before{content:\"\ue741\"}.jupyter-wrapper .bp3-icon-map-marker::before{content:\"\ue67d\"}.jupyter-wrapper .bp3-icon-maximize::before{content:\"\ue635\"}.jupyter-wrapper .bp3-icon-media::before{content:\"\ue62c\"}.jupyter-wrapper .bp3-icon-menu::before{content:\"\ue762\"}.jupyter-wrapper .bp3-icon-menu-closed::before{content:\"\ue655\"}.jupyter-wrapper .bp3-icon-menu-open::before{content:\"\ue654\"}.jupyter-wrapper .bp3-icon-merge-columns::before{content:\"\ue74f\"}.jupyter-wrapper .bp3-icon-merge-links::before{content:\"\ue60b\"}.jupyter-wrapper .bp3-icon-minimize::before{content:\"\ue634\"}.jupyter-wrapper .bp3-icon-minus::before{content:\"\u2212\"}.jupyter-wrapper .bp3-icon-mobile-phone::before{content:\"\ue717\"}.jupyter-wrapper .bp3-icon-mobile-video::before{content:\"\ue69f\"}.jupyter-wrapper .bp3-icon-moon::before{content:\"\ue754\"}.jupyter-wrapper .bp3-icon-more::before{content:\"\ue62a\"}.jupyter-wrapper .bp3-icon-mountain::before{content:\"\ue7b1\"}.jupyter-wrapper .bp3-icon-move::before{content:\"\ue693\"}.jupyter-wrapper .bp3-icon-mugshot::before{content:\"\ue6db\"}.jupyter-wrapper .bp3-icon-multi-select::before{content:\"\ue680\"}.jupyter-wrapper .bp3-icon-music::before{content:\"\ue6a6\"}.jupyter-wrapper .bp3-icon-new-drawing::before{content:\"\ue905\"}.jupyter-wrapper .bp3-icon-new-grid-item::before{content:\"\ue747\"}.jupyter-wrapper .bp3-icon-new-layer::before{content:\"\ue902\"}.jupyter-wrapper .bp3-icon-new-layers::before{content:\"\ue903\"}.jupyter-wrapper .bp3-icon-new-link::before{content:\"\ue65c\"}.jupyter-wrapper .bp3-icon-new-object::before{content:\"\ue65d\"}.jupyter-wrapper .bp3-icon-new-person::before{content:\"\ue6e9\"}.jupyter-wrapper .bp3-icon-new-prescription::before{content:\"\ue78b\"}.jupyter-wrapper .bp3-icon-new-text-box::before{content:\"\ue65b\"}.jupyter-wrapper .bp3-icon-ninja::before{content:\"\ue675\"}.jupyter-wrapper .bp3-icon-not-equal-to::before{content:\"\ue7e0\"}.jupyter-wrapper .bp3-icon-notifications::before{content:\"\ue624\"}.jupyter-wrapper .bp3-icon-notifications-updated::before{content:\"\ue7b8\"}.jupyter-wrapper .bp3-icon-numbered-list::before{content:\"\ue746\"}.jupyter-wrapper .bp3-icon-numerical::before{content:\"\ue756\"}.jupyter-wrapper .bp3-icon-office::before{content:\"\ue69b\"}.jupyter-wrapper .bp3-icon-offline::before{content:\"\ue67a\"}.jupyter-wrapper .bp3-icon-oil-field::before{content:\"\ue73f\"}.jupyter-wrapper .bp3-icon-one-column::before{content:\"\ue658\"}.jupyter-wrapper .bp3-icon-outdated::before{content:\"\ue7a8\"}.jupyter-wrapper .bp3-icon-page-layout::before{content:\"\ue660\"}.jupyter-wrapper .bp3-icon-panel-stats::before{content:\"\ue777\"}.jupyter-wrapper .bp3-icon-panel-table::before{content:\"\ue778\"}.jupyter-wrapper .bp3-icon-paperclip::before{content:\"\ue664\"}.jupyter-wrapper .bp3-icon-paragraph::before{content:\"\ue76c\"}.jupyter-wrapper .bp3-icon-path::before{content:\"\ue753\"}.jupyter-wrapper .bp3-icon-path-search::before{content:\"\ue65e\"}.jupyter-wrapper .bp3-icon-pause::before{content:\"\ue6a9\"}.jupyter-wrapper .bp3-icon-people::before{content:\"\ue63d\"}.jupyter-wrapper .bp3-icon-percentage::before{content:\"\ue76a\"}.jupyter-wrapper .bp3-icon-person::before{content:\"\ue63c\"}.jupyter-wrapper .bp3-icon-phone::before{content:\"\u260e\"}.jupyter-wrapper .bp3-icon-pie-chart::before{content:\"\ue684\"}.jupyter-wrapper .bp3-icon-pin::before{content:\"\ue646\"}.jupyter-wrapper .bp3-icon-pivot::before{content:\"\ue6f1\"}.jupyter-wrapper .bp3-icon-pivot-table::before{content:\"\ue6eb\"}.jupyter-wrapper .bp3-icon-play::before{content:\"\ue6ab\"}.jupyter-wrapper .bp3-icon-plus::before{content:\"+\"}.jupyter-wrapper .bp3-icon-polygon-filter::before{content:\"\ue6d1\"}.jupyter-wrapper .bp3-icon-power::before{content:\"\ue6d9\"}.jupyter-wrapper .bp3-icon-predictive-analysis::before{content:\"\ue617\"}.jupyter-wrapper .bp3-icon-prescription::before{content:\"\ue78a\"}.jupyter-wrapper .bp3-icon-presentation::before{content:\"\ue687\"}.jupyter-wrapper .bp3-icon-print::before{content:\"\u2399\"}.jupyter-wrapper .bp3-icon-projects::before{content:\"\ue622\"}.jupyter-wrapper .bp3-icon-properties::before{content:\"\ue631\"}.jupyter-wrapper .bp3-icon-property::before{content:\"\ue65a\"}.jupyter-wrapper .bp3-icon-publish-function::before{content:\"\ue752\"}.jupyter-wrapper .bp3-icon-pulse::before{content:\"\ue6e8\"}.jupyter-wrapper .bp3-icon-random::before{content:\"\ue698\"}.jupyter-wrapper .bp3-icon-record::before{content:\"\ue6ae\"}.jupyter-wrapper .bp3-icon-redo::before{content:\"\ue6c4\"}.jupyter-wrapper .bp3-icon-refresh::before{content:\"\ue643\"}.jupyter-wrapper .bp3-icon-regression-chart::before{content:\"\ue758\"}.jupyter-wrapper .bp3-icon-remove::before{content:\"\ue63f\"}.jupyter-wrapper .bp3-icon-remove-column::before{content:\"\ue755\"}.jupyter-wrapper .bp3-icon-remove-column-left::before{content:\"\ue6fd\"}.jupyter-wrapper .bp3-icon-remove-column-right::before{content:\"\ue6fe\"}.jupyter-wrapper .bp3-icon-remove-row-bottom::before{content:\"\ue6fc\"}.jupyter-wrapper .bp3-icon-remove-row-top::before{content:\"\ue6fb\"}.jupyter-wrapper .bp3-icon-repeat::before{content:\"\ue692\"}.jupyter-wrapper .bp3-icon-reset::before{content:\"\ue7d6\"}.jupyter-wrapper .bp3-icon-resolve::before{content:\"\ue672\"}.jupyter-wrapper .bp3-icon-rig::before{content:\"\ue740\"}.jupyter-wrapper .bp3-icon-right-join::before{content:\"\ue7a5\"}.jupyter-wrapper .bp3-icon-ring::before{content:\"\ue6f2\"}.jupyter-wrapper .bp3-icon-rotate-document::before{content:\"\ue6e1\"}.jupyter-wrapper .bp3-icon-rotate-page::before{content:\"\ue6e2\"}.jupyter-wrapper .bp3-icon-satellite::before{content:\"\ue76b\"}.jupyter-wrapper .bp3-icon-saved::before{content:\"\ue6b6\"}.jupyter-wrapper .bp3-icon-scatter-plot::before{content:\"\ue73e\"}.jupyter-wrapper .bp3-icon-search::before{content:\"\ue64b\"}.jupyter-wrapper .bp3-icon-search-around::before{content:\"\ue608\"}.jupyter-wrapper .bp3-icon-search-template::before{content:\"\ue628\"}.jupyter-wrapper .bp3-icon-search-text::before{content:\"\ue663\"}.jupyter-wrapper .bp3-icon-segmented-control::before{content:\"\ue6ec\"}.jupyter-wrapper .bp3-icon-select::before{content:\"\ue616\"}.jupyter-wrapper .bp3-icon-selection::before{content:\"\u29bf\"}.jupyter-wrapper .bp3-icon-send-to::before{content:\"\ue66e\"}.jupyter-wrapper .bp3-icon-send-to-graph::before{content:\"\ue736\"}.jupyter-wrapper .bp3-icon-send-to-map::before{content:\"\ue737\"}.jupyter-wrapper .bp3-icon-series-add::before{content:\"\ue796\"}.jupyter-wrapper .bp3-icon-series-configuration::before{content:\"\ue79a\"}.jupyter-wrapper .bp3-icon-series-derived::before{content:\"\ue799\"}.jupyter-wrapper .bp3-icon-series-filtered::before{content:\"\ue798\"}.jupyter-wrapper .bp3-icon-series-search::before{content:\"\ue797\"}.jupyter-wrapper .bp3-icon-settings::before{content:\"\ue6a2\"}.jupyter-wrapper .bp3-icon-share::before{content:\"\ue62e\"}.jupyter-wrapper .bp3-icon-shield::before{content:\"\ue7b2\"}.jupyter-wrapper .bp3-icon-shop::before{content:\"\ue6c2\"}.jupyter-wrapper .bp3-icon-shopping-cart::before{content:\"\ue6c1\"}.jupyter-wrapper .bp3-icon-signal-search::before{content:\"\ue909\"}.jupyter-wrapper .bp3-icon-sim-card::before{content:\"\ue718\"}.jupyter-wrapper .bp3-icon-slash::before{content:\"\ue769\"}.jupyter-wrapper .bp3-icon-small-cross::before{content:\"\ue6d7\"}.jupyter-wrapper .bp3-icon-small-minus::before{content:\"\ue70e\"}.jupyter-wrapper .bp3-icon-small-plus::before{content:\"\ue70d\"}.jupyter-wrapper .bp3-icon-small-tick::before{content:\"\ue6d8\"}.jupyter-wrapper .bp3-icon-snowflake::before{content:\"\ue7b6\"}.jupyter-wrapper .bp3-icon-social-media::before{content:\"\ue671\"}.jupyter-wrapper .bp3-icon-sort::before{content:\"\ue64f\"}.jupyter-wrapper .bp3-icon-sort-alphabetical::before{content:\"\ue64d\"}.jupyter-wrapper .bp3-icon-sort-alphabetical-desc::before{content:\"\ue6c8\"}.jupyter-wrapper .bp3-icon-sort-asc::before{content:\"\ue6d5\"}.jupyter-wrapper .bp3-icon-sort-desc::before{content:\"\ue6d6\"}.jupyter-wrapper .bp3-icon-sort-numerical::before{content:\"\ue64e\"}.jupyter-wrapper .bp3-icon-sort-numerical-desc::before{content:\"\ue6c9\"}.jupyter-wrapper .bp3-icon-split-columns::before{content:\"\ue750\"}.jupyter-wrapper .bp3-icon-square::before{content:\"\ue686\"}.jupyter-wrapper .bp3-icon-stacked-chart::before{content:\"\ue6e7\"}.jupyter-wrapper .bp3-icon-star::before{content:\"\u2605\"}.jupyter-wrapper .bp3-icon-star-empty::before{content:\"\u2606\"}.jupyter-wrapper .bp3-icon-step-backward::before{content:\"\ue6a7\"}.jupyter-wrapper .bp3-icon-step-chart::before{content:\"\ue70f\"}.jupyter-wrapper .bp3-icon-step-forward::before{content:\"\ue6ad\"}.jupyter-wrapper .bp3-icon-stop::before{content:\"\ue6aa\"}.jupyter-wrapper .bp3-icon-stopwatch::before{content:\"\ue901\"}.jupyter-wrapper .bp3-icon-strikethrough::before{content:\"\ue7a6\"}.jupyter-wrapper .bp3-icon-style::before{content:\"\ue601\"}.jupyter-wrapper .bp3-icon-swap-horizontal::before{content:\"\ue745\"}.jupyter-wrapper .bp3-icon-swap-vertical::before{content:\"\ue744\"}.jupyter-wrapper .bp3-icon-symbol-circle::before{content:\"\ue72e\"}.jupyter-wrapper .bp3-icon-symbol-cross::before{content:\"\ue731\"}.jupyter-wrapper .bp3-icon-symbol-diamond::before{content:\"\ue730\"}.jupyter-wrapper .bp3-icon-symbol-square::before{content:\"\ue72f\"}.jupyter-wrapper .bp3-icon-symbol-triangle-down::before{content:\"\ue733\"}.jupyter-wrapper .bp3-icon-symbol-triangle-up::before{content:\"\ue732\"}.jupyter-wrapper .bp3-icon-tag::before{content:\"\ue61c\"}.jupyter-wrapper .bp3-icon-take-action::before{content:\"\ue6ca\"}.jupyter-wrapper .bp3-icon-taxi::before{content:\"\ue79e\"}.jupyter-wrapper .bp3-icon-text-highlight::before{content:\"\ue6dd\"}.jupyter-wrapper .bp3-icon-th::before{content:\"\ue667\"}.jupyter-wrapper .bp3-icon-th-derived::before{content:\"\ue669\"}.jupyter-wrapper .bp3-icon-th-disconnect::before{content:\"\ue7d8\"}.jupyter-wrapper .bp3-icon-th-filtered::before{content:\"\ue7c6\"}.jupyter-wrapper .bp3-icon-th-list::before{content:\"\ue668\"}.jupyter-wrapper .bp3-icon-thumbs-down::before{content:\"\ue6be\"}.jupyter-wrapper .bp3-icon-thumbs-up::before{content:\"\ue6bd\"}.jupyter-wrapper .bp3-icon-tick::before{content:\"\u2713\"}.jupyter-wrapper .bp3-icon-tick-circle::before{content:\"\ue779\"}.jupyter-wrapper .bp3-icon-time::before{content:\"\u23f2\"}.jupyter-wrapper .bp3-icon-timeline-area-chart::before{content:\"\ue6cd\"}.jupyter-wrapper .bp3-icon-timeline-bar-chart::before{content:\"\ue620\"}.jupyter-wrapper .bp3-icon-timeline-events::before{content:\"\ue61e\"}.jupyter-wrapper .bp3-icon-timeline-line-chart::before{content:\"\ue61f\"}.jupyter-wrapper .bp3-icon-tint::before{content:\"\ue6b2\"}.jupyter-wrapper .bp3-icon-torch::before{content:\"\ue677\"}.jupyter-wrapper .bp3-icon-tractor::before{content:\"\ue90c\"}.jupyter-wrapper .bp3-icon-train::before{content:\"\ue79f\"}.jupyter-wrapper .bp3-icon-translate::before{content:\"\ue759\"}.jupyter-wrapper .bp3-icon-trash::before{content:\"\ue63b\"}.jupyter-wrapper .bp3-icon-tree::before{content:\"\ue7b7\"}.jupyter-wrapper .bp3-icon-trending-down::before{content:\"\ue71a\"}.jupyter-wrapper .bp3-icon-trending-up::before{content:\"\ue719\"}.jupyter-wrapper .bp3-icon-truck::before{content:\"\ue90b\"}.jupyter-wrapper .bp3-icon-two-columns::before{content:\"\ue657\"}.jupyter-wrapper .bp3-icon-unarchive::before{content:\"\ue906\"}.jupyter-wrapper .bp3-icon-underline::before{content:\"\u2381\"}.jupyter-wrapper .bp3-icon-undo::before{content:\"\u238c\"}.jupyter-wrapper .bp3-icon-ungroup-objects::before{content:\"\ue688\"}.jupyter-wrapper .bp3-icon-unknown-vehicle::before{content:\"\ue73d\"}.jupyter-wrapper .bp3-icon-unlock::before{content:\"\ue626\"}.jupyter-wrapper .bp3-icon-unpin::before{content:\"\ue650\"}.jupyter-wrapper .bp3-icon-unresolve::before{content:\"\ue679\"}.jupyter-wrapper .bp3-icon-updated::before{content:\"\ue7a7\"}.jupyter-wrapper .bp3-icon-upload::before{content:\"\ue68f\"}.jupyter-wrapper .bp3-icon-user::before{content:\"\ue627\"}.jupyter-wrapper .bp3-icon-variable::before{content:\"\ue6f5\"}.jupyter-wrapper .bp3-icon-vertical-bar-chart-asc::before{content:\"\ue75b\"}.jupyter-wrapper .bp3-icon-vertical-bar-chart-desc::before{content:\"\ue71c\"}.jupyter-wrapper .bp3-icon-vertical-distribution::before{content:\"\ue721\"}.jupyter-wrapper .bp3-icon-video::before{content:\"\ue6a0\"}.jupyter-wrapper .bp3-icon-volume-down::before{content:\"\ue6a4\"}.jupyter-wrapper .bp3-icon-volume-off::before{content:\"\ue6a3\"}.jupyter-wrapper .bp3-icon-volume-up::before{content:\"\ue6a5\"}.jupyter-wrapper .bp3-icon-walk::before{content:\"\ue79d\"}.jupyter-wrapper .bp3-icon-warning-sign::before{content:\"\ue647\"}.jupyter-wrapper .bp3-icon-waterfall-chart::before{content:\"\ue6e6\"}.jupyter-wrapper .bp3-icon-widget::before{content:\"\ue678\"}.jupyter-wrapper .bp3-icon-widget-button::before{content:\"\ue790\"}.jupyter-wrapper .bp3-icon-widget-footer::before{content:\"\ue792\"}.jupyter-wrapper .bp3-icon-widget-header::before{content:\"\ue791\"}.jupyter-wrapper .bp3-icon-wrench::before{content:\"\ue734\"}.jupyter-wrapper .bp3-icon-zoom-in::before{content:\"\ue641\"}.jupyter-wrapper .bp3-icon-zoom-out::before{content:\"\ue642\"}.jupyter-wrapper .bp3-icon-zoom-to-fit::before{content:\"\ue67b\"}.jupyter-wrapper .bp3-submenu>.bp3-popover-wrapper{display:block}.jupyter-wrapper .bp3-submenu .bp3-popover-target{display:block}.jupyter-wrapper .bp3-submenu.bp3-popover{-webkit-box-shadow:none;box-shadow:none;padding:0 5px}.jupyter-wrapper .bp3-submenu.bp3-popover>.bp3-popover-content{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.1),0 2px 4px rgba(16,22,26,.2),0 8px 24px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.1),0 2px 4px rgba(16,22,26,.2),0 8px 24px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-dark .bp3-submenu.bp3-popover,.jupyter-wrapper .bp3-submenu.bp3-popover.bp3-dark{-webkit-box-shadow:none;box-shadow:none}.jupyter-wrapper .bp3-dark .bp3-submenu.bp3-popover>.bp3-popover-content,.jupyter-wrapper .bp3-submenu.bp3-popover.bp3-dark>.bp3-popover-content{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),0 2px 4px rgba(16,22,26,.4),0 8px 24px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.2),0 2px 4px rgba(16,22,26,.4),0 8px 24px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-menu{margin:0;border-radius:3px;background:#fff;min-width:180px;padding:5px;list-style:none;text-align:left;color:#182026}.jupyter-wrapper .bp3-menu-divider{display:block;margin:5px;border-top:1px solid rgba(16,22,26,.15)}.jupyter-wrapper .bp3-dark .bp3-menu-divider{border-top-color:rgba(255,255,255,.15)}.jupyter-wrapper .bp3-menu-item{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start;border-radius:2px;padding:5px 7px;text-decoration:none;line-height:20px;color:inherit;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.jupyter-wrapper .bp3-menu-item>*{-webkit-box-flex:0;-ms-flex-positive:0;flex-grow:0;-ms-flex-negative:0;flex-shrink:0}.jupyter-wrapper .bp3-menu-item>.bp3-fill{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-negative:1;flex-shrink:1}.jupyter-wrapper .bp3-menu-item::before,.jupyter-wrapper .bp3-menu-item>*{margin-right:7px}.jupyter-wrapper .bp3-menu-item:empty::before,.jupyter-wrapper .bp3-menu-item>:last-child{margin-right:0}.jupyter-wrapper .bp3-menu-item>.bp3-fill{word-break:break-word}.jupyter-wrapper .bp3-menu-item:hover,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-menu-item{background-color:rgba(167,182,194,.3);cursor:pointer;text-decoration:none}.jupyter-wrapper .bp3-menu-item.bp3-disabled{background-color:inherit;cursor:not-allowed;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-dark .bp3-menu-item{color:inherit}.jupyter-wrapper .bp3-dark .bp3-menu-item:hover,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-menu-item,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-menu-item{background-color:rgba(138,155,168,.15);color:inherit}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-disabled{background-color:inherit;color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-menu-item.bp3-intent-primary{color:#106ba3}.jupyter-wrapper .bp3-menu-item.bp3-intent-primary .bp3-icon{color:inherit}.jupyter-wrapper .bp3-menu-item.bp3-intent-primary::before,.jupyter-wrapper .bp3-menu-item.bp3-intent-primary::after,.jupyter-wrapper .bp3-menu-item.bp3-intent-primary .bp3-menu-item-label{color:#106ba3}.jupyter-wrapper .bp3-menu-item.bp3-intent-primary:hover,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-primary.bp3-menu-item,.jupyter-wrapper .bp3-menu-item.bp3-intent-primary.bp3-active{background-color:#137cbd}.jupyter-wrapper .bp3-menu-item.bp3-intent-primary:active{background-color:#106ba3}.jupyter-wrapper .bp3-menu-item.bp3-intent-primary:hover,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-primary.bp3-menu-item,.jupyter-wrapper .bp3-menu-item.bp3-intent-primary:hover::before,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-primary.bp3-menu-item::before,.jupyter-wrapper .bp3-menu-item.bp3-intent-primary:hover::after,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-primary.bp3-menu-item::after,.jupyter-wrapper .bp3-menu-item.bp3-intent-primary:hover .bp3-menu-item-label,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-primary.bp3-menu-item .bp3-menu-item-label,.jupyter-wrapper .bp3-menu-item.bp3-intent-primary:active,.jupyter-wrapper .bp3-menu-item.bp3-intent-primary:active::before,.jupyter-wrapper .bp3-menu-item.bp3-intent-primary:active::after,.jupyter-wrapper .bp3-menu-item.bp3-intent-primary:active .bp3-menu-item-label,.jupyter-wrapper .bp3-menu-item.bp3-intent-primary.bp3-active,.jupyter-wrapper .bp3-menu-item.bp3-intent-primary.bp3-active::before,.jupyter-wrapper .bp3-menu-item.bp3-intent-primary.bp3-active::after,.jupyter-wrapper .bp3-menu-item.bp3-intent-primary.bp3-active .bp3-menu-item-label{color:#fff}.jupyter-wrapper .bp3-menu-item.bp3-intent-success{color:#0d8050}.jupyter-wrapper .bp3-menu-item.bp3-intent-success .bp3-icon{color:inherit}.jupyter-wrapper .bp3-menu-item.bp3-intent-success::before,.jupyter-wrapper .bp3-menu-item.bp3-intent-success::after,.jupyter-wrapper .bp3-menu-item.bp3-intent-success .bp3-menu-item-label{color:#0d8050}.jupyter-wrapper .bp3-menu-item.bp3-intent-success:hover,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-success.bp3-menu-item,.jupyter-wrapper .bp3-menu-item.bp3-intent-success.bp3-active{background-color:#0f9960}.jupyter-wrapper .bp3-menu-item.bp3-intent-success:active{background-color:#0d8050}.jupyter-wrapper .bp3-menu-item.bp3-intent-success:hover,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-success.bp3-menu-item,.jupyter-wrapper .bp3-menu-item.bp3-intent-success:hover::before,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-success.bp3-menu-item::before,.jupyter-wrapper .bp3-menu-item.bp3-intent-success:hover::after,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-success.bp3-menu-item::after,.jupyter-wrapper .bp3-menu-item.bp3-intent-success:hover .bp3-menu-item-label,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-success.bp3-menu-item .bp3-menu-item-label,.jupyter-wrapper .bp3-menu-item.bp3-intent-success:active,.jupyter-wrapper .bp3-menu-item.bp3-intent-success:active::before,.jupyter-wrapper .bp3-menu-item.bp3-intent-success:active::after,.jupyter-wrapper .bp3-menu-item.bp3-intent-success:active .bp3-menu-item-label,.jupyter-wrapper .bp3-menu-item.bp3-intent-success.bp3-active,.jupyter-wrapper .bp3-menu-item.bp3-intent-success.bp3-active::before,.jupyter-wrapper .bp3-menu-item.bp3-intent-success.bp3-active::after,.jupyter-wrapper .bp3-menu-item.bp3-intent-success.bp3-active .bp3-menu-item-label{color:#fff}.jupyter-wrapper .bp3-menu-item.bp3-intent-warning{color:#bf7326}.jupyter-wrapper .bp3-menu-item.bp3-intent-warning .bp3-icon{color:inherit}.jupyter-wrapper .bp3-menu-item.bp3-intent-warning::before,.jupyter-wrapper .bp3-menu-item.bp3-intent-warning::after,.jupyter-wrapper .bp3-menu-item.bp3-intent-warning .bp3-menu-item-label{color:#bf7326}.jupyter-wrapper .bp3-menu-item.bp3-intent-warning:hover,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-warning.bp3-menu-item,.jupyter-wrapper .bp3-menu-item.bp3-intent-warning.bp3-active{background-color:#d9822b}.jupyter-wrapper .bp3-menu-item.bp3-intent-warning:active{background-color:#bf7326}.jupyter-wrapper .bp3-menu-item.bp3-intent-warning:hover,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-warning.bp3-menu-item,.jupyter-wrapper .bp3-menu-item.bp3-intent-warning:hover::before,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-warning.bp3-menu-item::before,.jupyter-wrapper .bp3-menu-item.bp3-intent-warning:hover::after,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-warning.bp3-menu-item::after,.jupyter-wrapper .bp3-menu-item.bp3-intent-warning:hover .bp3-menu-item-label,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-warning.bp3-menu-item .bp3-menu-item-label,.jupyter-wrapper .bp3-menu-item.bp3-intent-warning:active,.jupyter-wrapper .bp3-menu-item.bp3-intent-warning:active::before,.jupyter-wrapper .bp3-menu-item.bp3-intent-warning:active::after,.jupyter-wrapper .bp3-menu-item.bp3-intent-warning:active .bp3-menu-item-label,.jupyter-wrapper .bp3-menu-item.bp3-intent-warning.bp3-active,.jupyter-wrapper .bp3-menu-item.bp3-intent-warning.bp3-active::before,.jupyter-wrapper .bp3-menu-item.bp3-intent-warning.bp3-active::after,.jupyter-wrapper .bp3-menu-item.bp3-intent-warning.bp3-active .bp3-menu-item-label{color:#fff}.jupyter-wrapper .bp3-menu-item.bp3-intent-danger{color:#c23030}.jupyter-wrapper .bp3-menu-item.bp3-intent-danger .bp3-icon{color:inherit}.jupyter-wrapper .bp3-menu-item.bp3-intent-danger::before,.jupyter-wrapper .bp3-menu-item.bp3-intent-danger::after,.jupyter-wrapper .bp3-menu-item.bp3-intent-danger .bp3-menu-item-label{color:#c23030}.jupyter-wrapper .bp3-menu-item.bp3-intent-danger:hover,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-danger.bp3-menu-item,.jupyter-wrapper .bp3-menu-item.bp3-intent-danger.bp3-active{background-color:#db3737}.jupyter-wrapper .bp3-menu-item.bp3-intent-danger:active{background-color:#c23030}.jupyter-wrapper .bp3-menu-item.bp3-intent-danger:hover,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-danger.bp3-menu-item,.jupyter-wrapper .bp3-menu-item.bp3-intent-danger:hover::before,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-danger.bp3-menu-item::before,.jupyter-wrapper .bp3-menu-item.bp3-intent-danger:hover::after,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-danger.bp3-menu-item::after,.jupyter-wrapper .bp3-menu-item.bp3-intent-danger:hover .bp3-menu-item-label,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-danger.bp3-menu-item .bp3-menu-item-label,.jupyter-wrapper .bp3-menu-item.bp3-intent-danger:active,.jupyter-wrapper .bp3-menu-item.bp3-intent-danger:active::before,.jupyter-wrapper .bp3-menu-item.bp3-intent-danger:active::after,.jupyter-wrapper .bp3-menu-item.bp3-intent-danger:active .bp3-menu-item-label,.jupyter-wrapper .bp3-menu-item.bp3-intent-danger.bp3-active,.jupyter-wrapper .bp3-menu-item.bp3-intent-danger.bp3-active::before,.jupyter-wrapper .bp3-menu-item.bp3-intent-danger.bp3-active::after,.jupyter-wrapper .bp3-menu-item.bp3-intent-danger.bp3-active .bp3-menu-item-label{color:#fff}.jupyter-wrapper .bp3-menu-item::before{line-height:1;font-family:\"Icons16\",sans-serif;font-size:16px;font-weight:400;font-style:normal;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-right:7px}.jupyter-wrapper .bp3-menu-item::before,.jupyter-wrapper .bp3-menu-item>.bp3-icon{margin-top:2px;color:#5c7080}.jupyter-wrapper .bp3-menu-item .bp3-menu-item-label{color:#5c7080}.jupyter-wrapper .bp3-menu-item:hover,.jupyter-wrapper .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-menu-item{color:inherit}.jupyter-wrapper .bp3-menu-item.bp3-active,.jupyter-wrapper .bp3-menu-item:active{background-color:rgba(115,134,148,.3)}.jupyter-wrapper .bp3-menu-item.bp3-disabled{outline:none !important;background-color:inherit !important;cursor:not-allowed !important;color:rgba(92,112,128,.6) !important}.jupyter-wrapper .bp3-menu-item.bp3-disabled::before,.jupyter-wrapper .bp3-menu-item.bp3-disabled>.bp3-icon,.jupyter-wrapper .bp3-menu-item.bp3-disabled .bp3-menu-item-label{color:rgba(92,112,128,.6) !important}.jupyter-wrapper .bp3-large .bp3-menu-item{padding:9px 7px;line-height:22px;font-size:16px}.jupyter-wrapper .bp3-large .bp3-menu-item .bp3-icon{margin-top:3px}.jupyter-wrapper .bp3-large .bp3-menu-item::before{line-height:1;font-family:\"Icons20\",sans-serif;font-size:20px;font-weight:400;font-style:normal;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-top:1px;margin-right:10px}.jupyter-wrapper button.bp3-menu-item{border:none;background:none;width:100%;text-align:left}.jupyter-wrapper .bp3-menu-header{display:block;margin:5px;border-top:1px solid rgba(16,22,26,.15);cursor:default;padding-left:2px}.jupyter-wrapper .bp3-dark .bp3-menu-header{border-top-color:rgba(255,255,255,.15)}.jupyter-wrapper .bp3-menu-header:first-of-type{border-top:none}.jupyter-wrapper .bp3-menu-header>h6{color:#182026;font-weight:600;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-wrap:normal;margin:0;padding:10px 7px 0 1px;line-height:17px}.jupyter-wrapper .bp3-dark .bp3-menu-header>h6{color:#f5f8fa}.jupyter-wrapper .bp3-menu-header:first-of-type>h6{padding-top:0}.jupyter-wrapper .bp3-large .bp3-menu-header>h6{padding-top:15px;padding-bottom:5px;font-size:18px}.jupyter-wrapper .bp3-large .bp3-menu-header:first-of-type>h6{padding-top:0}.jupyter-wrapper .bp3-dark .bp3-menu{background:#30404d;color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary{color:#48aff0}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary .bp3-icon{color:inherit}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary::before,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary::after,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary .bp3-menu-item-label{color:#48aff0}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary:hover,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-primary.bp3-menu-item,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-primary.bp3-menu-item,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary.bp3-active{background-color:#137cbd}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary:active{background-color:#106ba3}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary:hover,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-primary.bp3-menu-item,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-primary.bp3-menu-item,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary:hover::before,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-primary.bp3-menu-item::before,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-primary.bp3-menu-item::before,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary:hover::after,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-primary.bp3-menu-item::after,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-primary.bp3-menu-item::after,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary:hover .bp3-menu-item-label,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-primary.bp3-menu-item .bp3-menu-item-label,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-primary.bp3-menu-item .bp3-menu-item-label,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary:active,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary:active::before,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary:active::after,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary:active .bp3-menu-item-label,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary.bp3-active,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary.bp3-active::before,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary.bp3-active::after,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-primary.bp3-active .bp3-menu-item-label{color:#fff}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success{color:#3dcc91}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success .bp3-icon{color:inherit}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success::before,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success::after,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success .bp3-menu-item-label{color:#3dcc91}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success:hover,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-success.bp3-menu-item,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-success.bp3-menu-item,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success.bp3-active{background-color:#0f9960}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success:active{background-color:#0d8050}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success:hover,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-success.bp3-menu-item,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-success.bp3-menu-item,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success:hover::before,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-success.bp3-menu-item::before,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-success.bp3-menu-item::before,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success:hover::after,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-success.bp3-menu-item::after,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-success.bp3-menu-item::after,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success:hover .bp3-menu-item-label,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-success.bp3-menu-item .bp3-menu-item-label,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-success.bp3-menu-item .bp3-menu-item-label,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success:active,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success:active::before,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success:active::after,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success:active .bp3-menu-item-label,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success.bp3-active,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success.bp3-active::before,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success.bp3-active::after,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-success.bp3-active .bp3-menu-item-label{color:#fff}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning{color:#ffb366}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning .bp3-icon{color:inherit}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning::before,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning::after,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning .bp3-menu-item-label{color:#ffb366}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning:hover,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-warning.bp3-menu-item,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-warning.bp3-menu-item,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning.bp3-active{background-color:#d9822b}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning:active{background-color:#bf7326}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning:hover,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-warning.bp3-menu-item,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-warning.bp3-menu-item,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning:hover::before,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-warning.bp3-menu-item::before,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-warning.bp3-menu-item::before,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning:hover::after,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-warning.bp3-menu-item::after,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-warning.bp3-menu-item::after,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning:hover .bp3-menu-item-label,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-warning.bp3-menu-item .bp3-menu-item-label,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-warning.bp3-menu-item .bp3-menu-item-label,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning:active,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning:active::before,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning:active::after,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning:active .bp3-menu-item-label,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning.bp3-active,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning.bp3-active::before,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning.bp3-active::after,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-warning.bp3-active .bp3-menu-item-label{color:#fff}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger{color:#ff7373}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger .bp3-icon{color:inherit}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger::before,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger::after,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger .bp3-menu-item-label{color:#ff7373}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger:hover,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-danger.bp3-menu-item,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-danger.bp3-menu-item,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger.bp3-active{background-color:#db3737}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger:active{background-color:#c23030}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger:hover,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-danger.bp3-menu-item,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-danger.bp3-menu-item,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger:hover::before,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-danger.bp3-menu-item::before,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-danger.bp3-menu-item::before,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger:hover::after,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-danger.bp3-menu-item::after,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-danger.bp3-menu-item::after,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger:hover .bp3-menu-item-label,.jupyter-wrapper .bp3-dark .bp3-submenu .bp3-popover-target.bp3-popover-open>.bp3-intent-danger.bp3-menu-item .bp3-menu-item-label,.jupyter-wrapper .bp3-submenu .bp3-dark .bp3-popover-target.bp3-popover-open>.bp3-intent-danger.bp3-menu-item .bp3-menu-item-label,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger:active,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger:active::before,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger:active::after,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger:active .bp3-menu-item-label,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger.bp3-active,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger.bp3-active::before,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger.bp3-active::after,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-intent-danger.bp3-active .bp3-menu-item-label{color:#fff}.jupyter-wrapper .bp3-dark .bp3-menu-item::before,.jupyter-wrapper .bp3-dark .bp3-menu-item>.bp3-icon{color:#a7b6c2}.jupyter-wrapper .bp3-dark .bp3-menu-item .bp3-menu-item-label{color:#a7b6c2}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-active,.jupyter-wrapper .bp3-dark .bp3-menu-item:active{background-color:rgba(138,155,168,.3)}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-disabled{color:rgba(167,182,194,.6) !important}.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-disabled::before,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-disabled>.bp3-icon,.jupyter-wrapper .bp3-dark .bp3-menu-item.bp3-disabled .bp3-menu-item-label{color:rgba(167,182,194,.6) !important}.jupyter-wrapper .bp3-dark .bp3-menu-divider,.jupyter-wrapper .bp3-dark .bp3-menu-header{border-color:rgba(255,255,255,.15)}.jupyter-wrapper .bp3-dark .bp3-menu-header>h6{color:#f5f8fa}.jupyter-wrapper .bp3-label .bp3-menu{margin-top:5px}.jupyter-wrapper .bp3-navbar{position:relative;z-index:10;-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.1),0 0 0 rgba(16,22,26,0),0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.1),0 0 0 rgba(16,22,26,0),0 1px 1px rgba(16,22,26,.2);background-color:#fff;width:100%;height:50px;padding:0 15px}.jupyter-wrapper .bp3-navbar.bp3-dark,.jupyter-wrapper .bp3-dark .bp3-navbar{background-color:#394b59}.jupyter-wrapper .bp3-navbar.bp3-dark{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),0 0 0 rgba(16,22,26,0),0 1px 1px rgba(16,22,26,.4);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),0 0 0 rgba(16,22,26,0),0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-navbar{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),0 0 0 rgba(16,22,26,0),0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.2),0 0 0 rgba(16,22,26,0),0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-navbar.bp3-fixed-top{position:fixed;top:0;right:0;left:0}.jupyter-wrapper .bp3-navbar-heading{margin-right:15px;font-size:16px}.jupyter-wrapper .bp3-navbar-group{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:50px}.jupyter-wrapper .bp3-navbar-group.bp3-align-left{float:left}.jupyter-wrapper .bp3-navbar-group.bp3-align-right{float:right}.jupyter-wrapper .bp3-navbar-divider{margin:0 10px;border-left:1px solid rgba(16,22,26,.15);height:20px}.jupyter-wrapper .bp3-dark .bp3-navbar-divider{border-left-color:rgba(255,255,255,.15)}.jupyter-wrapper .bp3-non-ideal-state{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;text-align:center}.jupyter-wrapper .bp3-non-ideal-state>*{-webkit-box-flex:0;-ms-flex-positive:0;flex-grow:0;-ms-flex-negative:0;flex-shrink:0}.jupyter-wrapper .bp3-non-ideal-state>.bp3-fill{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-negative:1;flex-shrink:1}.jupyter-wrapper .bp3-non-ideal-state::before,.jupyter-wrapper .bp3-non-ideal-state>*{margin-bottom:20px}.jupyter-wrapper .bp3-non-ideal-state:empty::before,.jupyter-wrapper .bp3-non-ideal-state>:last-child{margin-bottom:0}.jupyter-wrapper .bp3-non-ideal-state>*{max-width:400px}.jupyter-wrapper .bp3-non-ideal-state-visual{color:rgba(92,112,128,.6);font-size:60px}.jupyter-wrapper .bp3-dark .bp3-non-ideal-state-visual{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-overflow-list{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-wrap:nowrap;flex-wrap:nowrap;min-width:0}.jupyter-wrapper .bp3-overflow-list-spacer{-ms-flex-negative:1;flex-shrink:1;width:1px}.jupyter-wrapper body.bp3-overlay-open{overflow:hidden}.jupyter-wrapper .bp3-overlay{position:static;top:0;right:0;bottom:0;left:0;z-index:20}.jupyter-wrapper .bp3-overlay:not(.bp3-overlay-open){pointer-events:none}.jupyter-wrapper .bp3-overlay.bp3-overlay-container{position:fixed;overflow:hidden}.jupyter-wrapper .bp3-overlay.bp3-overlay-container.bp3-overlay-inline{position:absolute}.jupyter-wrapper .bp3-overlay.bp3-overlay-scroll-container{position:fixed;overflow:auto}.jupyter-wrapper .bp3-overlay.bp3-overlay-scroll-container.bp3-overlay-inline{position:absolute}.jupyter-wrapper .bp3-overlay.bp3-overlay-inline{display:inline;overflow:visible}.jupyter-wrapper .bp3-overlay-content{position:fixed;z-index:20}.jupyter-wrapper .bp3-overlay-inline .bp3-overlay-content,.jupyter-wrapper .bp3-overlay-scroll-container .bp3-overlay-content{position:absolute}.jupyter-wrapper .bp3-overlay-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;opacity:1;z-index:20;background-color:rgba(16,22,26,.7);overflow:auto;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.jupyter-wrapper .bp3-overlay-backdrop.bp3-overlay-enter,.jupyter-wrapper .bp3-overlay-backdrop.bp3-overlay-appear{opacity:0}.jupyter-wrapper .bp3-overlay-backdrop.bp3-overlay-enter-active,.jupyter-wrapper .bp3-overlay-backdrop.bp3-overlay-appear-active{opacity:1;-webkit-transition-property:opacity;transition-property:opacity;-webkit-transition-duration:200ms;transition-duration:200ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-overlay-backdrop.bp3-overlay-exit{opacity:1}.jupyter-wrapper .bp3-overlay-backdrop.bp3-overlay-exit-active{opacity:0;-webkit-transition-property:opacity;transition-property:opacity;-webkit-transition-duration:200ms;transition-duration:200ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-overlay-backdrop:focus{outline:none}.jupyter-wrapper .bp3-overlay-inline .bp3-overlay-backdrop{position:absolute}.jupyter-wrapper .bp3-panel-stack{position:relative;overflow:hidden}.jupyter-wrapper .bp3-panel-stack-header{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-negative:0;flex-shrink:0;-webkit-box-align:center;-ms-flex-align:center;align-items:center;z-index:1;-webkit-box-shadow:0 1px rgba(16,22,26,.15);box-shadow:0 1px rgba(16,22,26,.15);height:30px}.jupyter-wrapper .bp3-dark .bp3-panel-stack-header{-webkit-box-shadow:0 1px rgba(255,255,255,.15);box-shadow:0 1px rgba(255,255,255,.15)}.jupyter-wrapper .bp3-panel-stack-header>span{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-ms-flex:1;flex:1;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch}.jupyter-wrapper .bp3-panel-stack-header .bp3-heading{margin:0 5px}.jupyter-wrapper .bp3-button.bp3-panel-stack-header-back{margin-left:5px;padding-left:0;white-space:nowrap}.jupyter-wrapper .bp3-button.bp3-panel-stack-header-back .bp3-icon{margin:0 2px}.jupyter-wrapper .bp3-panel-stack-view{position:absolute;top:0;right:0;bottom:0;left:0;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;margin-right:-1px;border-right:1px solid rgba(16,22,26,.15);background-color:#fff;overflow-y:auto}.jupyter-wrapper .bp3-dark .bp3-panel-stack-view{background-color:#30404d}.jupyter-wrapper .bp3-panel-stack-push .bp3-panel-stack-enter,.jupyter-wrapper .bp3-panel-stack-push .bp3-panel-stack-appear{-webkit-transform:translateX(100%);transform:translateX(100%);opacity:0}.jupyter-wrapper .bp3-panel-stack-push .bp3-panel-stack-enter-active,.jupyter-wrapper .bp3-panel-stack-push .bp3-panel-stack-appear-active{-webkit-transform:translate(0%);transform:translate(0%);opacity:1;-webkit-transition-property:opacity,-webkit-transform;transition-property:opacity,-webkit-transform;transition-property:transform,opacity;transition-property:transform,opacity,-webkit-transform;-webkit-transition-duration:400ms;transition-duration:400ms;-webkit-transition-timing-function:ease;transition-timing-function:ease;-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-panel-stack-push .bp3-panel-stack-exit{-webkit-transform:translate(0%);transform:translate(0%);opacity:1}.jupyter-wrapper .bp3-panel-stack-push .bp3-panel-stack-exit-active{-webkit-transform:translateX(-50%);transform:translateX(-50%);opacity:0;-webkit-transition-property:opacity,-webkit-transform;transition-property:opacity,-webkit-transform;transition-property:transform,opacity;transition-property:transform,opacity,-webkit-transform;-webkit-transition-duration:400ms;transition-duration:400ms;-webkit-transition-timing-function:ease;transition-timing-function:ease;-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-panel-stack-pop .bp3-panel-stack-enter,.jupyter-wrapper .bp3-panel-stack-pop .bp3-panel-stack-appear{-webkit-transform:translateX(-50%);transform:translateX(-50%);opacity:0}.jupyter-wrapper .bp3-panel-stack-pop .bp3-panel-stack-enter-active,.jupyter-wrapper .bp3-panel-stack-pop .bp3-panel-stack-appear-active{-webkit-transform:translate(0%);transform:translate(0%);opacity:1;-webkit-transition-property:opacity,-webkit-transform;transition-property:opacity,-webkit-transform;transition-property:transform,opacity;transition-property:transform,opacity,-webkit-transform;-webkit-transition-duration:400ms;transition-duration:400ms;-webkit-transition-timing-function:ease;transition-timing-function:ease;-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-panel-stack-pop .bp3-panel-stack-exit{-webkit-transform:translate(0%);transform:translate(0%);opacity:1}.jupyter-wrapper .bp3-panel-stack-pop .bp3-panel-stack-exit-active{-webkit-transform:translateX(100%);transform:translateX(100%);opacity:0;-webkit-transition-property:opacity,-webkit-transform;transition-property:opacity,-webkit-transform;transition-property:transform,opacity;transition-property:transform,opacity,-webkit-transform;-webkit-transition-duration:400ms;transition-duration:400ms;-webkit-transition-timing-function:ease;transition-timing-function:ease;-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-popover{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.1),0 2px 4px rgba(16,22,26,.2),0 8px 24px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.1),0 2px 4px rgba(16,22,26,.2),0 8px 24px rgba(16,22,26,.2);-webkit-transform:scale(1);transform:scale(1);display:inline-block;z-index:20;border-radius:3px}.jupyter-wrapper .bp3-popover .bp3-popover-arrow{position:absolute;width:30px;height:30px}.jupyter-wrapper .bp3-popover .bp3-popover-arrow::before{margin:5px;width:20px;height:20px}.jupyter-wrapper .bp3-tether-element-attached-bottom.bp3-tether-target-attached-top>.bp3-popover{margin-top:-17px;margin-bottom:17px}.jupyter-wrapper .bp3-tether-element-attached-bottom.bp3-tether-target-attached-top>.bp3-popover>.bp3-popover-arrow{bottom:-11px}.jupyter-wrapper .bp3-tether-element-attached-bottom.bp3-tether-target-attached-top>.bp3-popover>.bp3-popover-arrow svg{-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.jupyter-wrapper .bp3-tether-element-attached-left.bp3-tether-target-attached-right>.bp3-popover{margin-left:17px}.jupyter-wrapper .bp3-tether-element-attached-left.bp3-tether-target-attached-right>.bp3-popover>.bp3-popover-arrow{left:-11px}.jupyter-wrapper .bp3-tether-element-attached-left.bp3-tether-target-attached-right>.bp3-popover>.bp3-popover-arrow svg{-webkit-transform:rotate(0);transform:rotate(0)}.jupyter-wrapper .bp3-tether-element-attached-top.bp3-tether-target-attached-bottom>.bp3-popover{margin-top:17px}.jupyter-wrapper .bp3-tether-element-attached-top.bp3-tether-target-attached-bottom>.bp3-popover>.bp3-popover-arrow{top:-11px}.jupyter-wrapper .bp3-tether-element-attached-top.bp3-tether-target-attached-bottom>.bp3-popover>.bp3-popover-arrow svg{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.jupyter-wrapper .bp3-tether-element-attached-right.bp3-tether-target-attached-left>.bp3-popover{margin-right:17px;margin-left:-17px}.jupyter-wrapper .bp3-tether-element-attached-right.bp3-tether-target-attached-left>.bp3-popover>.bp3-popover-arrow{right:-11px}.jupyter-wrapper .bp3-tether-element-attached-right.bp3-tether-target-attached-left>.bp3-popover>.bp3-popover-arrow svg{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.jupyter-wrapper .bp3-tether-element-attached-middle>.bp3-popover>.bp3-popover-arrow{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.jupyter-wrapper .bp3-tether-element-attached-center>.bp3-popover>.bp3-popover-arrow{right:50%;-webkit-transform:translateX(50%);transform:translateX(50%)}.jupyter-wrapper .bp3-tether-element-attached-top.bp3-tether-target-attached-top>.bp3-popover>.bp3-popover-arrow{top:-0.3934px}.jupyter-wrapper .bp3-tether-element-attached-right.bp3-tether-target-attached-right>.bp3-popover>.bp3-popover-arrow{right:-0.3934px}.jupyter-wrapper .bp3-tether-element-attached-left.bp3-tether-target-attached-left>.bp3-popover>.bp3-popover-arrow{left:-0.3934px}.jupyter-wrapper .bp3-tether-element-attached-bottom.bp3-tether-target-attached-bottom>.bp3-popover>.bp3-popover-arrow{bottom:-0.3934px}.jupyter-wrapper .bp3-tether-element-attached-top.bp3-tether-element-attached-left>.bp3-popover{-webkit-transform-origin:top left;transform-origin:top left}.jupyter-wrapper .bp3-tether-element-attached-top.bp3-tether-element-attached-center>.bp3-popover{-webkit-transform-origin:top center;transform-origin:top center}.jupyter-wrapper .bp3-tether-element-attached-top.bp3-tether-element-attached-right>.bp3-popover{-webkit-transform-origin:top right;transform-origin:top right}.jupyter-wrapper .bp3-tether-element-attached-middle.bp3-tether-element-attached-left>.bp3-popover{-webkit-transform-origin:center left;transform-origin:center left}.jupyter-wrapper .bp3-tether-element-attached-middle.bp3-tether-element-attached-center>.bp3-popover{-webkit-transform-origin:center center;transform-origin:center center}.jupyter-wrapper .bp3-tether-element-attached-middle.bp3-tether-element-attached-right>.bp3-popover{-webkit-transform-origin:center right;transform-origin:center right}.jupyter-wrapper .bp3-tether-element-attached-bottom.bp3-tether-element-attached-left>.bp3-popover{-webkit-transform-origin:bottom left;transform-origin:bottom left}.jupyter-wrapper .bp3-tether-element-attached-bottom.bp3-tether-element-attached-center>.bp3-popover{-webkit-transform-origin:bottom center;transform-origin:bottom center}.jupyter-wrapper .bp3-tether-element-attached-bottom.bp3-tether-element-attached-right>.bp3-popover{-webkit-transform-origin:bottom right;transform-origin:bottom right}.jupyter-wrapper .bp3-popover .bp3-popover-content{background:#fff;color:inherit}.jupyter-wrapper .bp3-popover .bp3-popover-arrow::before{-webkit-box-shadow:1px 1px 6px rgba(16,22,26,.2);box-shadow:1px 1px 6px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-popover .bp3-popover-arrow-border{fill:#10161a;fill-opacity:.1}.jupyter-wrapper .bp3-popover .bp3-popover-arrow-fill{fill:#fff}.jupyter-wrapper .bp3-popover-enter>.bp3-popover,.jupyter-wrapper .bp3-popover-appear>.bp3-popover{-webkit-transform:scale(0.3);transform:scale(0.3)}.jupyter-wrapper .bp3-popover-enter-active>.bp3-popover,.jupyter-wrapper .bp3-popover-appear-active>.bp3-popover{-webkit-transform:scale(1);transform:scale(1);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:300ms;transition-duration:300ms;-webkit-transition-timing-function:cubic-bezier(0.54, 1.12, 0.38, 1.11);transition-timing-function:cubic-bezier(0.54, 1.12, 0.38, 1.11);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-popover-exit>.bp3-popover{-webkit-transform:scale(1);transform:scale(1)}.jupyter-wrapper .bp3-popover-exit-active>.bp3-popover{-webkit-transform:scale(0.3);transform:scale(0.3);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:300ms;transition-duration:300ms;-webkit-transition-timing-function:cubic-bezier(0.54, 1.12, 0.38, 1.11);transition-timing-function:cubic-bezier(0.54, 1.12, 0.38, 1.11);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-popover .bp3-popover-content{position:relative;border-radius:3px}.jupyter-wrapper .bp3-popover.bp3-popover-content-sizing .bp3-popover-content{max-width:350px;padding:20px}.jupyter-wrapper .bp3-popover-target+.bp3-overlay .bp3-popover.bp3-popover-content-sizing{width:350px}.jupyter-wrapper .bp3-popover.bp3-minimal{margin:0 !important}.jupyter-wrapper .bp3-popover.bp3-minimal .bp3-popover-arrow{display:none}.jupyter-wrapper .bp3-popover.bp3-minimal.bp3-popover{-webkit-transform:scale(1);transform:scale(1)}.jupyter-wrapper .bp3-popover-enter>.bp3-popover.bp3-minimal.bp3-popover,.jupyter-wrapper .bp3-popover-appear>.bp3-popover.bp3-minimal.bp3-popover{-webkit-transform:scale(1);transform:scale(1)}.jupyter-wrapper .bp3-popover-enter-active>.bp3-popover.bp3-minimal.bp3-popover,.jupyter-wrapper .bp3-popover-appear-active>.bp3-popover.bp3-minimal.bp3-popover{-webkit-transform:scale(1);transform:scale(1);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:100ms;transition-duration:100ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-popover-exit>.bp3-popover.bp3-minimal.bp3-popover{-webkit-transform:scale(1);transform:scale(1)}.jupyter-wrapper .bp3-popover-exit-active>.bp3-popover.bp3-minimal.bp3-popover{-webkit-transform:scale(1);transform:scale(1);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:100ms;transition-duration:100ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-popover.bp3-dark,.jupyter-wrapper .bp3-dark .bp3-popover{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),0 2px 4px rgba(16,22,26,.4),0 8px 24px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.2),0 2px 4px rgba(16,22,26,.4),0 8px 24px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-popover.bp3-dark .bp3-popover-content,.jupyter-wrapper .bp3-dark .bp3-popover .bp3-popover-content{background:#30404d;color:inherit}.jupyter-wrapper .bp3-popover.bp3-dark .bp3-popover-arrow::before,.jupyter-wrapper .bp3-dark .bp3-popover .bp3-popover-arrow::before{-webkit-box-shadow:1px 1px 6px rgba(16,22,26,.4);box-shadow:1px 1px 6px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-popover.bp3-dark .bp3-popover-arrow-border,.jupyter-wrapper .bp3-dark .bp3-popover .bp3-popover-arrow-border{fill:#10161a;fill-opacity:.2}.jupyter-wrapper .bp3-popover.bp3-dark .bp3-popover-arrow-fill,.jupyter-wrapper .bp3-dark .bp3-popover .bp3-popover-arrow-fill{fill:#30404d}.jupyter-wrapper .bp3-popover-arrow::before{display:block;position:absolute;-webkit-transform:rotate(45deg);transform:rotate(45deg);border-radius:2px;content:\"\"}.jupyter-wrapper .bp3-tether-pinned .bp3-popover-arrow{display:none}.jupyter-wrapper .bp3-popover-backdrop{background:rgba(255,255,255,0)}.jupyter-wrapper .bp3-transition-container{opacity:1;display:-webkit-box;display:-ms-flexbox;display:flex;z-index:20}.jupyter-wrapper .bp3-transition-container.bp3-popover-enter,.jupyter-wrapper .bp3-transition-container.bp3-popover-appear{opacity:0}.jupyter-wrapper .bp3-transition-container.bp3-popover-enter-active,.jupyter-wrapper .bp3-transition-container.bp3-popover-appear-active{opacity:1;-webkit-transition-property:opacity;transition-property:opacity;-webkit-transition-duration:100ms;transition-duration:100ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-transition-container.bp3-popover-exit{opacity:1}.jupyter-wrapper .bp3-transition-container.bp3-popover-exit-active{opacity:0;-webkit-transition-property:opacity;transition-property:opacity;-webkit-transition-duration:100ms;transition-duration:100ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-transition-container:focus{outline:none}.jupyter-wrapper .bp3-transition-container.bp3-popover-leave .bp3-popover-content{pointer-events:none}.jupyter-wrapper .bp3-transition-container[data-x-out-of-boundaries]{display:none}.jupyter-wrapper span.bp3-popover-target{display:inline-block}.jupyter-wrapper .bp3-popover-wrapper.bp3-fill{width:100%}.jupyter-wrapper .bp3-portal{position:absolute;top:0;right:0;left:0}@-webkit-keyframes linear-progress-bar-stripes{from{background-position:0 0}to{background-position:30px 0}}@keyframes linear-progress-bar-stripes{from{background-position:0 0}to{background-position:30px 0}}.jupyter-wrapper .bp3-progress-bar{display:block;position:relative;border-radius:40px;background:rgba(92,112,128,.2);width:100%;height:8px;overflow:hidden}.jupyter-wrapper .bp3-progress-bar .bp3-progress-meter{position:absolute;border-radius:40px;background:linear-gradient(-45deg, rgba(255, 255, 255, 0.2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.2) 50%, rgba(255, 255, 255, 0.2) 75%, transparent 75%);background-color:rgba(92,112,128,.8);background-size:30px 30px;width:100%;height:100%;-webkit-transition:width 200ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:width 200ms cubic-bezier(0.4, 1, 0.75, 0.9)}.jupyter-wrapper .bp3-progress-bar:not(.bp3-no-animation):not(.bp3-no-stripes) .bp3-progress-meter{animation:linear-progress-bar-stripes 300ms linear infinite reverse}.jupyter-wrapper .bp3-progress-bar.bp3-no-stripes .bp3-progress-meter{background-image:none}.jupyter-wrapper .bp3-dark .bp3-progress-bar{background:rgba(16,22,26,.5)}.jupyter-wrapper .bp3-dark .bp3-progress-bar .bp3-progress-meter{background-color:#8a9ba8}.jupyter-wrapper .bp3-progress-bar.bp3-intent-primary .bp3-progress-meter{background-color:#137cbd}.jupyter-wrapper .bp3-progress-bar.bp3-intent-success .bp3-progress-meter{background-color:#0f9960}.jupyter-wrapper .bp3-progress-bar.bp3-intent-warning .bp3-progress-meter{background-color:#d9822b}.jupyter-wrapper .bp3-progress-bar.bp3-intent-danger .bp3-progress-meter{background-color:#db3737}@-webkit-keyframes skeleton-glow{from{border-color:rgba(206,217,224,.2);background:rgba(206,217,224,.2)}to{border-color:rgba(92,112,128,.2);background:rgba(92,112,128,.2)}}@keyframes skeleton-glow{from{border-color:rgba(206,217,224,.2);background:rgba(206,217,224,.2)}to{border-color:rgba(92,112,128,.2);background:rgba(92,112,128,.2)}}.jupyter-wrapper .bp3-skeleton{border-color:rgba(206,217,224,.2) !important;border-radius:2px;-webkit-box-shadow:none !important;box-shadow:none !important;background:rgba(206,217,224,.2);background-clip:padding-box !important;cursor:default;color:transparent !important;-webkit-animation:1000ms linear infinite alternate skeleton-glow;animation:1000ms linear infinite alternate skeleton-glow;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.jupyter-wrapper .bp3-skeleton::before,.jupyter-wrapper .bp3-skeleton::after,.jupyter-wrapper .bp3-skeleton *{visibility:hidden !important}.jupyter-wrapper .bp3-slider{width:100%;min-width:150px;height:40px;position:relative;outline:none;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.jupyter-wrapper .bp3-slider:hover{cursor:pointer}.jupyter-wrapper .bp3-slider:active{cursor:-webkit-grabbing;cursor:grabbing}.jupyter-wrapper .bp3-slider.bp3-disabled{opacity:.5;cursor:not-allowed}.jupyter-wrapper .bp3-slider.bp3-slider-unlabeled{height:16px}.jupyter-wrapper .bp3-slider-track,.jupyter-wrapper .bp3-slider-progress{top:5px;right:0;left:0;height:6px;position:absolute}.jupyter-wrapper .bp3-slider-track{border-radius:3px;overflow:hidden}.jupyter-wrapper .bp3-slider-progress{background:rgba(92,112,128,.2)}.jupyter-wrapper .bp3-dark .bp3-slider-progress{background:rgba(16,22,26,.5)}.jupyter-wrapper .bp3-slider-progress.bp3-intent-primary{background-color:#137cbd}.jupyter-wrapper .bp3-slider-progress.bp3-intent-success{background-color:#0f9960}.jupyter-wrapper .bp3-slider-progress.bp3-intent-warning{background-color:#d9822b}.jupyter-wrapper .bp3-slider-progress.bp3-intent-danger{background-color:#db3737}.jupyter-wrapper .bp3-slider-handle{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);background-color:#f5f8fa;background-image:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0.8)), to(rgba(255, 255, 255, 0)));background-image:linear-gradient(to bottom, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0));color:#182026;position:absolute;top:0;left:0;border-radius:3px;-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.2),0 1px 1px rgba(16,22,26,.2);cursor:pointer;width:16px;height:16px}.jupyter-wrapper .bp3-slider-handle:hover{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);background-clip:padding-box;background-color:#ebf1f5}.jupyter-wrapper .bp3-slider-handle:active,.jupyter-wrapper .bp3-slider-handle.bp3-active{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 1px 2px rgba(16,22,26,.2);background-color:#d8e1e8;background-image:none}.jupyter-wrapper .bp3-slider-handle:disabled,.jupyter-wrapper .bp3-slider-handle.bp3-disabled{outline:none;-webkit-box-shadow:none;box-shadow:none;background-color:rgba(206,217,224,.5);background-image:none;cursor:not-allowed;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-slider-handle:disabled.bp3-active,.jupyter-wrapper .bp3-slider-handle:disabled.bp3-active:hover,.jupyter-wrapper .bp3-slider-handle.bp3-disabled.bp3-active,.jupyter-wrapper .bp3-slider-handle.bp3-disabled.bp3-active:hover{background:rgba(206,217,224,.7)}.jupyter-wrapper .bp3-slider-handle:focus{z-index:1}.jupyter-wrapper .bp3-slider-handle:hover{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 -1px 0 rgba(16,22,26,.1);background-clip:padding-box;background-color:#ebf1f5;z-index:2;-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.2),0 1px 1px rgba(16,22,26,.2);cursor:-webkit-grab;cursor:grab}.jupyter-wrapper .bp3-slider-handle.bp3-active{-webkit-box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:inset 0 0 0 1px rgba(16,22,26,.2),inset 0 1px 2px rgba(16,22,26,.2);background-color:#d8e1e8;background-image:none;-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),inset 0 1px 1px rgba(16,22,26,.1);box-shadow:0 0 0 1px rgba(16,22,26,.2),inset 0 1px 1px rgba(16,22,26,.1);cursor:-webkit-grabbing;cursor:grabbing}.jupyter-wrapper .bp3-disabled .bp3-slider-handle{-webkit-box-shadow:none;box-shadow:none;background:#bfccd6;pointer-events:none}.jupyter-wrapper .bp3-dark .bp3-slider-handle{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.4);background-color:#394b59;background-image:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0.05)), to(rgba(255, 255, 255, 0)));background-image:linear-gradient(to bottom, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0));color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-slider-handle:hover,.jupyter-wrapper .bp3-dark .bp3-slider-handle:active,.jupyter-wrapper .bp3-dark .bp3-slider-handle.bp3-active{color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-slider-handle:hover{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.4);background-color:#30404d}.jupyter-wrapper .bp3-dark .bp3-slider-handle:active,.jupyter-wrapper .bp3-dark .bp3-slider-handle.bp3-active{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.6),inset 0 1px 2px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.6),inset 0 1px 2px rgba(16,22,26,.2);background-color:#202b33;background-image:none}.jupyter-wrapper .bp3-dark .bp3-slider-handle:disabled,.jupyter-wrapper .bp3-dark .bp3-slider-handle.bp3-disabled{-webkit-box-shadow:none;box-shadow:none;background-color:rgba(57,75,89,.5);background-image:none;color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-slider-handle:disabled.bp3-active,.jupyter-wrapper .bp3-dark .bp3-slider-handle.bp3-disabled.bp3-active{background:rgba(57,75,89,.7)}.jupyter-wrapper .bp3-dark .bp3-slider-handle .bp3-button-spinner .bp3-spinner-head{background:rgba(16,22,26,.5);stroke:#8a9ba8}.jupyter-wrapper .bp3-dark .bp3-slider-handle,.jupyter-wrapper .bp3-dark .bp3-slider-handle:hover{background-color:#394b59}.jupyter-wrapper .bp3-dark .bp3-slider-handle.bp3-active{background-color:#293742}.jupyter-wrapper .bp3-dark .bp3-disabled .bp3-slider-handle{border-color:#5c7080;-webkit-box-shadow:none;box-shadow:none;background:#5c7080}.jupyter-wrapper .bp3-slider-handle .bp3-slider-label{margin-left:8px;border-radius:3px;-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.1),0 2px 4px rgba(16,22,26,.2),0 8px 24px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.1),0 2px 4px rgba(16,22,26,.2),0 8px 24px rgba(16,22,26,.2);background:#394b59;color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-slider-handle .bp3-slider-label{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),0 2px 4px rgba(16,22,26,.4),0 8px 24px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.2),0 2px 4px rgba(16,22,26,.4),0 8px 24px rgba(16,22,26,.4);background:#e1e8ed;color:#394b59}.jupyter-wrapper .bp3-disabled .bp3-slider-handle .bp3-slider-label{-webkit-box-shadow:none;box-shadow:none}.jupyter-wrapper .bp3-slider-handle.bp3-start,.jupyter-wrapper .bp3-slider-handle.bp3-end{width:8px}.jupyter-wrapper .bp3-slider-handle.bp3-start{border-top-right-radius:0;border-bottom-right-radius:0}.jupyter-wrapper .bp3-slider-handle.bp3-end{margin-left:8px;border-top-left-radius:0;border-bottom-left-radius:0}.jupyter-wrapper .bp3-slider-handle.bp3-end .bp3-slider-label{margin-left:0}.jupyter-wrapper .bp3-slider-label{-webkit-transform:translate(-50%, 20px);transform:translate(-50%, 20px);display:inline-block;position:absolute;padding:2px 5px;vertical-align:top;line-height:1;font-size:12px}.jupyter-wrapper .bp3-slider.bp3-vertical{width:40px;min-width:40px;height:150px}.jupyter-wrapper .bp3-slider.bp3-vertical .bp3-slider-track,.jupyter-wrapper .bp3-slider.bp3-vertical .bp3-slider-progress{top:0;bottom:0;left:5px;width:6px;height:auto}.jupyter-wrapper .bp3-slider.bp3-vertical .bp3-slider-progress{top:auto}.jupyter-wrapper .bp3-slider.bp3-vertical .bp3-slider-label{-webkit-transform:translate(20px, 50%);transform:translate(20px, 50%)}.jupyter-wrapper .bp3-slider.bp3-vertical .bp3-slider-handle{top:auto}.jupyter-wrapper .bp3-slider.bp3-vertical .bp3-slider-handle .bp3-slider-label{margin-top:-8px;margin-left:0}.jupyter-wrapper .bp3-slider.bp3-vertical .bp3-slider-handle.bp3-end,.jupyter-wrapper .bp3-slider.bp3-vertical .bp3-slider-handle.bp3-start{margin-left:0;width:16px;height:8px}.jupyter-wrapper .bp3-slider.bp3-vertical .bp3-slider-handle.bp3-start{border-top-left-radius:0;border-bottom-right-radius:3px}.jupyter-wrapper .bp3-slider.bp3-vertical .bp3-slider-handle.bp3-start .bp3-slider-label{-webkit-transform:translate(20px);transform:translate(20px)}.jupyter-wrapper .bp3-slider.bp3-vertical .bp3-slider-handle.bp3-end{margin-bottom:8px;border-top-left-radius:3px;border-bottom-left-radius:0;border-bottom-right-radius:0}@-webkit-keyframes pt-spinner-animation{from{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes pt-spinner-animation{from{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.jupyter-wrapper .bp3-spinner{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;overflow:visible;vertical-align:middle}.jupyter-wrapper .bp3-spinner svg{display:block}.jupyter-wrapper .bp3-spinner path{fill-opacity:0}.jupyter-wrapper .bp3-spinner .bp3-spinner-head{-webkit-transform-origin:center;transform-origin:center;-webkit-transition:stroke-dashoffset 200ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:stroke-dashoffset 200ms cubic-bezier(0.4, 1, 0.75, 0.9);stroke:rgba(92,112,128,.8);stroke-linecap:round}.jupyter-wrapper .bp3-spinner .bp3-spinner-track{stroke:rgba(92,112,128,.2)}.jupyter-wrapper .bp3-spinner-animation{-webkit-animation:pt-spinner-animation 500ms linear infinite;animation:pt-spinner-animation 500ms linear infinite}.jupyter-wrapper .bp3-no-spin>.bp3-spinner-animation{-webkit-animation:none;animation:none}.jupyter-wrapper .bp3-dark .bp3-spinner .bp3-spinner-head{stroke:#8a9ba8}.jupyter-wrapper .bp3-dark .bp3-spinner .bp3-spinner-track{stroke:rgba(16,22,26,.5)}.jupyter-wrapper .bp3-spinner.bp3-intent-primary .bp3-spinner-head{stroke:#137cbd}.jupyter-wrapper .bp3-spinner.bp3-intent-success .bp3-spinner-head{stroke:#0f9960}.jupyter-wrapper .bp3-spinner.bp3-intent-warning .bp3-spinner-head{stroke:#d9822b}.jupyter-wrapper .bp3-spinner.bp3-intent-danger .bp3-spinner-head{stroke:#db3737}.jupyter-wrapper .bp3-tabs.bp3-vertical{display:-webkit-box;display:-ms-flexbox;display:flex}.jupyter-wrapper .bp3-tabs.bp3-vertical>.bp3-tab-list{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.jupyter-wrapper .bp3-tabs.bp3-vertical>.bp3-tab-list .bp3-tab{border-radius:3px;width:100%;padding:0 10px}.jupyter-wrapper .bp3-tabs.bp3-vertical>.bp3-tab-list .bp3-tab[aria-selected=true]{-webkit-box-shadow:none;box-shadow:none;background-color:rgba(19,124,189,.2)}.jupyter-wrapper .bp3-tabs.bp3-vertical>.bp3-tab-list .bp3-tab-indicator-wrapper .bp3-tab-indicator{top:0;right:0;bottom:0;left:0;border-radius:3px;background-color:rgba(19,124,189,.2);height:auto}.jupyter-wrapper .bp3-tabs.bp3-vertical>.bp3-tab-panel{margin-top:0;padding-left:20px}.jupyter-wrapper .bp3-tab-list{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:0 0 auto;-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end;position:relative;margin:0;border:none;padding:0;list-style:none}.jupyter-wrapper .bp3-tab-list>*:not(:last-child){margin-right:20px}.jupyter-wrapper .bp3-tab{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-wrap:normal;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:0 0 auto;position:relative;cursor:pointer;max-width:100%;vertical-align:top;line-height:30px;color:#182026;font-size:14px}.jupyter-wrapper .bp3-tab a{display:block;text-decoration:none;color:inherit}.jupyter-wrapper .bp3-tab-indicator-wrapper~.bp3-tab{-webkit-box-shadow:none !important;box-shadow:none !important;background-color:transparent !important}.jupyter-wrapper .bp3-tab[aria-disabled=true]{cursor:not-allowed;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-tab[aria-selected=true]{border-radius:0;-webkit-box-shadow:inset 0 -3px 0 #106ba3;box-shadow:inset 0 -3px 0 #106ba3}.jupyter-wrapper .bp3-tab[aria-selected=true],.jupyter-wrapper .bp3-tab:not([aria-disabled=true]):hover{color:#106ba3}.jupyter-wrapper .bp3-tab:focus{-moz-outline-radius:0}.jupyter-wrapper .bp3-large>.bp3-tab{line-height:40px;font-size:16px}.jupyter-wrapper .bp3-tab-panel{margin-top:20px}.jupyter-wrapper .bp3-tab-panel[aria-hidden=true]{display:none}.jupyter-wrapper .bp3-tab-indicator-wrapper{position:absolute;top:0;left:0;-webkit-transform:translateX(0),translateY(0);transform:translateX(0),translateY(0);-webkit-transition:height,width,-webkit-transform;transition:height,width,-webkit-transform;transition:height,transform,width;transition:height,transform,width,-webkit-transform;-webkit-transition-duration:200ms;transition-duration:200ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);pointer-events:none}.jupyter-wrapper .bp3-tab-indicator-wrapper .bp3-tab-indicator{position:absolute;right:0;bottom:0;left:0;background-color:#106ba3;height:3px}.jupyter-wrapper .bp3-tab-indicator-wrapper.bp3-no-animation{-webkit-transition:none;transition:none}.jupyter-wrapper .bp3-dark .bp3-tab{color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-tab[aria-disabled=true]{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-tab[aria-selected=true]{-webkit-box-shadow:inset 0 -3px 0 #48aff0;box-shadow:inset 0 -3px 0 #48aff0}.jupyter-wrapper .bp3-dark .bp3-tab[aria-selected=true],.jupyter-wrapper .bp3-dark .bp3-tab:not([aria-disabled=true]):hover{color:#48aff0}.jupyter-wrapper .bp3-dark .bp3-tab-indicator{background-color:#48aff0}.jupyter-wrapper .bp3-flex-expander{-webkit-box-flex:1;-ms-flex:1 1;flex:1 1}.jupyter-wrapper .bp3-tag{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:center;-ms-flex-align:center;align-items:center;position:relative;border:none;border-radius:3px;-webkit-box-shadow:none;box-shadow:none;background-color:#5c7080;min-width:20px;max-width:100%;min-height:20px;padding:2px 6px;line-height:16px;color:#f5f8fa;font-size:12px}.jupyter-wrapper .bp3-tag.bp3-interactive{cursor:pointer}.jupyter-wrapper .bp3-tag.bp3-interactive:hover{background-color:rgba(92,112,128,.85)}.jupyter-wrapper .bp3-tag.bp3-interactive.bp3-active,.jupyter-wrapper .bp3-tag.bp3-interactive:active{background-color:rgba(92,112,128,.7)}.jupyter-wrapper .bp3-tag>*{-webkit-box-flex:0;-ms-flex-positive:0;flex-grow:0;-ms-flex-negative:0;flex-shrink:0}.jupyter-wrapper .bp3-tag>.bp3-fill{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-negative:1;flex-shrink:1}.jupyter-wrapper .bp3-tag::before,.jupyter-wrapper .bp3-tag>*{margin-right:4px}.jupyter-wrapper .bp3-tag:empty::before,.jupyter-wrapper .bp3-tag>:last-child{margin-right:0}.jupyter-wrapper .bp3-tag:focus{outline:rgba(19,124,189,.6) auto 2px;outline-offset:0;-moz-outline-radius:6px}.jupyter-wrapper .bp3-tag.bp3-round{border-radius:30px;padding-right:8px;padding-left:8px}.jupyter-wrapper .bp3-dark .bp3-tag{background-color:#bfccd6;color:#182026}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-interactive{cursor:pointer}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-interactive:hover{background-color:rgba(191,204,214,.85)}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-interactive.bp3-active,.jupyter-wrapper .bp3-dark .bp3-tag.bp3-interactive:active{background-color:rgba(191,204,214,.7)}.jupyter-wrapper .bp3-dark .bp3-tag>.bp3-icon,.jupyter-wrapper .bp3-dark .bp3-tag .bp3-icon-standard,.jupyter-wrapper .bp3-dark .bp3-tag .bp3-icon-large{fill:currentColor}.jupyter-wrapper .bp3-tag>.bp3-icon,.jupyter-wrapper .bp3-tag .bp3-icon-standard,.jupyter-wrapper .bp3-tag .bp3-icon-large{fill:#fff}.jupyter-wrapper .bp3-tag.bp3-large,.jupyter-wrapper .bp3-large .bp3-tag{min-width:30px;min-height:30px;padding:0 10px;line-height:20px;font-size:14px}.jupyter-wrapper .bp3-tag.bp3-large::before,.jupyter-wrapper .bp3-tag.bp3-large>*,.jupyter-wrapper .bp3-large .bp3-tag::before,.jupyter-wrapper .bp3-large .bp3-tag>*{margin-right:7px}.jupyter-wrapper .bp3-tag.bp3-large:empty::before,.jupyter-wrapper .bp3-tag.bp3-large>:last-child,.jupyter-wrapper .bp3-large .bp3-tag:empty::before,.jupyter-wrapper .bp3-large .bp3-tag>:last-child{margin-right:0}.jupyter-wrapper .bp3-tag.bp3-large.bp3-round,.jupyter-wrapper .bp3-large .bp3-tag.bp3-round{padding-right:12px;padding-left:12px}.jupyter-wrapper .bp3-tag.bp3-intent-primary{background:#137cbd;color:#fff}.jupyter-wrapper .bp3-tag.bp3-intent-primary.bp3-interactive{cursor:pointer}.jupyter-wrapper .bp3-tag.bp3-intent-primary.bp3-interactive:hover{background-color:rgba(19,124,189,.85)}.jupyter-wrapper .bp3-tag.bp3-intent-primary.bp3-interactive.bp3-active,.jupyter-wrapper .bp3-tag.bp3-intent-primary.bp3-interactive:active{background-color:rgba(19,124,189,.7)}.jupyter-wrapper .bp3-tag.bp3-intent-success{background:#0f9960;color:#fff}.jupyter-wrapper .bp3-tag.bp3-intent-success.bp3-interactive{cursor:pointer}.jupyter-wrapper .bp3-tag.bp3-intent-success.bp3-interactive:hover{background-color:rgba(15,153,96,.85)}.jupyter-wrapper .bp3-tag.bp3-intent-success.bp3-interactive.bp3-active,.jupyter-wrapper .bp3-tag.bp3-intent-success.bp3-interactive:active{background-color:rgba(15,153,96,.7)}.jupyter-wrapper .bp3-tag.bp3-intent-warning{background:#d9822b;color:#fff}.jupyter-wrapper .bp3-tag.bp3-intent-warning.bp3-interactive{cursor:pointer}.jupyter-wrapper .bp3-tag.bp3-intent-warning.bp3-interactive:hover{background-color:rgba(217,130,43,.85)}.jupyter-wrapper .bp3-tag.bp3-intent-warning.bp3-interactive.bp3-active,.jupyter-wrapper .bp3-tag.bp3-intent-warning.bp3-interactive:active{background-color:rgba(217,130,43,.7)}.jupyter-wrapper .bp3-tag.bp3-intent-danger{background:#db3737;color:#fff}.jupyter-wrapper .bp3-tag.bp3-intent-danger.bp3-interactive{cursor:pointer}.jupyter-wrapper .bp3-tag.bp3-intent-danger.bp3-interactive:hover{background-color:rgba(219,55,55,.85)}.jupyter-wrapper .bp3-tag.bp3-intent-danger.bp3-interactive.bp3-active,.jupyter-wrapper .bp3-tag.bp3-intent-danger.bp3-interactive:active{background-color:rgba(219,55,55,.7)}.jupyter-wrapper .bp3-tag.bp3-fill{display:-webkit-box;display:-ms-flexbox;display:flex;width:100%}.jupyter-wrapper .bp3-tag.bp3-minimal>.bp3-icon,.jupyter-wrapper .bp3-tag.bp3-minimal .bp3-icon-standard,.jupyter-wrapper .bp3-tag.bp3-minimal .bp3-icon-large{fill:#5c7080}.jupyter-wrapper .bp3-tag.bp3-minimal:not([class*=bp3-intent-]){background-color:rgba(138,155,168,.2);color:#182026}.jupyter-wrapper .bp3-tag.bp3-minimal:not([class*=bp3-intent-]).bp3-interactive{cursor:pointer}.jupyter-wrapper .bp3-tag.bp3-minimal:not([class*=bp3-intent-]).bp3-interactive:hover{background-color:rgba(92,112,128,.3)}.jupyter-wrapper .bp3-tag.bp3-minimal:not([class*=bp3-intent-]).bp3-interactive.bp3-active,.jupyter-wrapper .bp3-tag.bp3-minimal:not([class*=bp3-intent-]).bp3-interactive:active{background-color:rgba(92,112,128,.4)}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal:not([class*=bp3-intent-]){color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal:not([class*=bp3-intent-]).bp3-interactive{cursor:pointer}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal:not([class*=bp3-intent-]).bp3-interactive:hover{background-color:rgba(191,204,214,.3)}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal:not([class*=bp3-intent-]).bp3-interactive.bp3-active,.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal:not([class*=bp3-intent-]).bp3-interactive:active{background-color:rgba(191,204,214,.4)}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal:not([class*=bp3-intent-])>.bp3-icon,.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal:not([class*=bp3-intent-]) .bp3-icon-standard,.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal:not([class*=bp3-intent-]) .bp3-icon-large{fill:#a7b6c2}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-primary{background-color:rgba(19,124,189,.15);color:#106ba3}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-primary.bp3-interactive{cursor:pointer}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-primary.bp3-interactive:hover{background-color:rgba(19,124,189,.25)}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-primary.bp3-interactive.bp3-active,.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-primary.bp3-interactive:active{background-color:rgba(19,124,189,.35)}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-primary>.bp3-icon,.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-primary .bp3-icon-standard,.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-primary .bp3-icon-large{fill:#137cbd}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-primary{background-color:rgba(19,124,189,.25);color:#48aff0}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-primary.bp3-interactive{cursor:pointer}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-primary.bp3-interactive:hover{background-color:rgba(19,124,189,.35)}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-primary.bp3-interactive.bp3-active,.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-primary.bp3-interactive:active{background-color:rgba(19,124,189,.45)}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-success{background-color:rgba(15,153,96,.15);color:#0d8050}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-success.bp3-interactive{cursor:pointer}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-success.bp3-interactive:hover{background-color:rgba(15,153,96,.25)}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-success.bp3-interactive.bp3-active,.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-success.bp3-interactive:active{background-color:rgba(15,153,96,.35)}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-success>.bp3-icon,.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-success .bp3-icon-standard,.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-success .bp3-icon-large{fill:#0f9960}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-success{background-color:rgba(15,153,96,.25);color:#3dcc91}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-success.bp3-interactive{cursor:pointer}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-success.bp3-interactive:hover{background-color:rgba(15,153,96,.35)}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-success.bp3-interactive.bp3-active,.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-success.bp3-interactive:active{background-color:rgba(15,153,96,.45)}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-warning{background-color:rgba(217,130,43,.15);color:#bf7326}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-warning.bp3-interactive{cursor:pointer}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-warning.bp3-interactive:hover{background-color:rgba(217,130,43,.25)}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-warning.bp3-interactive.bp3-active,.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-warning.bp3-interactive:active{background-color:rgba(217,130,43,.35)}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-warning>.bp3-icon,.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-warning .bp3-icon-standard,.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-warning .bp3-icon-large{fill:#d9822b}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-warning{background-color:rgba(217,130,43,.25);color:#ffb366}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-warning.bp3-interactive{cursor:pointer}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-warning.bp3-interactive:hover{background-color:rgba(217,130,43,.35)}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-warning.bp3-interactive.bp3-active,.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-warning.bp3-interactive:active{background-color:rgba(217,130,43,.45)}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-danger{background-color:rgba(219,55,55,.15);color:#c23030}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-danger.bp3-interactive{cursor:pointer}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-danger.bp3-interactive:hover{background-color:rgba(219,55,55,.25)}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-danger.bp3-interactive.bp3-active,.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-danger.bp3-interactive:active{background-color:rgba(219,55,55,.35)}.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-danger>.bp3-icon,.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-danger .bp3-icon-standard,.jupyter-wrapper .bp3-tag.bp3-minimal.bp3-intent-danger .bp3-icon-large{fill:#db3737}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-danger{background-color:rgba(219,55,55,.25);color:#ff7373}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-danger.bp3-interactive{cursor:pointer}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-danger.bp3-interactive:hover{background-color:rgba(219,55,55,.35)}.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-danger.bp3-interactive.bp3-active,.jupyter-wrapper .bp3-dark .bp3-tag.bp3-minimal.bp3-intent-danger.bp3-interactive:active{background-color:rgba(219,55,55,.45)}.jupyter-wrapper .bp3-tag-remove{display:-webkit-box;display:-ms-flexbox;display:flex;opacity:.5;margin-top:-2px;margin-right:-6px !important;margin-bottom:-2px;border:none;background:none;cursor:pointer;padding:2px;padding-left:0;color:inherit}.jupyter-wrapper .bp3-tag-remove:hover{opacity:.8;background:none;text-decoration:none}.jupyter-wrapper .bp3-tag-remove:active{opacity:1}.jupyter-wrapper .bp3-tag-remove:empty::before{line-height:1;font-family:\"Icons16\",sans-serif;font-size:16px;font-weight:400;font-style:normal;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;content:\"\ue6d7\"}.jupyter-wrapper .bp3-large .bp3-tag-remove{margin-right:-10px !important;padding:5px;padding-left:0}.jupyter-wrapper .bp3-large .bp3-tag-remove:empty::before{line-height:1;font-family:\"Icons20\",sans-serif;font-size:20px;font-weight:400;font-style:normal}.jupyter-wrapper .bp3-tag-input{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start;cursor:text;height:auto;min-height:30px;padding-right:0;padding-left:5px;line-height:inherit}.jupyter-wrapper .bp3-tag-input>*{-webkit-box-flex:0;-ms-flex-positive:0;flex-grow:0;-ms-flex-negative:0;flex-shrink:0}.jupyter-wrapper .bp3-tag-input>.bp3-tag-input-values{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-negative:1;flex-shrink:1}.jupyter-wrapper .bp3-tag-input .bp3-tag-input-icon{margin-top:7px;margin-right:7px;margin-left:2px;color:#5c7080}.jupyter-wrapper .bp3-tag-input .bp3-tag-input-values{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-ms-flex-item-align:stretch;align-self:stretch;margin-top:5px;margin-right:7px;min-width:0}.jupyter-wrapper .bp3-tag-input .bp3-tag-input-values>*{-webkit-box-flex:0;-ms-flex-positive:0;flex-grow:0;-ms-flex-negative:0;flex-shrink:0}.jupyter-wrapper .bp3-tag-input .bp3-tag-input-values>.bp3-fill{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-negative:1;flex-shrink:1}.jupyter-wrapper .bp3-tag-input .bp3-tag-input-values::before,.jupyter-wrapper .bp3-tag-input .bp3-tag-input-values>*{margin-right:5px}.jupyter-wrapper .bp3-tag-input .bp3-tag-input-values:empty::before,.jupyter-wrapper .bp3-tag-input .bp3-tag-input-values>:last-child{margin-right:0}.jupyter-wrapper .bp3-tag-input .bp3-tag-input-values:first-child .bp3-input-ghost:first-child{padding-left:5px}.jupyter-wrapper .bp3-tag-input .bp3-tag-input-values>*{margin-bottom:5px}.jupyter-wrapper .bp3-tag-input .bp3-tag{overflow-wrap:break-word}.jupyter-wrapper .bp3-tag-input .bp3-tag.bp3-active{outline:rgba(19,124,189,.6) auto 2px;outline-offset:0;-moz-outline-radius:6px}.jupyter-wrapper .bp3-tag-input .bp3-input-ghost{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;width:80px;line-height:20px}.jupyter-wrapper .bp3-tag-input .bp3-input-ghost:disabled,.jupyter-wrapper .bp3-tag-input .bp3-input-ghost.bp3-disabled{cursor:not-allowed}.jupyter-wrapper .bp3-tag-input .bp3-button,.jupyter-wrapper .bp3-tag-input .bp3-spinner{margin:3px;margin-left:0}.jupyter-wrapper .bp3-tag-input .bp3-button{min-width:24px;min-height:24px;padding:0 7px}.jupyter-wrapper .bp3-tag-input.bp3-large{height:auto;min-height:40px}.jupyter-wrapper .bp3-tag-input.bp3-large::before,.jupyter-wrapper .bp3-tag-input.bp3-large>*{margin-right:10px}.jupyter-wrapper .bp3-tag-input.bp3-large:empty::before,.jupyter-wrapper .bp3-tag-input.bp3-large>:last-child{margin-right:0}.jupyter-wrapper .bp3-tag-input.bp3-large .bp3-tag-input-icon{margin-top:10px;margin-left:5px}.jupyter-wrapper .bp3-tag-input.bp3-large .bp3-input-ghost{line-height:30px}.jupyter-wrapper .bp3-tag-input.bp3-large .bp3-button{min-width:30px;min-height:30px;padding:5px 10px;margin:5px;margin-left:0}.jupyter-wrapper .bp3-tag-input.bp3-large .bp3-spinner{margin:8px;margin-left:0}.jupyter-wrapper .bp3-tag-input.bp3-active{-webkit-box-shadow:0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 1px 1px rgba(16,22,26,.2);background-color:#fff}.jupyter-wrapper .bp3-tag-input.bp3-active.bp3-intent-primary{-webkit-box-shadow:0 0 0 1px #106ba3,0 0 0 3px rgba(16,107,163,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #106ba3,0 0 0 3px rgba(16,107,163,.3),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-tag-input.bp3-active.bp3-intent-success{-webkit-box-shadow:0 0 0 1px #0d8050,0 0 0 3px rgba(13,128,80,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #0d8050,0 0 0 3px rgba(13,128,80,.3),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-tag-input.bp3-active.bp3-intent-warning{-webkit-box-shadow:0 0 0 1px #bf7326,0 0 0 3px rgba(191,115,38,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #bf7326,0 0 0 3px rgba(191,115,38,.3),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-tag-input.bp3-active.bp3-intent-danger{-webkit-box-shadow:0 0 0 1px #c23030,0 0 0 3px rgba(194,48,48,.3),inset 0 1px 1px rgba(16,22,26,.2);box-shadow:0 0 0 1px #c23030,0 0 0 3px rgba(194,48,48,.3),inset 0 1px 1px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-dark .bp3-tag-input .bp3-tag-input-icon,.jupyter-wrapper .bp3-tag-input.bp3-dark .bp3-tag-input-icon{color:#a7b6c2}.jupyter-wrapper .bp3-dark .bp3-tag-input .bp3-input-ghost,.jupyter-wrapper .bp3-tag-input.bp3-dark .bp3-input-ghost{color:#f5f8fa}.jupyter-wrapper .bp3-dark .bp3-tag-input .bp3-input-ghost::-webkit-input-placeholder,.jupyter-wrapper .bp3-tag-input.bp3-dark .bp3-input-ghost::-webkit-input-placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-tag-input .bp3-input-ghost::-moz-placeholder,.jupyter-wrapper .bp3-tag-input.bp3-dark .bp3-input-ghost::-moz-placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-tag-input .bp3-input-ghost:-ms-input-placeholder,.jupyter-wrapper .bp3-tag-input.bp3-dark .bp3-input-ghost:-ms-input-placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-tag-input .bp3-input-ghost::-ms-input-placeholder,.jupyter-wrapper .bp3-tag-input.bp3-dark .bp3-input-ghost::-ms-input-placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-tag-input .bp3-input-ghost::placeholder,.jupyter-wrapper .bp3-tag-input.bp3-dark .bp3-input-ghost::placeholder{color:rgba(167,182,194,.6)}.jupyter-wrapper .bp3-dark .bp3-tag-input.bp3-active,.jupyter-wrapper .bp3-tag-input.bp3-dark.bp3-active{-webkit-box-shadow:0 0 0 1px #137cbd,0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px #137cbd,0 0 0 1px #137cbd,0 0 0 3px rgba(19,124,189,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);background-color:rgba(16,22,26,.3)}.jupyter-wrapper .bp3-dark .bp3-tag-input.bp3-active.bp3-intent-primary,.jupyter-wrapper .bp3-tag-input.bp3-dark.bp3-active.bp3-intent-primary{-webkit-box-shadow:0 0 0 1px #106ba3,0 0 0 3px rgba(16,107,163,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px #106ba3,0 0 0 3px rgba(16,107,163,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-tag-input.bp3-active.bp3-intent-success,.jupyter-wrapper .bp3-tag-input.bp3-dark.bp3-active.bp3-intent-success{-webkit-box-shadow:0 0 0 1px #0d8050,0 0 0 3px rgba(13,128,80,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px #0d8050,0 0 0 3px rgba(13,128,80,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-tag-input.bp3-active.bp3-intent-warning,.jupyter-wrapper .bp3-tag-input.bp3-dark.bp3-active.bp3-intent-warning{-webkit-box-shadow:0 0 0 1px #bf7326,0 0 0 3px rgba(191,115,38,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px #bf7326,0 0 0 3px rgba(191,115,38,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-dark .bp3-tag-input.bp3-active.bp3-intent-danger,.jupyter-wrapper .bp3-tag-input.bp3-dark.bp3-active.bp3-intent-danger{-webkit-box-shadow:0 0 0 1px #c23030,0 0 0 3px rgba(194,48,48,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4);box-shadow:0 0 0 1px #c23030,0 0 0 3px rgba(194,48,48,.3),inset 0 0 0 1px rgba(16,22,26,.3),inset 0 1px 1px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-input-ghost{border:none;-webkit-box-shadow:none;box-shadow:none;background:none;padding:0}.jupyter-wrapper .bp3-input-ghost::-webkit-input-placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-input-ghost::-moz-placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-input-ghost:-ms-input-placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-input-ghost::-ms-input-placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-input-ghost::placeholder{opacity:1;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-input-ghost:focus{outline:none !important}.jupyter-wrapper .bp3-toast{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start;position:relative !important;margin:20px 0 0;border-radius:3px;-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.1),0 2px 4px rgba(16,22,26,.2),0 8px 24px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.1),0 2px 4px rgba(16,22,26,.2),0 8px 24px rgba(16,22,26,.2);background-color:#fff;min-width:300px;max-width:500px;pointer-events:all}.jupyter-wrapper .bp3-toast.bp3-toast-enter,.jupyter-wrapper .bp3-toast.bp3-toast-appear{-webkit-transform:translateY(-40px);transform:translateY(-40px)}.jupyter-wrapper .bp3-toast.bp3-toast-enter-active,.jupyter-wrapper .bp3-toast.bp3-toast-appear-active{-webkit-transform:translateY(0);transform:translateY(0);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:300ms;transition-duration:300ms;-webkit-transition-timing-function:cubic-bezier(0.54, 1.12, 0.38, 1.11);transition-timing-function:cubic-bezier(0.54, 1.12, 0.38, 1.11);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-toast.bp3-toast-enter~.bp3-toast,.jupyter-wrapper .bp3-toast.bp3-toast-appear~.bp3-toast{-webkit-transform:translateY(-40px);transform:translateY(-40px)}.jupyter-wrapper .bp3-toast.bp3-toast-enter-active~.bp3-toast,.jupyter-wrapper .bp3-toast.bp3-toast-appear-active~.bp3-toast{-webkit-transform:translateY(0);transform:translateY(0);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:300ms;transition-duration:300ms;-webkit-transition-timing-function:cubic-bezier(0.54, 1.12, 0.38, 1.11);transition-timing-function:cubic-bezier(0.54, 1.12, 0.38, 1.11);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-toast.bp3-toast-exit{opacity:1;-webkit-filter:blur(0);filter:blur(0)}.jupyter-wrapper .bp3-toast.bp3-toast-exit-active{opacity:0;-webkit-filter:blur(10px);filter:blur(10px);-webkit-transition-property:opacity,-webkit-filter;transition-property:opacity,-webkit-filter;transition-property:opacity,filter;transition-property:opacity,filter,-webkit-filter;-webkit-transition-duration:300ms;transition-duration:300ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-toast.bp3-toast-exit~.bp3-toast{-webkit-transform:translateY(0);transform:translateY(0)}.jupyter-wrapper .bp3-toast.bp3-toast-exit-active~.bp3-toast{-webkit-transform:translateY(-40px);transform:translateY(-40px);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:100ms;transition-duration:100ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:50ms;transition-delay:50ms}.jupyter-wrapper .bp3-toast .bp3-button-group{-webkit-box-flex:0;-ms-flex:0 0 auto;flex:0 0 auto;padding:5px;padding-left:0}.jupyter-wrapper .bp3-toast>.bp3-icon{margin:12px;margin-right:0;color:#5c7080}.jupyter-wrapper .bp3-toast.bp3-dark,.jupyter-wrapper .bp3-dark .bp3-toast{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),0 2px 4px rgba(16,22,26,.4),0 8px 24px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.2),0 2px 4px rgba(16,22,26,.4),0 8px 24px rgba(16,22,26,.4);background-color:#394b59}.jupyter-wrapper .bp3-toast.bp3-dark>.bp3-icon,.jupyter-wrapper .bp3-dark .bp3-toast>.bp3-icon{color:#a7b6c2}.jupyter-wrapper .bp3-toast[class*=bp3-intent-] a{color:rgba(255,255,255,.7)}.jupyter-wrapper .bp3-toast[class*=bp3-intent-] a:hover{color:#fff}.jupyter-wrapper .bp3-toast[class*=bp3-intent-]>.bp3-icon{color:#fff}.jupyter-wrapper .bp3-toast[class*=bp3-intent-] .bp3-button,.jupyter-wrapper .bp3-toast[class*=bp3-intent-] .bp3-button::before,.jupyter-wrapper .bp3-toast[class*=bp3-intent-] .bp3-button .bp3-icon,.jupyter-wrapper .bp3-toast[class*=bp3-intent-] .bp3-button:active{color:rgba(255,255,255,.7) !important}.jupyter-wrapper .bp3-toast[class*=bp3-intent-] .bp3-button:focus{outline-color:rgba(255,255,255,.5)}.jupyter-wrapper .bp3-toast[class*=bp3-intent-] .bp3-button:hover{background-color:rgba(255,255,255,.15) !important;color:#fff !important}.jupyter-wrapper .bp3-toast[class*=bp3-intent-] .bp3-button:active{background-color:rgba(255,255,255,.3) !important;color:#fff !important}.jupyter-wrapper .bp3-toast[class*=bp3-intent-] .bp3-button::after{background:rgba(255,255,255,.3) !important}.jupyter-wrapper .bp3-toast.bp3-intent-primary{background-color:#137cbd;color:#fff}.jupyter-wrapper .bp3-toast.bp3-intent-success{background-color:#0f9960;color:#fff}.jupyter-wrapper .bp3-toast.bp3-intent-warning{background-color:#d9822b;color:#fff}.jupyter-wrapper .bp3-toast.bp3-intent-danger{background-color:#db3737;color:#fff}.jupyter-wrapper .bp3-toast-message{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;padding:11px;word-break:break-word}.jupyter-wrapper .bp3-toast-container{display:-webkit-box !important;display:-ms-flexbox !important;display:flex !important;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:center;-ms-flex-align:center;align-items:center;position:fixed;right:0;left:0;z-index:40;overflow:hidden;padding:0 20px 20px;pointer-events:none}.jupyter-wrapper .bp3-toast-container.bp3-toast-container-top{top:0;bottom:auto}.jupyter-wrapper .bp3-toast-container.bp3-toast-container-bottom{-webkit-box-orient:vertical;-webkit-box-direction:reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse;top:auto;bottom:0}.jupyter-wrapper .bp3-toast-container.bp3-toast-container-left{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.jupyter-wrapper .bp3-toast-container.bp3-toast-container-right{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.jupyter-wrapper .bp3-toast-container-bottom .bp3-toast.bp3-toast-enter:not(.bp3-toast-enter-active),.jupyter-wrapper .bp3-toast-container-bottom .bp3-toast.bp3-toast-enter:not(.bp3-toast-enter-active)~.bp3-toast,.jupyter-wrapper .bp3-toast-container-bottom .bp3-toast.bp3-toast-appear:not(.bp3-toast-appear-active),.jupyter-wrapper .bp3-toast-container-bottom .bp3-toast.bp3-toast-appear:not(.bp3-toast-appear-active)~.bp3-toast,.jupyter-wrapper .bp3-toast-container-bottom .bp3-toast.bp3-toast-leave-active~.bp3-toast{-webkit-transform:translateY(60px);transform:translateY(60px)}.jupyter-wrapper .bp3-tooltip{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.1),0 2px 4px rgba(16,22,26,.2),0 8px 24px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.1),0 2px 4px rgba(16,22,26,.2),0 8px 24px rgba(16,22,26,.2);-webkit-transform:scale(1);transform:scale(1)}.jupyter-wrapper .bp3-tooltip .bp3-popover-arrow{position:absolute;width:22px;height:22px}.jupyter-wrapper .bp3-tooltip .bp3-popover-arrow::before{margin:4px;width:14px;height:14px}.jupyter-wrapper .bp3-tether-element-attached-bottom.bp3-tether-target-attached-top>.bp3-tooltip{margin-top:-11px;margin-bottom:11px}.jupyter-wrapper .bp3-tether-element-attached-bottom.bp3-tether-target-attached-top>.bp3-tooltip>.bp3-popover-arrow{bottom:-8px}.jupyter-wrapper .bp3-tether-element-attached-bottom.bp3-tether-target-attached-top>.bp3-tooltip>.bp3-popover-arrow svg{-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.jupyter-wrapper .bp3-tether-element-attached-left.bp3-tether-target-attached-right>.bp3-tooltip{margin-left:11px}.jupyter-wrapper .bp3-tether-element-attached-left.bp3-tether-target-attached-right>.bp3-tooltip>.bp3-popover-arrow{left:-8px}.jupyter-wrapper .bp3-tether-element-attached-left.bp3-tether-target-attached-right>.bp3-tooltip>.bp3-popover-arrow svg{-webkit-transform:rotate(0);transform:rotate(0)}.jupyter-wrapper .bp3-tether-element-attached-top.bp3-tether-target-attached-bottom>.bp3-tooltip{margin-top:11px}.jupyter-wrapper .bp3-tether-element-attached-top.bp3-tether-target-attached-bottom>.bp3-tooltip>.bp3-popover-arrow{top:-8px}.jupyter-wrapper .bp3-tether-element-attached-top.bp3-tether-target-attached-bottom>.bp3-tooltip>.bp3-popover-arrow svg{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.jupyter-wrapper .bp3-tether-element-attached-right.bp3-tether-target-attached-left>.bp3-tooltip{margin-right:11px;margin-left:-11px}.jupyter-wrapper .bp3-tether-element-attached-right.bp3-tether-target-attached-left>.bp3-tooltip>.bp3-popover-arrow{right:-8px}.jupyter-wrapper .bp3-tether-element-attached-right.bp3-tether-target-attached-left>.bp3-tooltip>.bp3-popover-arrow svg{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.jupyter-wrapper .bp3-tether-element-attached-middle>.bp3-tooltip>.bp3-popover-arrow{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.jupyter-wrapper .bp3-tether-element-attached-center>.bp3-tooltip>.bp3-popover-arrow{right:50%;-webkit-transform:translateX(50%);transform:translateX(50%)}.jupyter-wrapper .bp3-tether-element-attached-top.bp3-tether-target-attached-top>.bp3-tooltip>.bp3-popover-arrow{top:-0.22183px}.jupyter-wrapper .bp3-tether-element-attached-right.bp3-tether-target-attached-right>.bp3-tooltip>.bp3-popover-arrow{right:-0.22183px}.jupyter-wrapper .bp3-tether-element-attached-left.bp3-tether-target-attached-left>.bp3-tooltip>.bp3-popover-arrow{left:-0.22183px}.jupyter-wrapper .bp3-tether-element-attached-bottom.bp3-tether-target-attached-bottom>.bp3-tooltip>.bp3-popover-arrow{bottom:-0.22183px}.jupyter-wrapper .bp3-tether-element-attached-top.bp3-tether-element-attached-left>.bp3-tooltip{-webkit-transform-origin:top left;transform-origin:top left}.jupyter-wrapper .bp3-tether-element-attached-top.bp3-tether-element-attached-center>.bp3-tooltip{-webkit-transform-origin:top center;transform-origin:top center}.jupyter-wrapper .bp3-tether-element-attached-top.bp3-tether-element-attached-right>.bp3-tooltip{-webkit-transform-origin:top right;transform-origin:top right}.jupyter-wrapper .bp3-tether-element-attached-middle.bp3-tether-element-attached-left>.bp3-tooltip{-webkit-transform-origin:center left;transform-origin:center left}.jupyter-wrapper .bp3-tether-element-attached-middle.bp3-tether-element-attached-center>.bp3-tooltip{-webkit-transform-origin:center center;transform-origin:center center}.jupyter-wrapper .bp3-tether-element-attached-middle.bp3-tether-element-attached-right>.bp3-tooltip{-webkit-transform-origin:center right;transform-origin:center right}.jupyter-wrapper .bp3-tether-element-attached-bottom.bp3-tether-element-attached-left>.bp3-tooltip{-webkit-transform-origin:bottom left;transform-origin:bottom left}.jupyter-wrapper .bp3-tether-element-attached-bottom.bp3-tether-element-attached-center>.bp3-tooltip{-webkit-transform-origin:bottom center;transform-origin:bottom center}.jupyter-wrapper .bp3-tether-element-attached-bottom.bp3-tether-element-attached-right>.bp3-tooltip{-webkit-transform-origin:bottom right;transform-origin:bottom right}.jupyter-wrapper .bp3-tooltip .bp3-popover-content{background:#394b59;color:#f5f8fa}.jupyter-wrapper .bp3-tooltip .bp3-popover-arrow::before{-webkit-box-shadow:1px 1px 6px rgba(16,22,26,.2);box-shadow:1px 1px 6px rgba(16,22,26,.2)}.jupyter-wrapper .bp3-tooltip .bp3-popover-arrow-border{fill:#10161a;fill-opacity:.1}.jupyter-wrapper .bp3-tooltip .bp3-popover-arrow-fill{fill:#394b59}.jupyter-wrapper .bp3-popover-enter>.bp3-tooltip,.jupyter-wrapper .bp3-popover-appear>.bp3-tooltip{-webkit-transform:scale(0.8);transform:scale(0.8)}.jupyter-wrapper .bp3-popover-enter-active>.bp3-tooltip,.jupyter-wrapper .bp3-popover-appear-active>.bp3-tooltip{-webkit-transform:scale(1);transform:scale(1);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:100ms;transition-duration:100ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-popover-exit>.bp3-tooltip{-webkit-transform:scale(1);transform:scale(1)}.jupyter-wrapper .bp3-popover-exit-active>.bp3-tooltip{-webkit-transform:scale(0.8);transform:scale(0.8);-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform,-webkit-transform;-webkit-transition-duration:100ms;transition-duration:100ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-tooltip .bp3-popover-content{padding:10px 12px}.jupyter-wrapper .bp3-tooltip.bp3-dark,.jupyter-wrapper .bp3-dark .bp3-tooltip{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),0 2px 4px rgba(16,22,26,.4),0 8px 24px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.2),0 2px 4px rgba(16,22,26,.4),0 8px 24px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-tooltip.bp3-dark .bp3-popover-content,.jupyter-wrapper .bp3-dark .bp3-tooltip .bp3-popover-content{background:#e1e8ed;color:#394b59}.jupyter-wrapper .bp3-tooltip.bp3-dark .bp3-popover-arrow::before,.jupyter-wrapper .bp3-dark .bp3-tooltip .bp3-popover-arrow::before{-webkit-box-shadow:1px 1px 6px rgba(16,22,26,.4);box-shadow:1px 1px 6px rgba(16,22,26,.4)}.jupyter-wrapper .bp3-tooltip.bp3-dark .bp3-popover-arrow-border,.jupyter-wrapper .bp3-dark .bp3-tooltip .bp3-popover-arrow-border{fill:#10161a;fill-opacity:.2}.jupyter-wrapper .bp3-tooltip.bp3-dark .bp3-popover-arrow-fill,.jupyter-wrapper .bp3-dark .bp3-tooltip .bp3-popover-arrow-fill{fill:#e1e8ed}.jupyter-wrapper .bp3-tooltip.bp3-intent-primary .bp3-popover-content{background:#137cbd;color:#fff}.jupyter-wrapper .bp3-tooltip.bp3-intent-primary .bp3-popover-arrow-fill{fill:#137cbd}.jupyter-wrapper .bp3-tooltip.bp3-intent-success .bp3-popover-content{background:#0f9960;color:#fff}.jupyter-wrapper .bp3-tooltip.bp3-intent-success .bp3-popover-arrow-fill{fill:#0f9960}.jupyter-wrapper .bp3-tooltip.bp3-intent-warning .bp3-popover-content{background:#d9822b;color:#fff}.jupyter-wrapper .bp3-tooltip.bp3-intent-warning .bp3-popover-arrow-fill{fill:#d9822b}.jupyter-wrapper .bp3-tooltip.bp3-intent-danger .bp3-popover-content{background:#db3737;color:#fff}.jupyter-wrapper .bp3-tooltip.bp3-intent-danger .bp3-popover-arrow-fill{fill:#db3737}.jupyter-wrapper .bp3-tooltip-indicator{border-bottom:dotted 1px;cursor:help}.jupyter-wrapper .bp3-tree .bp3-icon,.jupyter-wrapper .bp3-tree .bp3-icon-standard,.jupyter-wrapper .bp3-tree .bp3-icon-large{color:#5c7080}.jupyter-wrapper .bp3-tree .bp3-icon.bp3-intent-primary,.jupyter-wrapper .bp3-tree .bp3-icon-standard.bp3-intent-primary,.jupyter-wrapper .bp3-tree .bp3-icon-large.bp3-intent-primary{color:#137cbd}.jupyter-wrapper .bp3-tree .bp3-icon.bp3-intent-success,.jupyter-wrapper .bp3-tree .bp3-icon-standard.bp3-intent-success,.jupyter-wrapper .bp3-tree .bp3-icon-large.bp3-intent-success{color:#0f9960}.jupyter-wrapper .bp3-tree .bp3-icon.bp3-intent-warning,.jupyter-wrapper .bp3-tree .bp3-icon-standard.bp3-intent-warning,.jupyter-wrapper .bp3-tree .bp3-icon-large.bp3-intent-warning{color:#d9822b}.jupyter-wrapper .bp3-tree .bp3-icon.bp3-intent-danger,.jupyter-wrapper .bp3-tree .bp3-icon-standard.bp3-intent-danger,.jupyter-wrapper .bp3-tree .bp3-icon-large.bp3-intent-danger{color:#db3737}.jupyter-wrapper .bp3-tree-node-list{margin:0;padding-left:0;list-style:none}.jupyter-wrapper .bp3-tree-root{position:relative;background-color:transparent;cursor:default;padding-left:0}.jupyter-wrapper .bp3-tree-node-content-0{padding-left:0px}.jupyter-wrapper .bp3-tree-node-content-1{padding-left:23px}.jupyter-wrapper .bp3-tree-node-content-2{padding-left:46px}.jupyter-wrapper .bp3-tree-node-content-3{padding-left:69px}.jupyter-wrapper .bp3-tree-node-content-4{padding-left:92px}.jupyter-wrapper .bp3-tree-node-content-5{padding-left:115px}.jupyter-wrapper .bp3-tree-node-content-6{padding-left:138px}.jupyter-wrapper .bp3-tree-node-content-7{padding-left:161px}.jupyter-wrapper .bp3-tree-node-content-8{padding-left:184px}.jupyter-wrapper .bp3-tree-node-content-9{padding-left:207px}.jupyter-wrapper .bp3-tree-node-content-10{padding-left:230px}.jupyter-wrapper .bp3-tree-node-content-11{padding-left:253px}.jupyter-wrapper .bp3-tree-node-content-12{padding-left:276px}.jupyter-wrapper .bp3-tree-node-content-13{padding-left:299px}.jupyter-wrapper .bp3-tree-node-content-14{padding-left:322px}.jupyter-wrapper .bp3-tree-node-content-15{padding-left:345px}.jupyter-wrapper .bp3-tree-node-content-16{padding-left:368px}.jupyter-wrapper .bp3-tree-node-content-17{padding-left:391px}.jupyter-wrapper .bp3-tree-node-content-18{padding-left:414px}.jupyter-wrapper .bp3-tree-node-content-19{padding-left:437px}.jupyter-wrapper .bp3-tree-node-content-20{padding-left:460px}.jupyter-wrapper .bp3-tree-node-content{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;width:100%;height:30px;padding-right:5px}.jupyter-wrapper .bp3-tree-node-content:hover{background-color:rgba(191,204,214,.4)}.jupyter-wrapper .bp3-tree-node-caret,.jupyter-wrapper .bp3-tree-node-caret-none{min-width:30px}.jupyter-wrapper .bp3-tree-node-caret{color:#5c7080;-webkit-transform:rotate(0deg);transform:rotate(0deg);cursor:pointer;padding:7px;-webkit-transition:-webkit-transform 200ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:-webkit-transform 200ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:transform 200ms cubic-bezier(0.4, 1, 0.75, 0.9);transition:transform 200ms cubic-bezier(0.4, 1, 0.75, 0.9),-webkit-transform 200ms cubic-bezier(0.4, 1, 0.75, 0.9)}.jupyter-wrapper .bp3-tree-node-caret:hover{color:#182026}.jupyter-wrapper .bp3-dark .bp3-tree-node-caret{color:#a7b6c2}.jupyter-wrapper .bp3-dark .bp3-tree-node-caret:hover{color:#f5f8fa}.jupyter-wrapper .bp3-tree-node-caret.bp3-tree-node-caret-open{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.jupyter-wrapper .bp3-tree-node-caret.bp3-icon-standard::before{content:\"\ue695\"}.jupyter-wrapper .bp3-tree-node-icon{position:relative;margin-right:7px}.jupyter-wrapper .bp3-tree-node-label{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-wrap:normal;-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.jupyter-wrapper .bp3-tree-node-label span{display:inline}.jupyter-wrapper .bp3-tree-node-secondary-label{padding:0 5px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.jupyter-wrapper .bp3-tree-node-secondary-label .bp3-popover-wrapper,.jupyter-wrapper .bp3-tree-node-secondary-label .bp3-popover-target{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.jupyter-wrapper .bp3-tree-node.bp3-disabled .bp3-tree-node-content{background-color:inherit;cursor:not-allowed;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-tree-node.bp3-disabled .bp3-tree-node-caret,.jupyter-wrapper .bp3-tree-node.bp3-disabled .bp3-tree-node-icon{cursor:not-allowed;color:rgba(92,112,128,.6)}.jupyter-wrapper .bp3-tree-node.bp3-tree-node-selected>.bp3-tree-node-content{background-color:#137cbd}.jupyter-wrapper .bp3-tree-node.bp3-tree-node-selected>.bp3-tree-node-content,.jupyter-wrapper .bp3-tree-node.bp3-tree-node-selected>.bp3-tree-node-content .bp3-icon,.jupyter-wrapper .bp3-tree-node.bp3-tree-node-selected>.bp3-tree-node-content .bp3-icon-standard,.jupyter-wrapper .bp3-tree-node.bp3-tree-node-selected>.bp3-tree-node-content .bp3-icon-large{color:#fff}.jupyter-wrapper .bp3-tree-node.bp3-tree-node-selected>.bp3-tree-node-content .bp3-tree-node-caret::before{color:rgba(255,255,255,.7)}.jupyter-wrapper .bp3-tree-node.bp3-tree-node-selected>.bp3-tree-node-content .bp3-tree-node-caret:hover::before{color:#fff}.jupyter-wrapper .bp3-dark .bp3-tree-node-content:hover{background-color:rgba(92,112,128,.3)}.jupyter-wrapper .bp3-dark .bp3-tree .bp3-icon,.jupyter-wrapper .bp3-dark .bp3-tree .bp3-icon-standard,.jupyter-wrapper .bp3-dark .bp3-tree .bp3-icon-large{color:#a7b6c2}.jupyter-wrapper .bp3-dark .bp3-tree .bp3-icon.bp3-intent-primary,.jupyter-wrapper .bp3-dark .bp3-tree .bp3-icon-standard.bp3-intent-primary,.jupyter-wrapper .bp3-dark .bp3-tree .bp3-icon-large.bp3-intent-primary{color:#137cbd}.jupyter-wrapper .bp3-dark .bp3-tree .bp3-icon.bp3-intent-success,.jupyter-wrapper .bp3-dark .bp3-tree .bp3-icon-standard.bp3-intent-success,.jupyter-wrapper .bp3-dark .bp3-tree .bp3-icon-large.bp3-intent-success{color:#0f9960}.jupyter-wrapper .bp3-dark .bp3-tree .bp3-icon.bp3-intent-warning,.jupyter-wrapper .bp3-dark .bp3-tree .bp3-icon-standard.bp3-intent-warning,.jupyter-wrapper .bp3-dark .bp3-tree .bp3-icon-large.bp3-intent-warning{color:#d9822b}.jupyter-wrapper .bp3-dark .bp3-tree .bp3-icon.bp3-intent-danger,.jupyter-wrapper .bp3-dark .bp3-tree .bp3-icon-standard.bp3-intent-danger,.jupyter-wrapper .bp3-dark .bp3-tree .bp3-icon-large.bp3-intent-danger{color:#db3737}.jupyter-wrapper .bp3-dark .bp3-tree-node.bp3-tree-node-selected>.bp3-tree-node-content{background-color:#137cbd}.jupyter-wrapper .bp3-omnibar{-webkit-filter:blur(0);filter:blur(0);opacity:1;top:20vh;left:calc(50% - 250px);z-index:21;border-radius:3px;-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.1),0 4px 8px rgba(16,22,26,.2),0 18px 46px 6px rgba(16,22,26,.2);box-shadow:0 0 0 1px rgba(16,22,26,.1),0 4px 8px rgba(16,22,26,.2),0 18px 46px 6px rgba(16,22,26,.2);background-color:#fff;width:500px}.jupyter-wrapper .bp3-omnibar.bp3-overlay-enter,.jupyter-wrapper .bp3-omnibar.bp3-overlay-appear{-webkit-filter:blur(20px);filter:blur(20px);opacity:.2}.jupyter-wrapper .bp3-omnibar.bp3-overlay-enter-active,.jupyter-wrapper .bp3-omnibar.bp3-overlay-appear-active{-webkit-filter:blur(0);filter:blur(0);opacity:1;-webkit-transition-property:opacity,-webkit-filter;transition-property:opacity,-webkit-filter;transition-property:filter,opacity;transition-property:filter,opacity,-webkit-filter;-webkit-transition-duration:200ms;transition-duration:200ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-omnibar.bp3-overlay-exit{-webkit-filter:blur(0);filter:blur(0);opacity:1}.jupyter-wrapper .bp3-omnibar.bp3-overlay-exit-active{-webkit-filter:blur(20px);filter:blur(20px);opacity:.2;-webkit-transition-property:opacity,-webkit-filter;transition-property:opacity,-webkit-filter;transition-property:filter,opacity;transition-property:filter,opacity,-webkit-filter;-webkit-transition-duration:200ms;transition-duration:200ms;-webkit-transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);transition-timing-function:cubic-bezier(0.4, 1, 0.75, 0.9);-webkit-transition-delay:0;transition-delay:0}.jupyter-wrapper .bp3-omnibar .bp3-input{border-radius:0;background-color:transparent}.jupyter-wrapper .bp3-omnibar .bp3-input,.jupyter-wrapper .bp3-omnibar .bp3-input:focus{-webkit-box-shadow:none;box-shadow:none}.jupyter-wrapper .bp3-omnibar .bp3-menu{border-radius:0;-webkit-box-shadow:inset 0 1px 0 rgba(16,22,26,.15);box-shadow:inset 0 1px 0 rgba(16,22,26,.15);background-color:transparent;max-height:calc(60vh - 40px);overflow:auto}.jupyter-wrapper .bp3-omnibar .bp3-menu:empty{display:none}.jupyter-wrapper .bp3-dark .bp3-omnibar,.jupyter-wrapper .bp3-omnibar.bp3-dark{-webkit-box-shadow:0 0 0 1px rgba(16,22,26,.2),0 4px 8px rgba(16,22,26,.4),0 18px 46px 6px rgba(16,22,26,.4);box-shadow:0 0 0 1px rgba(16,22,26,.2),0 4px 8px rgba(16,22,26,.4),0 18px 46px 6px rgba(16,22,26,.4);background-color:#30404d}.jupyter-wrapper .bp3-omnibar-overlay .bp3-overlay-backdrop{background-color:rgba(16,22,26,.2)}.jupyter-wrapper .bp3-select-popover .bp3-popover-content{padding:5px}.jupyter-wrapper .bp3-select-popover .bp3-input-group{margin-bottom:0}.jupyter-wrapper .bp3-select-popover .bp3-menu{max-width:400px;max-height:300px;overflow:auto;padding:0}.jupyter-wrapper .bp3-select-popover .bp3-menu:not(:first-child){padding-top:5px}.jupyter-wrapper .bp3-multi-select{min-width:150px}.jupyter-wrapper .bp3-multi-select-popover .bp3-menu{max-width:400px;max-height:300px;overflow:auto}.jupyter-wrapper .bp3-select-popover .bp3-popover-content{padding:5px}.jupyter-wrapper .bp3-select-popover .bp3-input-group{margin-bottom:0}.jupyter-wrapper .bp3-select-popover .bp3-menu{max-width:400px;max-height:300px;overflow:auto;padding:0}.jupyter-wrapper .bp3-select-popover .bp3-menu:not(:first-child){padding-top:5px}.jupyter-wrapper :root{--jp-icon-add: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE5IDEzaC02djZoLTJ2LTZINXYtMmg2VjVoMnY2aDZ2MnoiLz4KICA8L2c+Cjwvc3ZnPgo=);--jp-icon-bug: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTIwIDhoLTIuODFjLS40NS0uNzgtMS4wNy0xLjQ1LTEuODItMS45NkwxNyA0LjQxIDE1LjU5IDNsLTIuMTcgMi4xN0MxMi45NiA1LjA2IDEyLjQ5IDUgMTIgNWMtLjQ5IDAtLjk2LjA2LTEuNDEuMTdMOC40MSAzIDcgNC40MWwxLjYyIDEuNjNDNy44OCA2LjU1IDcuMjYgNy4yMiA2LjgxIDhINHYyaDIuMDljLS4wNS4zMy0uMDkuNjYtLjA5IDF2MUg0djJoMnYxYzAgLjM0LjA0LjY3LjA5IDFINHYyaDIuODFjMS4wNCAxLjc5IDIuOTcgMyA1LjE5IDNzNC4xNS0xLjIxIDUuMTktM0gyMHYtMmgtMi4wOWMuMDUtLjMzLjA5LS42Ni4wOS0xdi0xaDJ2LTJoLTJ2LTFjMC0uMzQtLjA0LS42Ny0uMDktMUgyMFY4em0tNiA4aC00di0yaDR2MnptMC00aC00di0yaDR2MnoiLz4KICA8L2c+Cjwvc3ZnPgo=);--jp-icon-build: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE0LjkgMTcuNDVDMTYuMjUgMTcuNDUgMTcuMzUgMTYuMzUgMTcuMzUgMTVDMTcuMzUgMTMuNjUgMTYuMjUgMTIuNTUgMTQuOSAxMi41NUMxMy41NCAxMi41NSAxMi40NSAxMy42NSAxMi40NSAxNUMxMi40NSAxNi4zNSAxMy41NCAxNy40NSAxNC45IDE3LjQ1Wk0yMC4xIDE1LjY4TDIxLjU4IDE2Ljg0QzIxLjcxIDE2Ljk1IDIxLjc1IDE3LjEzIDIxLjY2IDE3LjI5TDIwLjI2IDE5LjcxQzIwLjE3IDE5Ljg2IDIwIDE5LjkyIDE5LjgzIDE5Ljg2TDE4LjA5IDE5LjE2QzE3LjczIDE5LjQ0IDE3LjMzIDE5LjY3IDE2LjkxIDE5Ljg1TDE2LjY0IDIxLjdDMTYuNjIgMjEuODcgMTYuNDcgMjIgMTYuMyAyMkgxMy41QzEzLjMyIDIyIDEzLjE4IDIxLjg3IDEzLjE1IDIxLjdMMTIuODkgMTkuODVDMTIuNDYgMTkuNjcgMTIuMDcgMTkuNDQgMTEuNzEgMTkuMTZMOS45NjAwMiAxOS44NkM5LjgxMDAyIDE5LjkyIDkuNjIwMDIgMTkuODYgOS41NDAwMiAxOS43MUw4LjE0MDAyIDE3LjI5QzguMDUwMDIgMTcuMTMgOC4wOTAwMiAxNi45NSA4LjIyMDAyIDE2Ljg0TDkuNzAwMDIgMTUuNjhMOS42NTAwMSAxNUw5LjcwMDAyIDE0LjMxTDguMjIwMDIgMTMuMTZDOC4wOTAwMiAxMy4wNSA4LjA1MDAyIDEyLjg2IDguMTQwMDIgMTIuNzFMOS41NDAwMiAxMC4yOUM5LjYyMDAyIDEwLjEzIDkuODEwMDIgMTAuMDcgOS45NjAwMiAxMC4xM0wxMS43MSAxMC44NEMxMi4wNyAxMC41NiAxMi40NiAxMC4zMiAxMi44OSAxMC4xNUwxMy4xNSA4LjI4OTk4QzEzLjE4IDguMTI5OTggMTMuMzIgNy45OTk5OCAxMy41IDcuOTk5OThIMTYuM0MxNi40NyA3Ljk5OTk4IDE2LjYyIDguMTI5OTggMTYuNjQgOC4yODk5OEwxNi45MSAxMC4xNUMxNy4zMyAxMC4zMiAxNy43MyAxMC41NiAxOC4wOSAxMC44NEwxOS44MyAxMC4xM0MyMCAxMC4wNyAyMC4xNyAxMC4xMyAyMC4yNiAxMC4yOUwyMS42NiAxMi43MUMyMS43NSAxMi44NiAyMS43MSAxMy4wNSAyMS41OCAxMy4xNkwyMC4xIDE0LjMxTDIwLjE1IDE1TDIwLjEgMTUuNjhaIi8+CiAgICA8cGF0aCBkPSJNNy4zMjk2NiA3LjQ0NDU0QzguMDgzMSA3LjAwOTU0IDguMzM5MzIgNi4wNTMzMiA3LjkwNDMyIDUuMjk5ODhDNy40NjkzMiA0LjU0NjQzIDYuNTA4MSA0LjI4MTU2IDUuNzU0NjYgNC43MTY1NkM1LjM5MTc2IDQuOTI2MDggNS4xMjY5NSA1LjI3MTE4IDUuMDE4NDkgNS42NzU5NEM0LjkxMDA0IDYuMDgwNzEgNC45NjY4MiA2LjUxMTk4IDUuMTc2MzQgNi44NzQ4OEM1LjYxMTM0IDcuNjI4MzIgNi41NzYyMiA3Ljg3OTU0IDcuMzI5NjYgNy40NDQ1NFpNOS42NTcxOCA0Ljc5NTkzTDEwLjg2NzIgNC45NTE3OUMxMC45NjI4IDQuOTc3NDEgMTEuMDQwMiA1LjA3MTMzIDExLjAzODIgNS4xODc5M0wxMS4wMzg4IDYuOTg4OTNDMTEuMDQ1NSA3LjEwMDU0IDEwLjk2MTYgNy4xOTUxOCAxMC44NTUgNy4yMTA1NEw5LjY2MDAxIDcuMzgwODNMOS4yMzkxNSA4LjEzMTg4TDkuNjY5NjEgOS4yNTc0NUM5LjcwNzI5IDkuMzYyNzEgOS42NjkzNCA5LjQ3Njk5IDkuNTc0MDggOS41MzE5OUw4LjAxNTIzIDEwLjQzMkM3LjkxMTMxIDEwLjQ5MiA3Ljc5MzM3IDEwLjQ2NzcgNy43MjEwNSAxMC4zODI0TDYuOTg3NDggOS40MzE4OEw2LjEwOTMxIDkuNDMwODNMNS4zNDcwNCAxMC4zOTA1QzUuMjg5MDkgMTAuNDcwMiA1LjE3MzgzIDEwLjQ5MDUgNS4wNzE4NyAxMC40MzM5TDMuNTEyNDUgOS41MzI5M0MzLjQxMDQ5IDkuNDc2MzMgMy4zNzY0NyA5LjM1NzQxIDMuNDEwNzUgOS4yNTY3OUwzLjg2MzQ3IDguMTQwOTNMMy42MTc0OSA3Ljc3NDg4TDMuNDIzNDcgNy4zNzg4M0wyLjIzMDc1IDcuMjEyOTdDMi4xMjY0NyA3LjE5MjM1IDIuMDQwNDkgNy4xMDM0MiAyLjA0MjQ1IDYuOTg2ODJMMi4wNDE4NyA1LjE4NTgyQzIuMDQzODMgNS4wNjkyMiAyLjExOTA5IDQuOTc5NTggMi4yMTcwNCA0Ljk2OTIyTDMuNDIwNjUgNC43OTM5M0wzLjg2NzQ5IDQuMDI3ODhMMy40MTEwNSAyLjkxNzMxQzMuMzczMzcgMi44MTIwNCAzLjQxMTMxIDIuNjk3NzYgMy41MTUyMyAyLjYzNzc2TDUuMDc0MDggMS43Mzc3NkM1LjE2OTM0IDEuNjgyNzYgNS4yODcyOSAxLjcwNzA0IDUuMzU5NjEgMS43OTIzMUw2LjExOTE1IDIuNzI3ODhMNi45ODAwMSAyLjczODkzTDcuNzI0OTYgMS43ODkyMkM3Ljc5MTU2IDEuNzA0NTggNy45MTU0OCAxLjY3OTIyIDguMDA4NzkgMS43NDA4Mkw5LjU2ODIxIDIuNjQxODJDOS42NzAxNyAyLjY5ODQyIDkuNzEyODUgMi44MTIzNCA5LjY4NzIzIDIuOTA3OTdMOS4yMTcxOCA0LjAzMzgzTDkuNDYzMTYgNC4zOTk4OEw5LjY1NzE4IDQuNzk1OTNaIi8+CiAgPC9nPgo8L3N2Zz4K);--jp-icon-caret-down-empty-thin: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwb2x5Z29uIGNsYXNzPSJzdDEiIHBvaW50cz0iOS45LDEzLjYgMy42LDcuNCA0LjQsNi42IDkuOSwxMi4yIDE1LjQsNi43IDE2LjEsNy40ICIvPgoJPC9nPgo8L3N2Zz4K);--jp-icon-caret-down-empty: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KICAgIDxwYXRoIGQ9Ik01LjIsNS45TDksOS43bDMuOC0zLjhsMS4yLDEuMmwtNC45LDVsLTQuOS01TDUuMiw1Ljl6Ii8+CiAgPC9nPgo8L3N2Zz4K);--jp-icon-caret-down: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KICAgIDxwYXRoIGQ9Ik01LjIsNy41TDksMTEuMmwzLjgtMy44SDUuMnoiLz4KICA8L2c+Cjwvc3ZnPgo=);--jp-icon-caret-left: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwYXRoIGQ9Ik0xMC44LDEyLjhMNy4xLDlsMy44LTMuOGwwLDcuNkgxMC44eiIvPgogIDwvZz4KPC9zdmc+Cg==);--jp-icon-caret-right: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KICAgIDxwYXRoIGQ9Ik03LjIsNS4yTDEwLjksOWwtMy44LDMuOFY1LjJINy4yeiIvPgogIDwvZz4KPC9zdmc+Cg==);--jp-icon-caret-up-empty-thin: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwb2x5Z29uIGNsYXNzPSJzdDEiIHBvaW50cz0iMTUuNCwxMy4zIDkuOSw3LjcgNC40LDEzLjIgMy42LDEyLjUgOS45LDYuMyAxNi4xLDEyLjYgIi8+Cgk8L2c+Cjwvc3ZnPgo=);--jp-icon-caret-up: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KCTxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgoJCTxwYXRoIGQ9Ik01LjIsMTAuNUw5LDYuOGwzLjgsMy44SDUuMnoiLz4KICA8L2c+Cjwvc3ZnPgo=);--jp-icon-case-sensitive: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KICA8ZyBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiM0MTQxNDEiPgogICAgPHJlY3QgeD0iMiIgeT0iMiIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2Ii8+CiAgPC9nPgogIDxnIGNsYXNzPSJqcC1pY29uLWFjY2VudDIiIGZpbGw9IiNGRkYiPgogICAgPHBhdGggZD0iTTcuNiw4aDAuOWwzLjUsOGgtMS4xTDEwLDE0SDZsLTAuOSwySDRMNy42LDh6IE04LDkuMUw2LjQsMTNoMy4yTDgsOS4xeiIvPgogICAgPHBhdGggZD0iTTE2LjYsOS44Yy0wLjIsMC4xLTAuNCwwLjEtMC43LDAuMWMtMC4yLDAtMC40LTAuMS0wLjYtMC4yYy0wLjEtMC4xLTAuMi0wLjQtMC4yLTAuNyBjLTAuMywwLjMtMC42LDAuNS0wLjksMC43Yy0wLjMsMC4xLTAuNywwLjItMS4xLDAuMmMtMC4zLDAtMC41LDAtMC43LTAuMWMtMC4yLTAuMS0wLjQtMC4yLTAuNi0wLjNjLTAuMi0wLjEtMC4zLTAuMy0wLjQtMC41IGMtMC4xLTAuMi0wLjEtMC40LTAuMS0wLjdjMC0wLjMsMC4xLTAuNiwwLjItMC44YzAuMS0wLjIsMC4zLTAuNCwwLjQtMC41QzEyLDcsMTIuMiw2LjksMTIuNSw2LjhjMC4yLTAuMSwwLjUtMC4xLDAuNy0wLjIgYzAuMy0wLjEsMC41LTAuMSwwLjctMC4xYzAuMiwwLDAuNC0wLjEsMC42LTAuMWMwLjIsMCwwLjMtMC4xLDAuNC0wLjJjMC4xLTAuMSwwLjItMC4yLDAuMi0wLjRjMC0xLTEuMS0xLTEuMy0xIGMtMC40LDAtMS40LDAtMS40LDEuMmgtMC45YzAtMC40LDAuMS0wLjcsMC4yLTFjMC4xLTAuMiwwLjMtMC40LDAuNS0wLjZjMC4yLTAuMiwwLjUtMC4zLDAuOC0wLjNDMTMuMyw0LDEzLjYsNCwxMy45LDQgYzAuMywwLDAuNSwwLDAuOCwwLjFjMC4zLDAsMC41LDAuMSwwLjcsMC4yYzAuMiwwLjEsMC40LDAuMywwLjUsMC41QzE2LDUsMTYsNS4yLDE2LDUuNnYyLjljMCwwLjIsMCwwLjQsMCwwLjUgYzAsMC4xLDAuMSwwLjIsMC4zLDAuMmMwLjEsMCwwLjIsMCwwLjMsMFY5Ljh6IE0xNS4yLDYuOWMtMS4yLDAuNi0zLjEsMC4yLTMuMSwxLjRjMCwxLjQsMy4xLDEsMy4xLTAuNVY2Ljl6Ii8+CiAgPC9nPgo8L3N2Zz4K);--jp-icon-check: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTkgMTYuMTdMNC44MyAxMmwtMS40MiAxLjQxTDkgMTkgMjEgN2wtMS40MS0xLjQxeiIvPgogIDwvZz4KPC9zdmc+Cg==);--jp-icon-circle-empty: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyIDJDNi40NyAyIDIgNi40NyAyIDEyczQuNDcgMTAgMTAgMTAgMTAtNC40NyAxMC0xMFMxNy41MyAyIDEyIDJ6bTAgMThjLTQuNDEgMC04LTMuNTktOC04czMuNTktOCA4LTggOCAzLjU5IDggOC0zLjU5IDgtOCA4eiIvPgogIDwvZz4KPC9zdmc+Cg==);--jp-icon-circle: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTggMTgiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPGNpcmNsZSBjeD0iOSIgY3k9IjkiIHI9IjgiLz4KICA8L2c+Cjwvc3ZnPgo=);--jp-icon-clear: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8bWFzayBpZD0iZG9udXRIb2xlIj4KICAgIDxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgZmlsbD0id2hpdGUiIC8+CiAgICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI4IiBmaWxsPSJibGFjayIvPgogIDwvbWFzaz4KCiAgPGcgY2xhc3M9ImpwLWljb24zIiBmaWxsPSIjNjE2MTYxIj4KICAgIDxyZWN0IGhlaWdodD0iMTgiIHdpZHRoPSIyIiB4PSIxMSIgeT0iMyIgdHJhbnNmb3JtPSJyb3RhdGUoMzE1LCAxMiwgMTIpIi8+CiAgICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIxMCIgbWFzaz0idXJsKCNkb251dEhvbGUpIi8+CiAgPC9nPgo8L3N2Zz4K);--jp-icon-close: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbi1ub25lIGpwLWljb24tc2VsZWN0YWJsZS1pbnZlcnNlIGpwLWljb24zLWhvdmVyIiBmaWxsPSJub25lIj4KICAgIDxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjExIi8+CiAgPC9nPgoKICA8ZyBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIGpwLWljb24tYWNjZW50Mi1ob3ZlciIgZmlsbD0iIzYxNjE2MSI+CiAgICA8cGF0aCBkPSJNMTkgNi40MUwxNy41OSA1IDEyIDEwLjU5IDYuNDEgNSA1IDYuNDEgMTAuNTkgMTIgNSAxNy41OSA2LjQxIDE5IDEyIDEzLjQxIDE3LjU5IDE5IDE5IDE3LjU5IDEzLjQxIDEyeiIvPgogIDwvZz4KCiAgPGcgY2xhc3M9ImpwLWljb24tbm9uZSBqcC1pY29uLWJ1c3kiIGZpbGw9Im5vbmUiPgogICAgPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iNyIvPgogIDwvZz4KPC9zdmc+Cg==);--jp-icon-console: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwMCAyMDAiPgogIDxnIGNsYXNzPSJqcC1pY29uLWJyYW5kMSBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiMwMjg4RDEiPgogICAgPHBhdGggZD0iTTIwIDE5LjhoMTYwdjE1OS45SDIweiIvPgogIDwvZz4KICA8ZyBjbGFzcz0ianAtaWNvbi1zZWxlY3RhYmxlLWludmVyc2UiIGZpbGw9IiNmZmYiPgogICAgPHBhdGggZD0iTTEwNSAxMjcuM2g0MHYxMi44aC00MHpNNTEuMSA3N0w3NCA5OS45bC0yMy4zIDIzLjMgMTAuNSAxMC41IDIzLjMtMjMuM0w5NSA5OS45IDg0LjUgODkuNCA2MS42IDY2LjV6Ii8+CiAgPC9nPgo8L3N2Zz4K);--jp-icon-copy: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTggMTgiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTExLjksMUgzLjJDMi40LDEsMS43LDEuNywxLjcsMi41djEwLjJoMS41VjIuNWg4LjdWMXogTTE0LjEsMy45aC04Yy0wLjgsMC0xLjUsMC43LTEuNSwxLjV2MTAuMmMwLDAuOCwwLjcsMS41LDEuNSwxLjVoOCBjMC44LDAsMS41LTAuNywxLjUtMS41VjUuNEMxNS41LDQuNiwxNC45LDMuOSwxNC4xLDMuOXogTTE0LjEsMTUuNWgtOFY1LjRoOFYxNS41eiIvPgogIDwvZz4KPC9zdmc+Cg==);--jp-icon-cut: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTkuNjQgNy42NGMuMjMtLjUuMzYtMS4wNS4zNi0xLjY0IDAtMi4yMS0xLjc5LTQtNC00UzIgMy43OSAyIDZzMS43OSA0IDQgNGMuNTkgMCAxLjE0LS4xMyAxLjY0LS4zNkwxMCAxMmwtMi4zNiAyLjM2QzcuMTQgMTQuMTMgNi41OSAxNCA2IDE0Yy0yLjIxIDAtNCAxLjc5LTQgNHMxLjc5IDQgNCA0IDQtMS43OSA0LTRjMC0uNTktLjEzLTEuMTQtLjM2LTEuNjRMMTIgMTRsNyA3aDN2LTFMOS42NCA3LjY0ek02IDhjLTEuMSAwLTItLjg5LTItMnMuOS0yIDItMiAyIC44OSAyIDItLjkgMi0yIDJ6bTAgMTJjLTEuMSAwLTItLjg5LTItMnMuOS0yIDItMiAyIC44OSAyIDItLjkgMi0yIDJ6bTYtNy41Yy0uMjggMC0uNS0uMjItLjUtLjVzLjIyLS41LjUtLjUuNS4yMi41LjUtLjIyLjUtLjUuNXpNMTkgM2wtNiA2IDIgMiA3LTdWM3oiLz4KICA8L2c+Cjwvc3ZnPgo=);--jp-icon-download: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE5IDloLTRWM0g5djZINWw3IDcgNy03ek01IDE4djJoMTR2LTJINXoiLz4KICA8L2c+Cjwvc3ZnPgo=);--jp-icon-edit: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTMgMTcuMjVWMjFoMy43NUwxNy44MSA5Ljk0bC0zLjc1LTMuNzVMMyAxNy4yNXpNMjAuNzEgNy4wNGMuMzktLjM5LjM5LTEuMDIgMC0xLjQxbC0yLjM0LTIuMzRjLS4zOS0uMzktMS4wMi0uMzktMS40MSAwbC0xLjgzIDEuODMgMy43NSAzLjc1IDEuODMtMS44M3oiLz4KICA8L2c+Cjwvc3ZnPgo=);--jp-icon-ellipses: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPGNpcmNsZSBjeD0iNSIgY3k9IjEyIiByPSIyIi8+CiAgICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIyIi8+CiAgICA8Y2lyY2xlIGN4PSIxOSIgY3k9IjEyIiByPSIyIi8+CiAgPC9nPgo8L3N2Zz4K);--jp-icon-extension: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTIwLjUgMTFIMTlWN2MwLTEuMS0uOS0yLTItMmgtNFYzLjVDMTMgMi4xMiAxMS44OCAxIDEwLjUgMVM4IDIuMTIgOCAzLjVWNUg0Yy0xLjEgMC0xLjk5LjktMS45OSAydjMuOEgzLjVjMS40OSAwIDIuNyAxLjIxIDIuNyAyLjdzLTEuMjEgMi43LTIuNyAyLjdIMlYyMGMwIDEuMS45IDIgMiAyaDMuOHYtMS41YzAtMS40OSAxLjIxLTIuNyAyLjctMi43IDEuNDkgMCAyLjcgMS4yMSAyLjcgMi43VjIySDE3YzEuMSAwIDItLjkgMi0ydi00aDEuNWMxLjM4IDAgMi41LTEuMTIgMi41LTIuNVMyMS44OCAxMSAyMC41IDExeiIvPgogIDwvZz4KPC9zdmc+Cg==);--jp-icon-fast-forward: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTQgMThsOC41LTZMNCA2djEyem05LTEydjEybDguNS02TDEzIDZ6Ii8+CiAgICA8L2c+Cjwvc3ZnPgo=);--jp-icon-file-upload: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTkgMTZoNnYtNmg0bC03LTctNyA3aDR6bS00IDJoMTR2Mkg1eiIvPgogIDwvZz4KPC9zdmc+Cg==);--jp-icon-file: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTkuMyA4LjJsLTUuNS01LjVjLS4zLS4zLS43LS41LTEuMi0uNUgzLjljLS44LjEtMS42LjktMS42IDEuOHYxNC4xYzAgLjkuNyAxLjYgMS42IDEuNmgxNC4yYy45IDAgMS42LS43IDEuNi0xLjZWOS40Yy4xLS41LS4xLS45LS40LTEuMnptLTUuOC0zLjNsMy40IDMuNmgtMy40VjQuOXptMy45IDEyLjdINC43Yy0uMSAwLS4yIDAtLjItLjJWNC43YzAtLjIuMS0uMy4yLS4zaDcuMnY0LjRzMCAuOC4zIDEuMWMuMy4zIDEuMS4zIDEuMS4zaDQuM3Y3LjJzLS4xLjItLjIuMnoiLz4KPC9zdmc+Cg==);--jp-icon-filter-list: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEwIDE4aDR2LTJoLTR2MnpNMyA2djJoMThWNkgzem0zIDdoMTJ2LTJINnYyeiIvPgogIDwvZz4KPC9zdmc+Cg==);--jp-icon-folder: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTAgNEg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMThjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY4YzAtMS4xLS45LTItMi0yaC04bC0yLTJ6Ii8+Cjwvc3ZnPgo=);--jp-icon-html5: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDUxMiA1MTIiPgogIDxwYXRoIGNsYXNzPSJqcC1pY29uMCBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiMwMDAiIGQ9Ik0xMDguNCAwaDIzdjIyLjhoMjEuMlYwaDIzdjY5aC0yM1Y0NmgtMjF2MjNoLTIzLjJNMjA2IDIzaC0yMC4zVjBoNjMuN3YyM0gyMjl2NDZoLTIzbTUzLjUtNjloMjQuMWwxNC44IDI0LjNMMzEzLjIgMGgyNC4xdjY5aC0yM1YzNC44bC0xNi4xIDI0LjgtMTYuMS0yNC44VjY5aC0yMi42bTg5LjItNjloMjN2NDYuMmgzMi42VjY5aC01NS42Ii8+CiAgPHBhdGggY2xhc3M9ImpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iI2U0NGQyNiIgZD0iTTEwNy42IDQ3MWwtMzMtMzcwLjRoMzYyLjhsLTMzIDM3MC4yTDI1NS43IDUxMiIvPgogIDxwYXRoIGNsYXNzPSJqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiNmMTY1MjkiIGQ9Ik0yNTYgNDgwLjVWMTMxaDE0OC4zTDM3NiA0NDciLz4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1zZWxlY3RhYmxlLWludmVyc2UiIGZpbGw9IiNlYmViZWIiIGQ9Ik0xNDIgMTc2LjNoMTE0djQ1LjRoLTY0LjJsNC4yIDQ2LjVoNjB2NDUuM0gxNTQuNG0yIDIyLjhIMjAybDMuMiAzNi4zIDUwLjggMTMuNnY0Ny40bC05My4yLTI2Ii8+CiAgPHBhdGggY2xhc3M9ImpwLWljb24tc2VsZWN0YWJsZS1pbnZlcnNlIiBmaWxsPSIjZmZmIiBkPSJNMzY5LjYgMTc2LjNIMjU1Ljh2NDUuNGgxMDkuNm0tNC4xIDQ2LjVIMjU1Ljh2NDUuNGg1NmwtNS4zIDU5LTUwLjcgMTMuNnY0Ny4ybDkzLTI1LjgiLz4KPC9zdmc+Cg==);--jp-icon-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1icmFuZDQganAtaWNvbi1zZWxlY3RhYmxlLWludmVyc2UiIGZpbGw9IiNGRkYiIGQ9Ik0yLjIgMi4yaDE3LjV2MTcuNUgyLjJ6Ii8+CiAgPHBhdGggY2xhc3M9ImpwLWljb24tYnJhbmQwIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzNGNTFCNSIgZD0iTTIuMiAyLjJ2MTcuNWgxNy41bC4xLTE3LjVIMi4yem0xMi4xIDIuMmMxLjIgMCAyLjIgMSAyLjIgMi4ycy0xIDIuMi0yLjIgMi4yLTIuMi0xLTIuMi0yLjIgMS0yLjIgMi4yLTIuMnpNNC40IDE3LjZsMy4zLTguOCAzLjMgNi42IDIuMi0zLjIgNC40IDUuNEg0LjR6Ii8+Cjwvc3ZnPgo=);--jp-icon-inspector: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMjAgNEg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMThjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY2YzAtMS4xLS45LTItMi0yem0tNSAxNEg0di00aDExdjR6bTAtNUg0VjloMTF2NHptNSA1aC00VjloNHY5eiIvPgo8L3N2Zz4K);--jp-icon-json: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtaWNvbi13YXJuMSBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiNGOUE4MjUiPgogICAgPHBhdGggZD0iTTIwLjIgMTEuOGMtMS42IDAtMS43LjUtMS43IDEgMCAuNC4xLjkuMSAxLjMuMS41LjEuOS4xIDEuMyAwIDEuNy0xLjQgMi4zLTMuNSAyLjNoLS45di0xLjloLjVjMS4xIDAgMS40IDAgMS40LS44IDAtLjMgMC0uNi0uMS0xIDAtLjQtLjEtLjgtLjEtMS4yIDAtMS4zIDAtMS44IDEuMy0yLTEuMy0uMi0xLjMtLjctMS4zLTIgMC0uNC4xLS44LjEtMS4yLjEtLjQuMS0uNy4xLTEgMC0uOC0uNC0uNy0xLjQtLjhoLS41VjQuMWguOWMyLjIgMCAzLjUuNyAzLjUgMi4zIDAgLjQtLjEuOS0uMSAxLjMtLjEuNS0uMS45LS4xIDEuMyAwIC41LjIgMSAxLjcgMXYxLjh6TTEuOCAxMC4xYzEuNiAwIDEuNy0uNSAxLjctMSAwLS40LS4xLS45LS4xLTEuMy0uMS0uNS0uMS0uOS0uMS0xLjMgMC0xLjYgMS40LTIuMyAzLjUtMi4zaC45djEuOWgtLjVjLTEgMC0xLjQgMC0xLjQuOCAwIC4zIDAgLjYuMSAxIDAgLjIuMS42LjEgMSAwIDEuMyAwIDEuOC0xLjMgMkM2IDExLjIgNiAxMS43IDYgMTNjMCAuNC0uMS44LS4xIDEuMi0uMS4zLS4xLjctLjEgMSAwIC44LjMuOCAxLjQuOGguNXYxLjloLS45Yy0yLjEgMC0zLjUtLjYtMy41LTIuMyAwLS40LjEtLjkuMS0xLjMuMS0uNS4xLS45LjEtMS4zIDAtLjUtLjItMS0xLjctMXYtMS45eiIvPgogICAgPGNpcmNsZSBjeD0iMTEiIGN5PSIxMy44IiByPSIyLjEiLz4KICAgIDxjaXJjbGUgY3g9IjExIiBjeT0iOC4yIiByPSIyLjEiLz4KICA8L2c+Cjwvc3ZnPgo=);--jp-icon-jupyter-favicon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUyIiBoZWlnaHQ9IjE2NSIgdmlld0JveD0iMCAwIDE1MiAxNjUiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbi13YXJuMCIgZmlsbD0iI0YzNzcyNiI+CiAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjA3ODk0NywgMTEwLjU4MjkyNykiIGQ9Ik03NS45NDIyODQyLDI5LjU4MDQ1NjEgQzQzLjMwMjM5NDcsMjkuNTgwNDU2MSAxNC43OTY3ODMyLDE3LjY1MzQ2MzQgMCwwIEM1LjUxMDgzMjExLDE1Ljg0MDY4MjkgMTUuNzgxNTM4OSwyOS41NjY3NzMyIDI5LjM5MDQ5NDcsMzkuMjc4NDE3MSBDNDIuOTk5Nyw0OC45ODk4NTM3IDU5LjI3MzcsNTQuMjA2NzgwNSA3NS45NjA1Nzg5LDU0LjIwNjc4MDUgQzkyLjY0NzQ1NzksNTQuMjA2NzgwNSAxMDguOTIxNDU4LDQ4Ljk4OTg1MzcgMTIyLjUzMDY2MywzOS4yNzg0MTcxIEMxMzYuMTM5NDUzLDI5LjU2Njc3MzIgMTQ2LjQxMDI4NCwxNS44NDA2ODI5IDE1MS45MjExNTgsMCBDMTM3LjA4Nzg2OCwxNy42NTM0NjM0IDEwOC41ODI1ODksMjkuNTgwNDU2MSA3NS45NDIyODQyLDI5LjU4MDQ1NjEgTDc1Ljk0MjI4NDIsMjkuNTgwNDU2MSBaIiAvPgogICAgPHBhdGggdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMzczNjgsIDAuNzA0ODc4KSIgZD0iTTc1Ljk3ODQ1NzksMjQuNjI2NDA3MyBDMTA4LjYxODc2MywyNC42MjY0MDczIDEzNy4xMjQ0NTgsMzYuNTUzNDQxNSAxNTEuOTIxMTU4LDU0LjIwNjc4MDUgQzE0Ni40MTAyODQsMzguMzY2MjIyIDEzNi4xMzk0NTMsMjQuNjQwMTMxNyAxMjIuNTMwNjYzLDE0LjkyODQ4NzggQzEwOC45MjE0NTgsNS4yMTY4NDM5IDkyLjY0NzQ1NzksMCA3NS45NjA1Nzg5LDAgQzU5LjI3MzcsMCA0Mi45OTk3LDUuMjE2ODQzOSAyOS4zOTA0OTQ3LDE0LjkyODQ4NzggQzE1Ljc4MTUzODksMjQuNjQwMTMxNyA1LjUxMDgzMjExLDM4LjM2NjIyMiAwLDU0LjIwNjc4MDUgQzE0LjgzMzA4MTYsMzYuNTg5OTI5MyA0My4zMzg1Njg0LDI0LjYyNjQwNzMgNzUuOTc4NDU3OSwyNC42MjY0MDczIEw3NS45Nzg0NTc5LDI0LjYyNjQwNzMgWiIgLz4KICA8L2c+Cjwvc3ZnPgo=);--jp-icon-jupyter: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzkiIGhlaWdodD0iNTEiIHZpZXdCb3g9IjAgMCAzOSA1MSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTYzOCAtMjI4MSkiPgogICAgPGcgY2xhc3M9ImpwLWljb24td2FybjAiIGZpbGw9IiNGMzc3MjYiPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjM5Ljc0IDIzMTEuOTgpIiBkPSJNIDE4LjI2NDYgNy4xMzQxMUMgMTAuNDE0NSA3LjEzNDExIDMuNTU4NzIgNC4yNTc2IDAgMEMgMS4zMjUzOSAzLjgyMDQgMy43OTU1NiA3LjEzMDgxIDcuMDY4NiA5LjQ3MzAzQyAxMC4zNDE3IDExLjgxNTIgMTQuMjU1NyAxMy4wNzM0IDE4LjI2OSAxMy4wNzM0QyAyMi4yODIzIDEzLjA3MzQgMjYuMTk2MyAxMS44MTUyIDI5LjQ2OTQgOS40NzMwM0MgMzIuNzQyNCA3LjEzMDgxIDM1LjIxMjYgMy44MjA0IDM2LjUzOCAwQyAzMi45NzA1IDQuMjU3NiAyNi4xMTQ4IDcuMTM0MTEgMTguMjY0NiA3LjEzNDExWiIvPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjM5LjczIDIyODUuNDgpIiBkPSJNIDE4LjI3MzMgNS45MzkzMUMgMjYuMTIzNSA1LjkzOTMxIDMyLjk3OTMgOC44MTU4MyAzNi41MzggMTMuMDczNEMgMzUuMjEyNiA5LjI1MzAzIDMyLjc0MjQgNS45NDI2MiAyOS40Njk0IDMuNjAwNEMgMjYuMTk2MyAxLjI1ODE4IDIyLjI4MjMgMCAxOC4yNjkgMEMgMTQuMjU1NyAwIDEwLjM0MTcgMS4yNTgxOCA3LjA2ODYgMy42MDA0QyAzLjc5NTU2IDUuOTQyNjIgMS4zMjUzOSA5LjI1MzAzIDAgMTMuMDczNEMgMy41Njc0NSA4LjgyNDYzIDEwLjQyMzIgNS45MzkzMSAxOC4yNzMzIDUuOTM5MzFaIi8+CiAgICA8L2c+CiAgICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjY5LjMgMjI4MS4zMSkiIGQ9Ik0gNS44OTM1MyAyLjg0NEMgNS45MTg4OSAzLjQzMTY1IDUuNzcwODUgNC4wMTM2NyA1LjQ2ODE1IDQuNTE2NDVDIDUuMTY1NDUgNS4wMTkyMiA0LjcyMTY4IDUuNDIwMTUgNC4xOTI5OSA1LjY2ODUxQyAzLjY2NDMgNS45MTY4OCAzLjA3NDQ0IDYuMDAxNTEgMi40OTgwNSA1LjkxMTcxQyAxLjkyMTY2IDUuODIxOSAxLjM4NDYzIDUuNTYxNyAwLjk1NDg5OCA1LjE2NDAxQyAwLjUyNTE3IDQuNzY2MzMgMC4yMjIwNTYgNC4yNDkwMyAwLjA4MzkwMzcgMy42Nzc1N0MgLTAuMDU0MjQ4MyAzLjEwNjExIC0wLjAyMTIzIDIuNTA2MTcgMC4xNzg3ODEgMS45NTM2NEMgMC4zNzg3OTMgMS40MDExIDAuNzM2ODA5IDAuOTIwODE3IDEuMjA3NTQgMC41NzM1MzhDIDEuNjc4MjYgMC4yMjYyNTkgMi4yNDA1NSAwLjAyNzU5MTkgMi44MjMyNiAwLjAwMjY3MjI5QyAzLjYwMzg5IC0wLjAzMDcxMTUgNC4zNjU3MyAwLjI0OTc4OSA0Ljk0MTQyIDAuNzgyNTUxQyA1LjUxNzExIDEuMzE1MzEgNS44NTk1NiAyLjA1Njc2IDUuODkzNTMgMi44NDRaIi8+CiAgICAgIDxwYXRoIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2MzkuOCAyMzIzLjgxKSIgZD0iTSA3LjQyNzg5IDMuNTgzMzhDIDcuNDYwMDggNC4zMjQzIDcuMjczNTUgNS4wNTgxOSA2Ljg5MTkzIDUuNjkyMTNDIDYuNTEwMzEgNi4zMjYwNyA1Ljk1MDc1IDYuODMxNTYgNS4yODQxMSA3LjE0NDZDIDQuNjE3NDcgNy40NTc2MyAzLjg3MzcxIDcuNTY0MTQgMy4xNDcwMiA3LjQ1MDYzQyAyLjQyMDMyIDcuMzM3MTIgMS43NDMzNiA3LjAwODcgMS4yMDE4NCA2LjUwNjk1QyAwLjY2MDMyOCA2LjAwNTIgMC4yNzg2MSA1LjM1MjY4IDAuMTA1MDE3IDQuNjMyMDJDIC0wLjA2ODU3NTcgMy45MTEzNSAtMC4wMjYyMzYxIDMuMTU0OTQgMC4yMjY2NzUgMi40NTg1NkMgMC40Nzk1ODcgMS43NjIxNyAwLjkzMTY5NyAxLjE1NzEzIDEuNTI1NzYgMC43MjAwMzNDIDIuMTE5ODMgMC4yODI5MzUgMi44MjkxNCAwLjAzMzQzOTUgMy41NjM4OSAwLjAwMzEzMzQ0QyA0LjU0NjY3IC0wLjAzNzQwMzMgNS41MDUyOSAwLjMxNjcwNiA2LjIyOTYxIDAuOTg3ODM1QyA2Ljk1MzkzIDEuNjU4OTYgNy4zODQ4NCAyLjU5MjM1IDcuNDI3ODkgMy41ODMzOEwgNy40Mjc4OSAzLjU4MzM4WiIvPgogICAgICA8cGF0aCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjM4LjM2IDIyODYuMDYpIiBkPSJNIDIuMjc0NzEgNC4zOTYyOUMgMS44NDM2MyA0LjQxNTA4IDEuNDE2NzEgNC4zMDQ0NSAxLjA0Nzk5IDQuMDc4NDNDIDAuNjc5MjY4IDMuODUyNCAwLjM4NTMyOCAzLjUyMTE0IDAuMjAzMzcxIDMuMTI2NTZDIDAuMDIxNDEzNiAyLjczMTk4IC0wLjA0MDM3OTggMi4yOTE4MyAwLjAyNTgxMTYgMS44NjE4MUMgMC4wOTIwMDMxIDEuNDMxOCAwLjI4MzIwNCAxLjAzMTI2IDAuNTc1MjEzIDAuNzEwODgzQyAwLjg2NzIyMiAwLjM5MDUxIDEuMjQ2OTEgMC4xNjQ3MDggMS42NjYyMiAwLjA2MjA1OTJDIDIuMDg1NTMgLTAuMDQwNTg5NyAyLjUyNTYxIC0wLjAxNTQ3MTQgMi45MzA3NiAwLjEzNDIzNUMgMy4zMzU5MSAwLjI4Mzk0MSAzLjY4NzkyIDAuNTUxNTA1IDMuOTQyMjIgMC45MDMwNkMgNC4xOTY1MiAxLjI1NDYyIDQuMzQxNjkgMS42NzQzNiA0LjM1OTM1IDIuMTA5MTZDIDQuMzgyOTkgMi42OTEwNyA0LjE3Njc4IDMuMjU4NjkgMy43ODU5NyAzLjY4NzQ2QyAzLjM5NTE2IDQuMTE2MjQgMi44NTE2NiA0LjM3MTE2IDIuMjc0NzEgNC4zOTYyOUwgMi4yNzQ3MSA0LjM5NjI5WiIvPgogICAgPC9nPgogIDwvZz4+Cjwvc3ZnPgo=);--jp-icon-jupyterlab-wordmark: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDAiIHZpZXdCb3g9IjAgMCAxODYwLjggNDc1Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiM0RTRFNEUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQ4MC4xMzY0MDEsIDY0LjI3MTQ5MykiPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDU4Ljg3NTU2NikiPgogICAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjA4NzYwMywgMC4xNDAyOTQpIj4KICAgICAgICA8cGF0aCBkPSJNLTQyNi45LDE2OS44YzAsNDguNy0zLjcsNjQuNy0xMy42LDc2LjRjLTEwLjgsMTAtMjUsMTUuNS0zOS43LDE1LjVsMy43LDI5IGMyMi44LDAuMyw0NC44LTcuOSw2MS45LTIzLjFjMTcuOC0xOC41LDI0LTQ0LjEsMjQtODMuM1YwSC00Mjd2MTcwLjFMLTQyNi45LDE2OS44TC00MjYuOSwxNjkuOHoiLz4KICAgICAgPC9nPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTU1LjA0NTI5NiwgNTYuODM3MTA0KSI+CiAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEuNTYyNDUzLCAxLjc5OTg0MikiPgogICAgICAgIDxwYXRoIGQ9Ik0tMzEyLDE0OGMwLDIxLDAsMzkuNSwxLjcsNTUuNGgtMzEuOGwtMi4xLTMzLjNoLTAuOGMtNi43LDExLjYtMTYuNCwyMS4zLTI4LDI3LjkgYy0xMS42LDYuNi0yNC44LDEwLTM4LjIsOS44Yy0zMS40LDAtNjktMTcuNy02OS04OVYwaDM2LjR2MTEyLjdjMCwzOC43LDExLjYsNjQuNyw0NC42LDY0LjdjMTAuMy0wLjIsMjAuNC0zLjUsMjguOS05LjQgYzguNS01LjksMTUuMS0xNC4zLDE4LjktMjMuOWMyLjItNi4xLDMuMy0xMi41LDMuMy0xOC45VjAuMmgzNi40VjE0OEgtMzEyTC0zMTIsMTQ4eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzOTAuMDEzMzIyLCA1My40Nzk2MzgpIj4KICAgICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMS43MDY0NTgsIDAuMjMxNDI1KSI+CiAgICAgICAgPHBhdGggZD0iTS00NzguNiw3MS40YzAtMjYtMC44LTQ3LTEuNy02Ni43aDMyLjdsMS43LDM0LjhoMC44YzcuMS0xMi41LDE3LjUtMjIuOCwzMC4xLTI5LjcgYzEyLjUtNywyNi43LTEwLjMsNDEtOS44YzQ4LjMsMCw4NC43LDQxLjcsODQuNywxMDMuM2MwLDczLjEtNDMuNywxMDkuMi05MSwxMDkuMmMtMTIuMSwwLjUtMjQuMi0yLjItMzUtNy44IGMtMTAuOC01LjYtMTkuOS0xMy45LTI2LjYtMjQuMmgtMC44VjI5MWgtMzZ2LTIyMEwtNDc4LjYsNzEuNEwtNDc4LjYsNzEuNHogTS00NDIuNiwxMjUuNmMwLjEsNS4xLDAuNiwxMC4xLDEuNywxNS4xIGMzLDEyLjMsOS45LDIzLjMsMTkuOCwzMS4xYzkuOSw3LjgsMjIuMSwxMi4xLDM0LjcsMTIuMWMzOC41LDAsNjAuNy0zMS45LDYwLjctNzguNWMwLTQwLjctMjEuMS03NS42LTU5LjUtNzUuNiBjLTEyLjksMC40LTI1LjMsNS4xLTM1LjMsMTMuNGMtOS45LDguMy0xNi45LDE5LjctMTkuNiwzMi40Yy0xLjUsNC45LTIuMywxMC0yLjUsMTUuMVYxMjUuNkwtNDQyLjYsMTI1LjZMLTQ0Mi42LDEyNS42eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg2MDYuNzQwNzI2LCA1Ni44MzcxMDQpIj4KICAgICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC43NTEyMjYsIDEuOTg5Mjk5KSI+CiAgICAgICAgPHBhdGggZD0iTS00NDAuOCwwbDQzLjcsMTIwLjFjNC41LDEzLjQsOS41LDI5LjQsMTIuOCw0MS43aDAuOGMzLjctMTIuMiw3LjktMjcuNywxMi44LTQyLjQgbDM5LjctMTE5LjJoMzguNUwtMzQ2LjksMTQ1Yy0yNiw2OS43LTQzLjcsMTA1LjQtNjguNiwxMjcuMmMtMTIuNSwxMS43LTI3LjksMjAtNDQuNiwyMy45bC05LjEtMzEuMSBjMTEuNy0zLjksMjIuNS0xMC4xLDMxLjgtMTguMWMxMy4yLTExLjEsMjMuNy0yNS4yLDMwLjYtNDEuMmMxLjUtMi44LDIuNS01LjcsMi45LTguOGMtMC4zLTMuMy0xLjItNi42LTIuNS05LjdMLTQ4MC4yLDAuMSBoMzkuN0wtNDQwLjgsMEwtNDQwLjgsMHoiLz4KICAgICAgPC9nPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODIyLjc0ODEwNCwgMC4wMDAwMDApIj4KICAgICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMS40NjQwNTAsIDAuMzc4OTE0KSI+CiAgICAgICAgPHBhdGggZD0iTS00MTMuNywwdjU4LjNoNTJ2MjguMmgtNTJWMTk2YzAsMjUsNywzOS41LDI3LjMsMzkuNWM3LjEsMC4xLDE0LjItMC43LDIxLjEtMi41IGwxLjcsMjcuN2MtMTAuMywzLjctMjEuMyw1LjQtMzIuMiw1Yy03LjMsMC40LTE0LjYtMC43LTIxLjMtMy40Yy02LjgtMi43LTEyLjktNi44LTE3LjktMTIuMWMtMTAuMy0xMC45LTE0LjEtMjktMTQuMS01Mi45IFY4Ni41aC0zMVY1OC4zaDMxVjkuNkwtNDEzLjcsMEwtNDEzLjcsMHoiLz4KICAgICAgPC9nPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOTc0LjQzMzI4NiwgNTMuNDc5NjM4KSI+CiAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuOTkwMDM0LCAwLjYxMDMzOSkiPgogICAgICAgIDxwYXRoIGQ9Ik0tNDQ1LjgsMTEzYzAuOCw1MCwzMi4yLDcwLjYsNjguNiw3MC42YzE5LDAuNiwzNy45LTMsNTUuMy0xMC41bDYuMiwyNi40IGMtMjAuOSw4LjktNDMuNSwxMy4xLTY2LjIsMTIuNmMtNjEuNSwwLTk4LjMtNDEuMi05OC4zLTEwMi41Qy00ODAuMiw0OC4yLTQ0NC43LDAtMzg2LjUsMGM2NS4yLDAsODIuNyw1OC4zLDgyLjcsOTUuNyBjLTAuMSw1LjgtMC41LDExLjUtMS4yLDE3LjJoLTE0MC42SC00NDUuOEwtNDQ1LjgsMTEzeiBNLTMzOS4yLDg2LjZjMC40LTIzLjUtOS41LTYwLjEtNTAuNC02MC4xIGMtMzYuOCwwLTUyLjgsMzQuNC01NS43LDYwLjFILTMzOS4yTC0zMzkuMiw4Ni42TC0zMzkuMiw4Ni42eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMjAxLjk2MTA1OCwgNTMuNDc5NjM4KSI+CiAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEuMTc5NjQwLCAwLjcwNTA2OCkiPgogICAgICAgIDxwYXRoIGQ9Ik0tNDc4LjYsNjhjMC0yMy45LTAuNC00NC41LTEuNy02My40aDMxLjhsMS4yLDM5LjloMS43YzkuMS0yNy4zLDMxLTQ0LjUsNTUuMy00NC41IGMzLjUtMC4xLDcsMC40LDEwLjMsMS4ydjM0LjhjLTQuMS0wLjktOC4yLTEuMy0xMi40LTEuMmMtMjUuNiwwLTQzLjcsMTkuNy00OC43LDQ3LjRjLTEsNS43LTEuNiwxMS41LTEuNywxNy4ydjEwOC4zaC0zNlY2OCBMLTQ3OC42LDY4eiIvPgogICAgICA8L2c+CiAgICA8L2c+CiAgPC9nPgoKICA8ZyBjbGFzcz0ianAtaWNvbi13YXJuMCIgZmlsbD0iI0YzNzcyNiI+CiAgICA8cGF0aCBkPSJNMTM1Mi4zLDMyNi4yaDM3VjI4aC0zN1YzMjYuMnogTTE2MDQuOCwzMjYuMmMtMi41LTEzLjktMy40LTMxLjEtMy40LTQ4Ljd2LTc2IGMwLTQwLjctMTUuMS04My4xLTc3LjMtODMuMWMtMjUuNiwwLTUwLDcuMS02Ni44LDE4LjFsOC40LDI0LjRjMTQuMy05LjIsMzQtMTUuMSw1My0xNS4xYzQxLjYsMCw0Ni4yLDMwLjIsNDYuMiw0N3Y0LjIgYy03OC42LTAuNC0xMjIuMywyNi41LTEyMi4zLDc1LjZjMCwyOS40LDIxLDU4LjQsNjIuMiw1OC40YzI5LDAsNTAuOS0xNC4zLDYyLjItMzAuMmgxLjNsMi45LDI1LjZIMTYwNC44eiBNMTU2NS43LDI1Ny43IGMwLDMuOC0wLjgsOC0yLjEsMTEuOGMtNS45LDE3LjItMjIuNywzNC00OS4yLDM0Yy0xOC45LDAtMzQuOS0xMS4zLTM0LjktMzUuM2MwLTM5LjUsNDUuOC00Ni42LDg2LjItNDUuOFYyNTcuN3ogTTE2OTguNSwzMjYuMiBsMS43LTMzLjZoMS4zYzE1LjEsMjYuOSwzOC43LDM4LjIsNjguMSwzOC4yYzQ1LjQsMCw5MS4yLTM2LjEsOTEuMi0xMDguOGMwLjQtNjEuNy0zNS4zLTEwMy43LTg1LjctMTAzLjcgYy0zMi44LDAtNTYuMywxNC43LTY5LjMsMzcuNGgtMC44VjI4aC0zNi42djI0NS43YzAsMTguMS0wLjgsMzguNi0xLjcsNTIuNUgxNjk4LjV6IE0xNzA0LjgsMjA4LjJjMC01LjksMS4zLTEwLjksMi4xLTE1LjEgYzcuNi0yOC4xLDMxLjEtNDUuNCw1Ni4zLTQ1LjRjMzkuNSwwLDYwLjUsMzQuOSw2MC41LDc1LjZjMCw0Ni42LTIzLjEsNzguMS02MS44LDc4LjFjLTI2LjksMC00OC4zLTE3LjYtNTUuNS00My4zIGMtMC44LTQuMi0xLjctOC44LTEuNy0xMy40VjIwOC4yeiIvPgogIDwvZz4KPC9zdmc+Cg==);--jp-icon-kernel: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgZmlsbD0iIzYxNjE2MSIgZD0iTTE1IDlIOXY2aDZWOXptLTIgNGgtMnYtMmgydjJ6bTgtMlY5aC0yVjdjMC0xLjEtLjktMi0yLTJoLTJWM2gtMnYyaC0yVjNIOXYySDdjLTEuMSAwLTIgLjktMiAydjJIM3YyaDJ2MkgzdjJoMnYyYzAgMS4xLjkgMiAyIDJoMnYyaDJ2LTJoMnYyaDJ2LTJoMmMxLjEgMCAyLS45IDItMnYtMmgydi0yaC0ydi0yaDJ6bS00IDZIN1Y3aDEwdjEweiIvPgo8L3N2Zz4K);--jp-icon-keyboard: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMjAgNUg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMTdjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY3YzAtMS4xLS45LTItMi0yem0tOSAzaDJ2MmgtMlY4em0wIDNoMnYyaC0ydi0yek04IDhoMnYySDhWOHptMCAzaDJ2Mkg4di0yem0tMSAySDV2LTJoMnYyem0wLTNINVY4aDJ2MnptOSA3SDh2LTJoOHYyem0wLTRoLTJ2LTJoMnYyem0wLTNoLTJWOGgydjJ6bTMgM2gtMnYtMmgydjJ6bTAtM2gtMlY4aDJ2MnoiLz4KPC9zdmc+Cg==);--jp-icon-launcher: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTkgMTlINVY1aDdWM0g1YTIgMiAwIDAwLTIgMnYxNGEyIDIgMCAwMDIgMmgxNGMxLjEgMCAyLS45IDItMnYtN2gtMnY3ek0xNCAzdjJoMy41OWwtOS44MyA5LjgzIDEuNDEgMS40MUwxOSA2LjQxVjEwaDJWM2gtN3oiLz4KPC9zdmc+Cg==);--jp-icon-line-form: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGZpbGw9IndoaXRlIiBkPSJNNS44OCA0LjEyTDEzLjc2IDEybC03Ljg4IDcuODhMOCAyMmwxMC0xMEw4IDJ6Ii8+Cjwvc3ZnPgo=);--jp-icon-link: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTMuOSAxMmMwLTEuNzEgMS4zOS0zLjEgMy4xLTMuMWg0VjdIN2MtMi43NiAwLTUgMi4yNC01IDVzMi4yNCA1IDUgNWg0di0xLjlIN2MtMS43MSAwLTMuMS0xLjM5LTMuMS0zLjF6TTggMTNoOHYtMkg4djJ6bTktNmgtNHYxLjloNGMxLjcxIDAgMy4xIDEuMzkgMy4xIDMuMXMtMS4zOSAzLjEtMy4xIDMuMWgtNFYxN2g0YzIuNzYgMCA1LTIuMjQgNS01cy0yLjI0LTUtNS01eiIvPgogIDwvZz4KPC9zdmc+Cg==);--jp-icon-list: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiM2MTYxNjEiIGQ9Ik0xOSA1djE0SDVWNWgxNG0xLjEtMkgzLjljLS41IDAtLjkuNC0uOS45djE2LjJjMCAuNC40LjkuOS45aDE2LjJjLjQgMCAuOS0uNS45LS45VjMuOWMwLS41LS41LS45LS45LS45ek0xMSA3aDZ2MmgtNlY3em0wIDRoNnYyaC02di0yem0wIDRoNnYyaC02ek03IDdoMnYySDd6bTAgNGgydjJIN3ptMCA0aDJ2Mkg3eiIvPgo8L3N2Zz4=);--jp-icon-listings-info: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pg0KPHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJDYXBhXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgNTAuOTc4IDUwLjk3OCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNTAuOTc4IDUwLjk3ODsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPGc+DQoJPGc+DQoJCTxnPg0KCQkJPHBhdGggc3R5bGU9ImZpbGw6IzAxMDAwMjsiIGQ9Ik00My41Miw3LjQ1OEMzOC43MTEsMi42NDgsMzIuMzA3LDAsMjUuNDg5LDBDMTguNjcsMCwxMi4yNjYsMi42NDgsNy40NTgsNy40NTgNCgkJCQljLTkuOTQzLDkuOTQxLTkuOTQzLDI2LjExOSwwLDM2LjA2MmM0LjgwOSw0LjgwOSwxMS4yMTIsNy40NTYsMTguMDMxLDcuNDU4YzAsMCwwLjAwMSwwLDAuMDAyLDANCgkJCQljNi44MTYsMCwxMy4yMjEtMi42NDgsMTguMDI5LTcuNDU4YzQuODA5LTQuODA5LDcuNDU3LTExLjIxMiw3LjQ1Ny0xOC4wM0M1MC45NzcsMTguNjcsNDguMzI4LDEyLjI2Niw0My41Miw3LjQ1OHoNCgkJCQkgTTQyLjEwNiw0Mi4xMDVjLTQuNDMyLDQuNDMxLTEwLjMzMiw2Ljg3Mi0xNi42MTUsNi44NzJoLTAuMDAyYy02LjI4NS0wLjAwMS0xMi4xODctMi40NDEtMTYuNjE3LTYuODcyDQoJCQkJYy05LjE2Mi05LjE2My05LjE2Mi0yNC4wNzEsMC0zMy4yMzNDMTMuMzAzLDQuNDQsMTkuMjA0LDIsMjUuNDg5LDJjNi4yODQsMCwxMi4xODYsMi40NCwxNi42MTcsNi44NzINCgkJCQljNC40MzEsNC40MzEsNi44NzEsMTAuMzMyLDYuODcxLDE2LjYxN0M0OC45NzcsMzEuNzcyLDQ2LjUzNiwzNy42NzUsNDIuMTA2LDQyLjEwNXoiLz4NCgkJPC9nPg0KCQk8Zz4NCgkJCTxwYXRoIHN0eWxlPSJmaWxsOiMwMTAwMDI7IiBkPSJNMjMuNTc4LDMyLjIxOGMtMC4wMjMtMS43MzQsMC4xNDMtMy4wNTksMC40OTYtMy45NzJjMC4zNTMtMC45MTMsMS4xMS0xLjk5NywyLjI3Mi0zLjI1Mw0KCQkJCWMwLjQ2OC0wLjUzNiwwLjkyMy0xLjA2MiwxLjM2Ny0xLjU3NWMwLjYyNi0wLjc1MywxLjEwNC0xLjQ3OCwxLjQzNi0yLjE3NWMwLjMzMS0wLjcwNywwLjQ5NS0xLjU0MSwwLjQ5NS0yLjUNCgkJCQljMC0xLjA5Ni0wLjI2LTIuMDg4LTAuNzc5LTIuOTc5Yy0wLjU2NS0wLjg3OS0xLjUwMS0xLjMzNi0yLjgwNi0xLjM2OWMtMS44MDIsMC4wNTctMi45ODUsMC42NjctMy41NSwxLjgzMg0KCQkJCWMtMC4zMDEsMC41MzUtMC41MDMsMS4xNDEtMC42MDcsMS44MTRjLTAuMTM5LDAuNzA3LTAuMjA3LDEuNDMyLTAuMjA3LDIuMTc0aC0yLjkzN2MtMC4wOTEtMi4yMDgsMC40MDctNC4xMTQsMS40OTMtNS43MTkNCgkJCQljMS4wNjItMS42NCwyLjg1NS0yLjQ4MSw1LjM3OC0yLjUyN2MyLjE2LDAuMDIzLDMuODc0LDAuNjA4LDUuMTQxLDEuNzU4YzEuMjc4LDEuMTYsMS45MjksMi43NjQsMS45NSw0LjgxMQ0KCQkJCWMwLDEuMTQyLTAuMTM3LDIuMTExLTAuNDEsMi45MTFjLTAuMzA5LDAuODQ1LTAuNzMxLDEuNTkzLTEuMjY4LDIuMjQzYy0wLjQ5MiwwLjY1LTEuMDY4LDEuMzE4LTEuNzMsMi4wMDINCgkJCQljLTAuNjUsMC42OTctMS4zMTMsMS40NzktMS45ODcsMi4zNDZjLTAuMjM5LDAuMzc3LTAuNDI5LDAuNzc3LTAuNTY1LDEuMTk5Yy0wLjE2LDAuOTU5LTAuMjE3LDEuOTUxLTAuMTcxLDIuOTc5DQoJCQkJQzI2LjU4OSwzMi4yMTgsMjMuNTc4LDMyLjIxOCwyMy41NzgsMzIuMjE4eiBNMjMuNTc4LDM4LjIydi0zLjQ4NGgzLjA3NnYzLjQ4NEgyMy41Nzh6Ii8+DQoJCTwvZz4NCgk8L2c+DQo8L2c+DQo8Zz4NCjwvZz4NCjxnPg0KPC9nPg0KPGc+DQo8L2c+DQo8Zz4NCjwvZz4NCjxnPg0KPC9nPg0KPGc+DQo8L2c+DQo8Zz4NCjwvZz4NCjxnPg0KPC9nPg0KPGc+DQo8L2c+DQo8Zz4NCjwvZz4NCjxnPg0KPC9nPg0KPGc+DQo8L2c+DQo8Zz4NCjwvZz4NCjxnPg0KPC9nPg0KPGc+DQo8L2c+DQo8L3N2Zz4NCg==);--jp-icon-markdown: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1jb250cmFzdDAganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjN0IxRkEyIiBkPSJNNSAxNC45aDEybC02LjEgNnptOS40LTYuOGMwLTEuMy0uMS0yLjktLjEtNC41LS40IDEuNC0uOSAyLjktMS4zIDQuM2wtMS4zIDQuM2gtMkw4LjUgNy45Yy0uNC0xLjMtLjctMi45LTEtNC4zLS4xIDEuNi0uMSAzLjItLjIgNC42TDcgMTIuNEg0LjhsLjctMTFoMy4zTDEwIDVjLjQgMS4yLjcgMi43IDEgMy45LjMtMS4yLjctMi42IDEtMy45bDEuMi0zLjdoMy4zbC42IDExaC0yLjRsLS4zLTQuMnoiLz4KPC9zdmc+Cg==);--jp-icon-new-folder: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTIwIDZoLThsLTItMkg0Yy0xLjExIDAtMS45OS44OS0xLjk5IDJMMiAxOGMwIDEuMTEuODkgMiAyIDJoMTZjMS4xMSAwIDItLjg5IDItMlY4YzAtMS4xMS0uODktMi0yLTJ6bS0xIDhoLTN2M2gtMnYtM2gtM3YtMmgzVjloMnYzaDN2MnoiLz4KICA8L2c+Cjwvc3ZnPgo=);--jp-icon-not-trusted: url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI1IDI1Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgc3Ryb2tlPSIjMzMzMzMzIiBzdHJva2Utd2lkdGg9IjIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMgMykiIGQ9Ik0xLjg2MDk0IDExLjQ0MDlDMC44MjY0NDggOC43NzAyNyAwLjg2Mzc3OSA2LjA1NzY0IDEuMjQ5MDcgNC4xOTkzMkMyLjQ4MjA2IDMuOTMzNDcgNC4wODA2OCAzLjQwMzQ3IDUuNjAxMDIgMi44NDQ5QzcuMjM1NDkgMi4yNDQ0IDguODU2NjYgMS41ODE1IDkuOTg3NiAxLjA5NTM5QzExLjA1OTcgMS41ODM0MSAxMi42MDk0IDIuMjQ0NCAxNC4yMTggMi44NDMzOUMxNS43NTAzIDMuNDEzOTQgMTcuMzk5NSAzLjk1MjU4IDE4Ljc1MzkgNC4yMTM4NUMxOS4xMzY0IDYuMDcxNzcgMTkuMTcwOSA4Ljc3NzIyIDE4LjEzOSAxMS40NDA5QzE3LjAzMDMgMTQuMzAzMiAxNC42NjY4IDE3LjE4NDQgOS45OTk5OSAxOC45MzU0QzUuMzMzMTkgMTcuMTg0NCAyLjk2OTY4IDE0LjMwMzIgMS44NjA5NCAxMS40NDA5WiIvPgogICAgPHBhdGggY2xhc3M9ImpwLWljb24yIiBzdHJva2U9IiMzMzMzMzMiIHN0cm9rZS13aWR0aD0iMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOS4zMTU5MiA5LjMyMDMxKSIgZD0iTTcuMzY4NDIgMEwwIDcuMzY0NzkiLz4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgc3Ryb2tlPSIjMzMzMzMzIiBzdHJva2Utd2lkdGg9IjIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDkuMzE1OTIgMTYuNjgzNikgc2NhbGUoMSAtMSkiIGQ9Ik03LjM2ODQyIDBMMCA3LjM2NDc5Ii8+Cjwvc3ZnPgo=);--jp-icon-notebook: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtaWNvbi13YXJuMCBqcC1pY29uLXNlbGVjdGFibGUiIGZpbGw9IiNFRjZDMDAiPgogICAgPHBhdGggZD0iTTE4LjcgMy4zdjE1LjRIMy4zVjMuM2gxNS40bTEuNS0xLjVIMS44djE4LjNoMTguM2wuMS0xOC4zeiIvPgogICAgPHBhdGggZD0iTTE2LjUgMTYuNWwtNS40LTQuMy01LjYgNC4zdi0xMWgxMXoiLz4KICA8L2c+Cjwvc3ZnPgo=);--jp-icon-palette: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTE4IDEzVjIwSDRWNkg5LjAyQzkuMDcgNS4yOSA5LjI0IDQuNjIgOS41IDRINEMyLjkgNCAyIDQuOSAyIDZWMjBDMiAyMS4xIDIuOSAyMiA0IDIySDE4QzE5LjEgMjIgMjAgMjEuMSAyMCAyMFYxNUwxOCAxM1pNMTkuMyA4Ljg5QzE5Ljc0IDguMTkgMjAgNy4zOCAyMCA2LjVDMjAgNC4wMSAxNy45OSAyIDE1LjUgMkMxMy4wMSAyIDExIDQuMDEgMTEgNi41QzExIDguOTkgMTMuMDEgMTEgMTUuNDkgMTFDMTYuMzcgMTEgMTcuMTkgMTAuNzQgMTcuODggMTAuM0wyMSAxMy40MkwyMi40MiAxMkwxOS4zIDguODlaTTE1LjUgOUMxNC4xMiA5IDEzIDcuODggMTMgNi41QzEzIDUuMTIgMTQuMTIgNCAxNS41IDRDMTYuODggNCAxOCA1LjEyIDE4IDYuNUMxOCA3Ljg4IDE2Ljg4IDkgMTUuNSA5WiIvPgogICAgPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00IDZIOS4wMTg5NEM5LjAwNjM5IDYuMTY1MDIgOSA2LjMzMTc2IDkgNi41QzkgOC44MTU3NyAxMC4yMTEgMTAuODQ4NyAxMi4wMzQzIDEySDlWMTRIMTZWMTIuOTgxMUMxNi41NzAzIDEyLjkzNzcgMTcuMTIgMTIuODIwNyAxNy42Mzk2IDEyLjYzOTZMMTggMTNWMjBINFY2Wk04IDhINlYxMEg4VjhaTTYgMTJIOFYxNEg2VjEyWk04IDE2SDZWMThIOFYxNlpNOSAxNkgxNlYxOEg5VjE2WiIvPgogIDwvZz4KPC9zdmc+Cg==);--jp-icon-paste: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTE5IDJoLTQuMThDMTQuNC44NCAxMy4zIDAgMTIgMGMtMS4zIDAtMi40Ljg0LTIuODIgMkg1Yy0xLjEgMC0yIC45LTIgMnYxNmMwIDEuMS45IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjRjMC0xLjEtLjktMi0yLTJ6bS03IDBjLjU1IDAgMSAuNDUgMSAxcy0uNDUgMS0xIDEtMS0uNDUtMS0xIC40NS0xIDEtMXptNyAxOEg1VjRoMnYzaDEwVjRoMnYxNnoiLz4KICAgIDwvZz4KPC9zdmc+Cg==);--jp-icon-python: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtaWNvbi1icmFuZDAganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjMEQ0N0ExIj4KICAgIDxwYXRoIGQ9Ik0xMS4xIDYuOVY1LjhINi45YzAtLjUgMC0xLjMuMi0xLjYuNC0uNy44LTEuMSAxLjctMS40IDEuNy0uMyAyLjUtLjMgMy45LS4xIDEgLjEgMS45LjkgMS45IDEuOXY0LjJjMCAuNS0uOSAxLjYtMiAxLjZIOC44Yy0xLjUgMC0yLjQgMS40LTIuNCAyLjh2Mi4ySDQuN0MzLjUgMTUuMSAzIDE0IDMgMTMuMVY5Yy0uMS0xIC42LTIgMS44LTIgMS41LS4xIDYuMy0uMSA2LjMtLjF6Ii8+CiAgICA8cGF0aCBkPSJNMTAuOSAxNS4xdjEuMWg0LjJjMCAuNSAwIDEuMy0uMiAxLjYtLjQuNy0uOCAxLjEtMS43IDEuNC0xLjcuMy0yLjUuMy0zLjkuMS0xLS4xLTEuOS0uOS0xLjktMS45di00LjJjMC0uNS45LTEuNiAyLTEuNmgzLjhjMS41IDAgMi40LTEuNCAyLjQtMi44VjYuNmgxLjdDMTguNSA2LjkgMTkgOCAxOSA4LjlWMTNjMCAxLS43IDIuMS0xLjkgMi4xaC02LjJ6Ii8+CiAgPC9nPgo8L3N2Zz4K);--jp-icon-r-kernel: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1jb250cmFzdDMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjMjE5NkYzIiBkPSJNNC40IDIuNWMxLjItLjEgMi45LS4zIDQuOS0uMyAyLjUgMCA0LjEuNCA1LjIgMS4zIDEgLjcgMS41IDEuOSAxLjUgMy41IDAgMi0xLjQgMy41LTIuOSA0LjEgMS4yLjQgMS43IDEuNiAyLjIgMyAuNiAxLjkgMSAzLjkgMS4zIDQuNmgtMy44Yy0uMy0uNC0uOC0xLjctMS4yLTMuN3MtMS4yLTIuNi0yLjYtMi42aC0uOXY2LjRINC40VjIuNXptMy43IDYuOWgxLjRjMS45IDAgMi45LS45IDIuOS0yLjNzLTEtMi4zLTIuOC0yLjNjLS43IDAtMS4zIDAtMS42LjJ2NC41aC4xdi0uMXoiLz4KPC9zdmc+Cg==);--jp-icon-react: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMTUwIDE1MCA1NDEuOSAyOTUuMyI+CiAgPGcgY2xhc3M9ImpwLWljb24tYnJhbmQyIGpwLWljb24tc2VsZWN0YWJsZSIgZmlsbD0iIzYxREFGQiI+CiAgICA8cGF0aCBkPSJNNjY2LjMgMjk2LjVjMC0zMi41LTQwLjctNjMuMy0xMDMuMS04Mi40IDE0LjQtNjMuNiA4LTExNC4yLTIwLjItMTMwLjQtNi41LTMuOC0xNC4xLTUuNi0yMi40LTUuNnYyMi4zYzQuNiAwIDguMy45IDExLjQgMi42IDEzLjYgNy44IDE5LjUgMzcuNSAxNC45IDc1LjctMS4xIDkuNC0yLjkgMTkuMy01LjEgMjkuNC0xOS42LTQuOC00MS04LjUtNjMuNS0xMC45LTEzLjUtMTguNS0yNy41LTM1LjMtNDEuNi01MCAzMi42LTMwLjMgNjMuMi00Ni45IDg0LTQ2LjlWNzhjLTI3LjUgMC02My41IDE5LjYtOTkuOSA1My42LTM2LjQtMzMuOC03Mi40LTUzLjItOTkuOS01My4ydjIyLjNjMjAuNyAwIDUxLjQgMTYuNSA4NCA0Ni42LTE0IDE0LjctMjggMzEuNC00MS4zIDQ5LjktMjIuNiAyLjQtNDQgNi4xLTYzLjYgMTEtMi4zLTEwLTQtMTkuNy01LjItMjktNC43LTM4LjIgMS4xLTY3LjkgMTQuNi03NS44IDMtMS44IDYuOS0yLjYgMTEuNS0yLjZWNzguNWMtOC40IDAtMTYgMS44LTIyLjYgNS42LTI4LjEgMTYuMi0zNC40IDY2LjctMTkuOSAxMzAuMS02Mi4yIDE5LjItMTAyLjcgNDkuOS0xMDIuNyA4Mi4zIDAgMzIuNSA0MC43IDYzLjMgMTAzLjEgODIuNC0xNC40IDYzLjYtOCAxMTQuMiAyMC4yIDEzMC40IDYuNSAzLjggMTQuMSA1LjYgMjIuNSA1LjYgMjcuNSAwIDYzLjUtMTkuNiA5OS45LTUzLjYgMzYuNCAzMy44IDcyLjQgNTMuMiA5OS45IDUzLjIgOC40IDAgMTYtMS44IDIyLjYtNS42IDI4LjEtMTYuMiAzNC40LTY2LjcgMTkuOS0xMzAuMSA2Mi0xOS4xIDEwMi41LTQ5LjkgMTAyLjUtODIuM3ptLTEzMC4yLTY2LjdjLTMuNyAxMi45LTguMyAyNi4yLTEzLjUgMzkuNS00LjEtOC04LjQtMTYtMTMuMS0yNC00LjYtOC05LjUtMTUuOC0xNC40LTIzLjQgMTQuMiAyLjEgMjcuOSA0LjcgNDEgNy45em0tNDUuOCAxMDYuNWMtNy44IDEzLjUtMTUuOCAyNi4zLTI0LjEgMzguMi0xNC45IDEuMy0zMCAyLTQ1LjIgMi0xNS4xIDAtMzAuMi0uNy00NS0xLjktOC4zLTExLjktMTYuNC0yNC42LTI0LjItMzgtNy42LTEzLjEtMTQuNS0yNi40LTIwLjgtMzkuOCA2LjItMTMuNCAxMy4yLTI2LjggMjAuNy0zOS45IDcuOC0xMy41IDE1LjgtMjYuMyAyNC4xLTM4LjIgMTQuOS0xLjMgMzAtMiA0NS4yLTIgMTUuMSAwIDMwLjIuNyA0NSAxLjkgOC4zIDExLjkgMTYuNCAyNC42IDI0LjIgMzggNy42IDEzLjEgMTQuNSAyNi40IDIwLjggMzkuOC02LjMgMTMuNC0xMy4yIDI2LjgtMjAuNyAzOS45em0zMi4zLTEzYzUuNCAxMy40IDEwIDI2LjggMTMuOCAzOS44LTEzLjEgMy4yLTI2LjkgNS45LTQxLjIgOCA0LjktNy43IDkuOC0xNS42IDE0LjQtMjMuNyA0LjYtOCA4LjktMTYuMSAxMy0yNC4xek00MjEuMiA0MzBjLTkuMy05LjYtMTguNi0yMC4zLTI3LjgtMzIgOSAuNCAxOC4yLjcgMjcuNS43IDkuNCAwIDE4LjctLjIgMjcuOC0uNy05IDExLjctMTguMyAyMi40LTI3LjUgMzJ6bS03NC40LTU4LjljLTE0LjItMi4xLTI3LjktNC43LTQxLTcuOSAzLjctMTIuOSA4LjMtMjYuMiAxMy41LTM5LjUgNC4xIDggOC40IDE2IDEzLjEgMjQgNC43IDggOS41IDE1LjggMTQuNCAyMy40ek00MjAuNyAxNjNjOS4zIDkuNiAxOC42IDIwLjMgMjcuOCAzMi05LS40LTE4LjItLjctMjcuNS0uNy05LjQgMC0xOC43LjItMjcuOC43IDktMTEuNyAxOC4zLTIyLjQgMjcuNS0zMnptLTc0IDU4LjljLTQuOSA3LjctOS44IDE1LjYtMTQuNCAyMy43LTQuNiA4LTguOSAxNi0xMyAyNC01LjQtMTMuNC0xMC0yNi44LTEzLjgtMzkuOCAxMy4xLTMuMSAyNi45LTUuOCA0MS4yLTcuOXptLTkwLjUgMTI1LjJjLTM1LjQtMTUuMS01OC4zLTM0LjktNTguMy01MC42IDAtMTUuNyAyMi45LTM1LjYgNTguMy01MC42IDguNi0zLjcgMTgtNyAyNy43LTEwLjEgNS43IDE5LjYgMTMuMiA0MCAyMi41IDYwLjktOS4yIDIwLjgtMTYuNiA0MS4xLTIyLjIgNjAuNi05LjktMy4xLTE5LjMtNi41LTI4LTEwLjJ6TTMxMCA0OTBjLTEzLjYtNy44LTE5LjUtMzcuNS0xNC45LTc1LjcgMS4xLTkuNCAyLjktMTkuMyA1LjEtMjkuNCAxOS42IDQuOCA0MSA4LjUgNjMuNSAxMC45IDEzLjUgMTguNSAyNy41IDM1LjMgNDEuNiA1MC0zMi42IDMwLjMtNjMuMiA0Ni45LTg0IDQ2LjktNC41LS4xLTguMy0xLTExLjMtMi43em0yMzcuMi03Ni4yYzQuNyAzOC4yLTEuMSA2Ny45LTE0LjYgNzUuOC0zIDEuOC02LjkgMi42LTExLjUgMi42LTIwLjcgMC01MS40LTE2LjUtODQtNDYuNiAxNC0xNC43IDI4LTMxLjQgNDEuMy00OS45IDIyLjYtMi40IDQ0LTYuMSA2My42LTExIDIuMyAxMC4xIDQuMSAxOS44IDUuMiAyOS4xem0zOC41LTY2LjdjLTguNiAzLjctMTggNy0yNy43IDEwLjEtNS43LTE5LjYtMTMuMi00MC0yMi41LTYwLjkgOS4yLTIwLjggMTYuNi00MS4xIDIyLjItNjAuNiA5LjkgMy4xIDE5LjMgNi41IDI4LjEgMTAuMiAzNS40IDE1LjEgNTguMyAzNC45IDU4LjMgNTAuNi0uMSAxNS43LTIzIDM1LjYtNTguNCA1MC42ek0zMjAuOCA3OC40eiIvPgogICAgPGNpcmNsZSBjeD0iNDIwLjkiIGN5PSIyOTYuNSIgcj0iNDUuNyIvPgogIDwvZz4KPC9zdmc+Cg==);--jp-icon-refresh: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDE4IDE4Ij4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTkgMTMuNWMtMi40OSAwLTQuNS0yLjAxLTQuNS00LjVTNi41MSA0LjUgOSA0LjVjMS4yNCAwIDIuMzYuNTIgMy4xNyAxLjMzTDEwIDhoNVYzbC0xLjc2IDEuNzZDMTIuMTUgMy42OCAxMC42NiAzIDkgMyA1LjY5IDMgMy4wMSA1LjY5IDMuMDEgOVM1LjY5IDE1IDkgMTVjMi45NyAwIDUuNDMtMi4xNiA1LjktNWgtMS41MmMtLjQ2IDItMi4yNCAzLjUtNC4zOCAzLjV6Ii8+CiAgICA8L2c+Cjwvc3ZnPgo=);--jp-icon-regex: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIwIDIwIj4KICA8ZyBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiM0MTQxNDEiPgogICAgPHJlY3QgeD0iMiIgeT0iMiIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2Ii8+CiAgPC9nPgoKICA8ZyBjbGFzcz0ianAtaWNvbi1hY2NlbnQyIiBmaWxsPSIjRkZGIj4KICAgIDxjaXJjbGUgY2xhc3M9InN0MiIgY3g9IjUuNSIgY3k9IjE0LjUiIHI9IjEuNSIvPgogICAgPHJlY3QgeD0iMTIiIHk9IjQiIGNsYXNzPSJzdDIiIHdpZHRoPSIxIiBoZWlnaHQ9IjgiLz4KICAgIDxyZWN0IHg9IjguNSIgeT0iNy41IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjg2NiAtMC41IDAuNSAwLjg2NiAtMi4zMjU1IDcuMzIxOSkiIGNsYXNzPSJzdDIiIHdpZHRoPSI4IiBoZWlnaHQ9IjEiLz4KICAgIDxyZWN0IHg9IjEyIiB5PSI0IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjUgLTAuODY2IDAuODY2IDAuNSAtMC42Nzc5IDE0LjgyNTIpIiBjbGFzcz0ic3QyIiB3aWR0aD0iMSIgaGVpZ2h0PSI4Ii8+CiAgPC9nPgo8L3N2Zz4K);--jp-icon-run: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTggNXYxNGwxMS03eiIvPgogICAgPC9nPgo8L3N2Zz4K);--jp-icon-running: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDUxMiA1MTIiPgogIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICA8cGF0aCBkPSJNMjU2IDhDMTE5IDggOCAxMTkgOCAyNTZzMTExIDI0OCAyNDggMjQ4IDI0OC0xMTEgMjQ4LTI0OFMzOTMgOCAyNTYgOHptOTYgMzI4YzAgOC44LTcuMiAxNi0xNiAxNkgxNzZjLTguOCAwLTE2LTcuMi0xNi0xNlYxNzZjMC04LjggNy4yLTE2IDE2LTE2aDE2MGM4LjggMCAxNiA3LjIgMTYgMTZ2MTYweiIvPgogIDwvZz4KPC9zdmc+Cg==);--jp-icon-save: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTE3IDNINWMtMS4xMSAwLTIgLjktMiAydjE0YzAgMS4xLjg5IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjdsLTQtNHptLTUgMTZjLTEuNjYgMC0zLTEuMzQtMy0zczEuMzQtMyAzLTMgMyAxLjM0IDMgMy0xLjM0IDMtMyAzem0zLTEwSDVWNWgxMHY0eiIvPgogICAgPC9nPgo8L3N2Zz4K);--jp-icon-search: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTggMTgiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyLjEsMTAuOWgtMC43bC0wLjItMC4yYzAuOC0wLjksMS4zLTIuMiwxLjMtMy41YzAtMy0yLjQtNS40LTUuNC01LjRTMS44LDQuMiwxLjgsNy4xczIuNCw1LjQsNS40LDUuNCBjMS4zLDAsMi41LTAuNSwzLjUtMS4zbDAuMiwwLjJ2MC43bDQuMSw0LjFsMS4yLTEuMkwxMi4xLDEwLjl6IE03LjEsMTAuOWMtMi4xLDAtMy43LTEuNy0zLjctMy43czEuNy0zLjcsMy43LTMuN3MzLjcsMS43LDMuNywzLjcgUzkuMiwxMC45LDcuMSwxMC45eiIvPgogIDwvZz4KPC9zdmc+Cg==);--jp-icon-settings: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTkuNDMgMTIuOThjLjA0LS4zMi4wNy0uNjQuMDctLjk4cy0uMDMtLjY2LS4wNy0uOThsMi4xMS0xLjY1Yy4xOS0uMTUuMjQtLjQyLjEyLS42NGwtMi0zLjQ2Yy0uMTItLjIyLS4zOS0uMy0uNjEtLjIybC0yLjQ5IDFjLS41Mi0uNC0xLjA4LS43My0xLjY5LS45OGwtLjM4LTIuNjVBLjQ4OC40ODggMCAwMDE0IDJoLTRjLS4yNSAwLS40Ni4xOC0uNDkuNDJsLS4zOCAyLjY1Yy0uNjEuMjUtMS4xNy41OS0xLjY5Ljk4bC0yLjQ5LTFjLS4yMy0uMDktLjQ5IDAtLjYxLjIybC0yIDMuNDZjLS4xMy4yMi0uMDcuNDkuMTIuNjRsMi4xMSAxLjY1Yy0uMDQuMzItLjA3LjY1LS4wNy45OHMuMDMuNjYuMDcuOThsLTIuMTEgMS42NWMtLjE5LjE1LS4yNC40Mi0uMTIuNjRsMiAzLjQ2Yy4xMi4yMi4zOS4zLjYxLjIybDIuNDktMWMuNTIuNCAxLjA4LjczIDEuNjkuOThsLjM4IDIuNjVjLjAzLjI0LjI0LjQyLjQ5LjQyaDRjLjI1IDAgLjQ2LS4xOC40OS0uNDJsLjM4LTIuNjVjLjYxLS4yNSAxLjE3LS41OSAxLjY5LS45OGwyLjQ5IDFjLjIzLjA5LjQ5IDAgLjYxLS4yMmwyLTMuNDZjLjEyLS4yMi4wNy0uNDktLjEyLS42NGwtMi4xMS0xLjY1ek0xMiAxNS41Yy0xLjkzIDAtMy41LTEuNTctMy41LTMuNXMxLjU3LTMuNSAzLjUtMy41IDMuNSAxLjU3IDMuNSAzLjUtMS41NyAzLjUtMy41IDMuNXoiLz4KPC9zdmc+Cg==);--jp-icon-spreadsheet: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8cGF0aCBjbGFzcz0ianAtaWNvbi1jb250cmFzdDEganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNENBRjUwIiBkPSJNMi4yIDIuMnYxNy42aDE3LjZWMi4ySDIuMnptMTUuNCA3LjdoLTUuNVY0LjRoNS41djUuNXpNOS45IDQuNHY1LjVINC40VjQuNGg1LjV6bS01LjUgNy43aDUuNXY1LjVINC40di01LjV6bTcuNyA1LjV2LTUuNWg1LjV2NS41aC01LjV6Ii8+Cjwvc3ZnPgo=);--jp-icon-stop: url(data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxnIGNsYXNzPSJqcC1pY29uMyIgZmlsbD0iIzYxNjE2MSI+CiAgICAgICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPgogICAgICAgIDxwYXRoIGQ9Ik02IDZoMTJ2MTJINnoiLz4KICAgIDwvZz4KPC9zdmc+Cg==);--jp-icon-tab: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTIxIDNIM2MtMS4xIDAtMiAuOS0yIDJ2MTRjMCAxLjEuOSAyIDIgMmgxOGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0wIDE2SDNWNWgxMHY0aDh2MTB6Ii8+CiAgPC9nPgo8L3N2Zz4K);--jp-icon-terminal: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0IiA+CiAgICA8cmVjdCBjbGFzcz0ianAtaWNvbjIganAtaWNvbi1zZWxlY3RhYmxlIiB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIgMikiIGZpbGw9IiMzMzMzMzMiLz4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uLWFjY2VudDIganAtaWNvbi1zZWxlY3RhYmxlLWludmVyc2UiIGQ9Ik01LjA1NjY0IDguNzYxNzJDNS4wNTY2NCA4LjU5NzY2IDUuMDMxMjUgOC40NTMxMiA0Ljk4MDQ3IDguMzI4MTJDNC45MzM1OSA4LjE5OTIyIDQuODU1NDcgOC4wODIwMyA0Ljc0NjA5IDcuOTc2NTZDNC42NDA2MiA3Ljg3MTA5IDQuNSA3Ljc3NTM5IDQuMzI0MjIgNy42ODk0NUM0LjE1MjM0IDcuNTk5NjEgMy45NDMzNiA3LjUxMTcyIDMuNjk3MjcgNy40MjU3OEMzLjMwMjczIDcuMjg1MTYgMi45NDMzNiA3LjEzNjcyIDIuNjE5MTQgNi45ODA0N0MyLjI5NDkyIDYuODI0MjIgMi4wMTc1OCA2LjY0MjU4IDEuNzg3MTEgNi40MzU1NUMxLjU2MDU1IDYuMjI4NTIgMS4zODQ3NyA1Ljk4ODI4IDEuMjU5NzcgNS43MTQ4NEMxLjEzNDc3IDUuNDM3NSAxLjA3MjI3IDUuMTA5MzggMS4wNzIyNyA0LjczMDQ3QzEuMDcyMjcgNC4zOTg0NCAxLjEyODkxIDQuMDk1NyAxLjI0MjE5IDMuODIyMjdDMS4zNTU0NyAzLjU0NDkyIDEuNTE1NjIgMy4zMDQ2OSAxLjcyMjY2IDMuMTAxNTZDMS45Mjk2OSAyLjg5ODQ0IDIuMTc5NjkgMi43MzQzNyAyLjQ3MjY2IDIuNjA5MzhDMi43NjU2MiAyLjQ4NDM4IDMuMDkxOCAyLjQwNDMgMy40NTExNyAyLjM2OTE0VjEuMTA5MzhINC4zODg2N1YyLjM4MDg2QzQuNzQwMjMgMi40Mjc3MyA1LjA1NjY0IDIuNTIzNDQgNS4zMzc4OSAyLjY2Nzk3QzUuNjE5MTQgMi44MTI1IDUuODU3NDIgMy4wMDE5NSA2LjA1MjczIDMuMjM2MzNDNi4yNTE5NSAzLjQ2NjggNi40MDQzIDMuNzQwMjMgNi41MDk3NyA0LjA1NjY0QzYuNjE5MTQgNC4zNjkxNCA2LjY3MzgzIDQuNzIwNyA2LjY3MzgzIDUuMTExMzNINS4wNDQ5MkM1LjA0NDkyIDQuNjM4NjcgNC45Mzc1IDQuMjgxMjUgNC43MjI2NiA0LjAzOTA2QzQuNTA3ODEgMy43OTI5NyA0LjIxNjggMy42Njk5MiAzLjg0OTYxIDMuNjY5OTJDMy42NTAzOSAzLjY2OTkyIDMuNDc2NTYgMy42OTcyNyAzLjMyODEyIDMuNzUxOTVDMy4xODM1OSAzLjgwMjczIDMuMDY0NDUgMy44NzY5NSAyLjk3MDcgMy45NzQ2MUMyLjg3Njk1IDQuMDY4MzYgMi44MDY2NCA0LjE3OTY5IDIuNzU5NzcgNC4zMDg1OUMyLjcxNjggNC40Mzc1IDIuNjk1MzEgNC41NzgxMiAyLjY5NTMxIDQuNzMwNDdDMi42OTUzMSA0Ljg4MjgxIDIuNzE2OCA1LjAxOTUzIDIuNzU5NzcgNS4xNDA2MkMyLjgwNjY0IDUuMjU3ODEgMi44ODI4MSA1LjM2NzE5IDIuOTg4MjggNS40Njg3NUMzLjA5NzY2IDUuNTcwMzEgMy4yNDAyMyA1LjY2Nzk3IDMuNDE2MDIgNS43NjE3MkMzLjU5MTggNS44NTE1NiAzLjgxMDU1IDUuOTQzMzYgNC4wNzIyNyA2LjAzNzExQzQuNDY2OCA2LjE4NTU1IDQuODI0MjIgNi4zMzk4NCA1LjE0NDUzIDYuNUM1LjQ2NDg0IDYuNjU2MjUgNS43MzgyOCA2LjgzOTg0IDUuOTY0ODQgNy4wNTA3OEM2LjE5NTMxIDcuMjU3ODEgNi4zNzEwOSA3LjUgNi40OTIxOSA3Ljc3NzM0QzYuNjE3MTkgOC4wNTA3OCA2LjY3OTY5IDguMzc1IDYuNjc5NjkgOC43NUM2LjY3OTY5IDkuMDkzNzUgNi42MjMwNSA5LjQwNDMgNi41MDk3NyA5LjY4MTY0QzYuMzk2NDggOS45NTUwOCA2LjIzNDM4IDEwLjE5MTQgNi4wMjM0NCAxMC4zOTA2QzUuODEyNSAxMC41ODk4IDUuNTU4NTkgMTAuNzUgNS4yNjE3MiAxMC44NzExQzQuOTY0ODQgMTAuOTg4MyA0LjYzMjgxIDExLjA2NDUgNC4yNjU2MiAxMS4wOTk2VjEyLjI0OEgzLjMzMzk4VjExLjA5OTZDMy4wMDE5NSAxMS4wNjg0IDIuNjc5NjkgMTAuOTk2MSAyLjM2NzE5IDEwLjg4MjhDMi4wNTQ2OSAxMC43NjU2IDEuNzc3MzQgMTAuNTk3NyAxLjUzNTE2IDEwLjM3ODlDMS4yOTY4OCAxMC4xNjAyIDEuMTA1NDcgOS44ODQ3NyAwLjk2MDkzOCA5LjU1MjczQzAuODE2NDA2IDkuMjE2OCAwLjc0NDE0MSA4LjgxNDQ1IDAuNzQ0MTQxIDguMzQ1N0gyLjM3ODkxQzIuMzc4OTEgOC42MjY5NSAyLjQxOTkyIDguODYzMjggMi41MDE5NSA5LjA1NDY5QzIuNTgzOTggOS4yNDIxOSAyLjY4OTQ1IDkuMzkyNTggMi44MTgzNiA5LjUwNTg2QzIuOTUxMTcgOS42MTUyMyAzLjEwMTU2IDkuNjkzMzYgMy4yNjk1MyA5Ljc0MDIzQzMuNDM3NSA5Ljc4NzExIDMuNjA5MzggOS44MTA1NSAzLjc4NTE2IDkuODEwNTVDNC4yMDMxMiA5LjgxMDU1IDQuNTE5NTMgOS43MTI4OSA0LjczNDM4IDkuNTE3NThDNC45NDkyMiA5LjMyMjI3IDUuMDU2NjQgOS4wNzAzMSA1LjA1NjY0IDguNzYxNzJaTTEzLjQxOCAxMi4yNzE1SDguMDc0MjJWMTFIMTMuNDE4VjEyLjI3MTVaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzLjk1MjY0IDYpIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K);--jp-icon-text-editor: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8cGF0aCBjbGFzcz0ianAtaWNvbjMganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjNjE2MTYxIiBkPSJNMTUgMTVIM3YyaDEydi0yem0wLThIM3YyaDEyVjd6TTMgMTNoMTh2LTJIM3Yyem0wIDhoMTh2LTJIM3Yyek0zIDN2MmgxOFYzSDN6Ii8+Cjwvc3ZnPgo=);--jp-icon-trusted: url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDI0IDI1Ij4KICAgIDxwYXRoIGNsYXNzPSJqcC1pY29uMiIgc3Ryb2tlPSIjMzMzMzMzIiBzdHJva2Utd2lkdGg9IjIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIgMykiIGQ9Ik0xLjg2MDk0IDExLjQ0MDlDMC44MjY0NDggOC43NzAyNyAwLjg2Mzc3OSA2LjA1NzY0IDEuMjQ5MDcgNC4xOTkzMkMyLjQ4MjA2IDMuOTMzNDcgNC4wODA2OCAzLjQwMzQ3IDUuNjAxMDIgMi44NDQ5QzcuMjM1NDkgMi4yNDQ0IDguODU2NjYgMS41ODE1IDkuOTg3NiAxLjA5NTM5QzExLjA1OTcgMS41ODM0MSAxMi42MDk0IDIuMjQ0NCAxNC4yMTggMi44NDMzOUMxNS43NTAzIDMuNDEzOTQgMTcuMzk5NSAzLjk1MjU4IDE4Ljc1MzkgNC4yMTM4NUMxOS4xMzY0IDYuMDcxNzcgMTkuMTcwOSA4Ljc3NzIyIDE4LjEzOSAxMS40NDA5QzE3LjAzMDMgMTQuMzAzMiAxNC42NjY4IDE3LjE4NDQgOS45OTk5OSAxOC45MzU0QzUuMzMzMiAxNy4xODQ0IDIuOTY5NjggMTQuMzAzMiAxLjg2MDk0IDExLjQ0MDlaIi8+CiAgICA8cGF0aCBjbGFzcz0ianAtaWNvbjIiIGZpbGw9IiMzMzMzMzMiIHN0cm9rZT0iIzMzMzMzMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOCA5Ljg2NzE5KSIgZD0iTTIuODYwMTUgNC44NjUzNUwwLjcyNjU0OSAyLjk5OTU5TDAgMy42MzA0NUwyLjg2MDE1IDYuMTMxNTdMOCAwLjYzMDg3Mkw3LjI3ODU3IDBMMi44NjAxNSA0Ljg2NTM1WiIvPgo8L3N2Zz4K);--jp-icon-undo: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyLjUgOGMtMi42NSAwLTUuMDUuOTktNi45IDIuNkwyIDd2OWg5bC0zLjYyLTMuNjJjMS4zOS0xLjE2IDMuMTYtMS44OCA1LjEyLTEuODggMy41NCAwIDYuNTUgMi4zMSA3LjYgNS41bDIuMzctLjc4QzIxLjA4IDExLjAzIDE3LjE1IDggMTIuNSA4eiIvPgogIDwvZz4KPC9zdmc+Cg==);--jp-icon-vega: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtaWNvbjEganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjMjEyMTIxIj4KICAgIDxwYXRoIGQ9Ik0xMC42IDUuNGwyLjItMy4ySDIuMnY3LjNsNC02LjZ6Ii8+CiAgICA8cGF0aCBkPSJNMTUuOCAyLjJsLTQuNCA2LjZMNyA2LjNsLTQuOCA4djUuNWgxNy42VjIuMmgtNHptLTcgMTUuNEg1LjV2LTQuNGgzLjN2NC40em00LjQgMEg5LjhWOS44aDMuNHY3Ljh6bTQuNCAwaC0zLjRWNi41aDMuNHYxMS4xeiIvPgogIDwvZz4KPC9zdmc+Cg==);--jp-icon-yaml: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgdmlld0JveD0iMCAwIDIyIDIyIj4KICA8ZyBjbGFzcz0ianAtaWNvbi1jb250cmFzdDIganAtaWNvbi1zZWxlY3RhYmxlIiBmaWxsPSIjRDgxQjYwIj4KICAgIDxwYXRoIGQ9Ik03LjIgMTguNnYtNS40TDMgNS42aDMuM2wxLjQgMy4xYy4zLjkuNiAxLjYgMSAyLjUuMy0uOC42LTEuNiAxLTIuNWwxLjQtMy4xaDMuNGwtNC40IDcuNnY1LjVsLTIuOS0uMXoiLz4KICAgIDxjaXJjbGUgY2xhc3M9InN0MCIgY3g9IjE3LjYiIGN5PSIxNi41IiByPSIyLjEiLz4KICAgIDxjaXJjbGUgY2xhc3M9InN0MCIgY3g9IjE3LjYiIGN5PSIxMSIgcj0iMi4xIi8+CiAgPC9nPgo8L3N2Zz4K)}.jupyter-wrapper .jp-AddIcon{background-image:var(--jp-icon-add)}.jupyter-wrapper .jp-BugIcon{background-image:var(--jp-icon-bug)}.jupyter-wrapper .jp-BuildIcon{background-image:var(--jp-icon-build)}.jupyter-wrapper .jp-CaretDownEmptyIcon{background-image:var(--jp-icon-caret-down-empty)}.jupyter-wrapper .jp-CaretDownEmptyThinIcon{background-image:var(--jp-icon-caret-down-empty-thin)}.jupyter-wrapper .jp-CaretDownIcon{background-image:var(--jp-icon-caret-down)}.jupyter-wrapper .jp-CaretLeftIcon{background-image:var(--jp-icon-caret-left)}.jupyter-wrapper .jp-CaretRightIcon{background-image:var(--jp-icon-caret-right)}.jupyter-wrapper .jp-CaretUpEmptyThinIcon{background-image:var(--jp-icon-caret-up-empty-thin)}.jupyter-wrapper .jp-CaretUpIcon{background-image:var(--jp-icon-caret-up)}.jupyter-wrapper .jp-CaseSensitiveIcon{background-image:var(--jp-icon-case-sensitive)}.jupyter-wrapper .jp-CheckIcon{background-image:var(--jp-icon-check)}.jupyter-wrapper .jp-CircleEmptyIcon{background-image:var(--jp-icon-circle-empty)}.jupyter-wrapper .jp-CircleIcon{background-image:var(--jp-icon-circle)}.jupyter-wrapper .jp-ClearIcon{background-image:var(--jp-icon-clear)}.jupyter-wrapper .jp-CloseIcon{background-image:var(--jp-icon-close)}.jupyter-wrapper .jp-ConsoleIcon{background-image:var(--jp-icon-console)}.jupyter-wrapper .jp-CopyIcon{background-image:var(--jp-icon-copy)}.jupyter-wrapper .jp-CutIcon{background-image:var(--jp-icon-cut)}.jupyter-wrapper .jp-DownloadIcon{background-image:var(--jp-icon-download)}.jupyter-wrapper .jp-EditIcon{background-image:var(--jp-icon-edit)}.jupyter-wrapper .jp-EllipsesIcon{background-image:var(--jp-icon-ellipses)}.jupyter-wrapper .jp-ExtensionIcon{background-image:var(--jp-icon-extension)}.jupyter-wrapper .jp-FastForwardIcon{background-image:var(--jp-icon-fast-forward)}.jupyter-wrapper .jp-FileIcon{background-image:var(--jp-icon-file)}.jupyter-wrapper .jp-FileUploadIcon{background-image:var(--jp-icon-file-upload)}.jupyter-wrapper .jp-FilterListIcon{background-image:var(--jp-icon-filter-list)}.jupyter-wrapper .jp-FolderIcon{background-image:var(--jp-icon-folder)}.jupyter-wrapper .jp-Html5Icon{background-image:var(--jp-icon-html5)}.jupyter-wrapper .jp-ImageIcon{background-image:var(--jp-icon-image)}.jupyter-wrapper .jp-InspectorIcon{background-image:var(--jp-icon-inspector)}.jupyter-wrapper .jp-JsonIcon{background-image:var(--jp-icon-json)}.jupyter-wrapper .jp-JupyterFaviconIcon{background-image:var(--jp-icon-jupyter-favicon)}.jupyter-wrapper .jp-JupyterIcon{background-image:var(--jp-icon-jupyter)}.jupyter-wrapper .jp-JupyterlabWordmarkIcon{background-image:var(--jp-icon-jupyterlab-wordmark)}.jupyter-wrapper .jp-KernelIcon{background-image:var(--jp-icon-kernel)}.jupyter-wrapper .jp-KeyboardIcon{background-image:var(--jp-icon-keyboard)}.jupyter-wrapper .jp-LauncherIcon{background-image:var(--jp-icon-launcher)}.jupyter-wrapper .jp-LineFormIcon{background-image:var(--jp-icon-line-form)}.jupyter-wrapper .jp-LinkIcon{background-image:var(--jp-icon-link)}.jupyter-wrapper .jp-ListIcon{background-image:var(--jp-icon-list)}.jupyter-wrapper .jp-ListingsInfoIcon{background-image:var(--jp-icon-listings-info)}.jupyter-wrapper .jp-MarkdownIcon{background-image:var(--jp-icon-markdown)}.jupyter-wrapper .jp-NewFolderIcon{background-image:var(--jp-icon-new-folder)}.jupyter-wrapper .jp-NotTrustedIcon{background-image:var(--jp-icon-not-trusted)}.jupyter-wrapper .jp-NotebookIcon{background-image:var(--jp-icon-notebook)}.jupyter-wrapper .jp-PaletteIcon{background-image:var(--jp-icon-palette)}.jupyter-wrapper .jp-PasteIcon{background-image:var(--jp-icon-paste)}.jupyter-wrapper .jp-PythonIcon{background-image:var(--jp-icon-python)}.jupyter-wrapper .jp-RKernelIcon{background-image:var(--jp-icon-r-kernel)}.jupyter-wrapper .jp-ReactIcon{background-image:var(--jp-icon-react)}.jupyter-wrapper .jp-RefreshIcon{background-image:var(--jp-icon-refresh)}.jupyter-wrapper .jp-RegexIcon{background-image:var(--jp-icon-regex)}.jupyter-wrapper .jp-RunIcon{background-image:var(--jp-icon-run)}.jupyter-wrapper .jp-RunningIcon{background-image:var(--jp-icon-running)}.jupyter-wrapper .jp-SaveIcon{background-image:var(--jp-icon-save)}.jupyter-wrapper .jp-SearchIcon{background-image:var(--jp-icon-search)}.jupyter-wrapper .jp-SettingsIcon{background-image:var(--jp-icon-settings)}.jupyter-wrapper .jp-SpreadsheetIcon{background-image:var(--jp-icon-spreadsheet)}.jupyter-wrapper .jp-StopIcon{background-image:var(--jp-icon-stop)}.jupyter-wrapper .jp-TabIcon{background-image:var(--jp-icon-tab)}.jupyter-wrapper .jp-TerminalIcon{background-image:var(--jp-icon-terminal)}.jupyter-wrapper .jp-TextEditorIcon{background-image:var(--jp-icon-text-editor)}.jupyter-wrapper .jp-TrustedIcon{background-image:var(--jp-icon-trusted)}.jupyter-wrapper .jp-UndoIcon{background-image:var(--jp-icon-undo)}.jupyter-wrapper .jp-VegaIcon{background-image:var(--jp-icon-vega)}.jupyter-wrapper .jp-YamlIcon{background-image:var(--jp-icon-yaml)}.jupyter-wrapper :root{--jp-icon-search-white: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTggMTgiIHdpZHRoPSIxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZyBjbGFzcz0ianAtaWNvbjMiIGZpbGw9IiM2MTYxNjEiPgogICAgPHBhdGggZD0iTTEyLjEsMTAuOWgtMC43bC0wLjItMC4yYzAuOC0wLjksMS4zLTIuMiwxLjMtMy41YzAtMy0yLjQtNS40LTUuNC01LjRTMS44LDQuMiwxLjgsNy4xczIuNCw1LjQsNS40LDUuNCBjMS4zLDAsMi41LTAuNSwzLjUtMS4zbDAuMiwwLjJ2MC43bDQuMSw0LjFsMS4yLTEuMkwxMi4xLDEwLjl6IE03LjEsMTAuOWMtMi4xLDAtMy43LTEuNy0zLjctMy43czEuNy0zLjcsMy43LTMuN3MzLjcsMS43LDMuNywzLjcgUzkuMiwxMC45LDcuMSwxMC45eiIvPgogIDwvZz4KPC9zdmc+Cg==)}.jupyter-wrapper .jp-Icon,.jupyter-wrapper .jp-MaterialIcon{background-position:center;background-repeat:no-repeat;background-size:16px;min-width:16px;min-height:16px}.jupyter-wrapper .jp-Icon-cover{background-position:center;background-repeat:no-repeat;background-size:cover}.jupyter-wrapper .jp-Icon-16{background-size:16px;min-width:16px;min-height:16px}.jupyter-wrapper .jp-Icon-18{background-size:18px;min-width:18px;min-height:18px}.jupyter-wrapper .jp-Icon-20{background-size:20px;min-width:20px;min-height:20px}.jupyter-wrapper .jp-icon0[fill]{fill:var(--jp-inverse-layout-color0)}.jupyter-wrapper .jp-icon1[fill]{fill:var(--jp-inverse-layout-color1)}.jupyter-wrapper .jp-icon2[fill]{fill:var(--jp-inverse-layout-color2)}.jupyter-wrapper .jp-icon3[fill]{fill:var(--jp-inverse-layout-color3)}.jupyter-wrapper .jp-icon4[fill]{fill:var(--jp-inverse-layout-color4)}.jupyter-wrapper .jp-icon0[stroke]{stroke:var(--jp-inverse-layout-color0)}.jupyter-wrapper .jp-icon1[stroke]{stroke:var(--jp-inverse-layout-color1)}.jupyter-wrapper .jp-icon2[stroke]{stroke:var(--jp-inverse-layout-color2)}.jupyter-wrapper .jp-icon3[stroke]{stroke:var(--jp-inverse-layout-color3)}.jupyter-wrapper .jp-icon4[stroke]{stroke:var(--jp-inverse-layout-color4)}.jupyter-wrapper .jp-icon-accent0[fill]{fill:var(--jp-layout-color0)}.jupyter-wrapper .jp-icon-accent1[fill]{fill:var(--jp-layout-color1)}.jupyter-wrapper .jp-icon-accent2[fill]{fill:var(--jp-layout-color2)}.jupyter-wrapper .jp-icon-accent3[fill]{fill:var(--jp-layout-color3)}.jupyter-wrapper .jp-icon-accent4[fill]{fill:var(--jp-layout-color4)}.jupyter-wrapper .jp-icon-accent0[stroke]{stroke:var(--jp-layout-color0)}.jupyter-wrapper .jp-icon-accent1[stroke]{stroke:var(--jp-layout-color1)}.jupyter-wrapper .jp-icon-accent2[stroke]{stroke:var(--jp-layout-color2)}.jupyter-wrapper .jp-icon-accent3[stroke]{stroke:var(--jp-layout-color3)}.jupyter-wrapper .jp-icon-accent4[stroke]{stroke:var(--jp-layout-color4)}.jupyter-wrapper .jp-icon-none[fill]{fill:none}.jupyter-wrapper .jp-icon-none[stroke]{stroke:none}.jupyter-wrapper .jp-icon-brand0[fill]{fill:var(--jp-brand-color0)}.jupyter-wrapper .jp-icon-brand1[fill]{fill:var(--jp-brand-color1)}.jupyter-wrapper .jp-icon-brand2[fill]{fill:var(--jp-brand-color2)}.jupyter-wrapper .jp-icon-brand3[fill]{fill:var(--jp-brand-color3)}.jupyter-wrapper .jp-icon-brand4[fill]{fill:var(--jp-brand-color4)}.jupyter-wrapper .jp-icon-brand0[stroke]{stroke:var(--jp-brand-color0)}.jupyter-wrapper .jp-icon-brand1[stroke]{stroke:var(--jp-brand-color1)}.jupyter-wrapper .jp-icon-brand2[stroke]{stroke:var(--jp-brand-color2)}.jupyter-wrapper .jp-icon-brand3[stroke]{stroke:var(--jp-brand-color3)}.jupyter-wrapper .jp-icon-brand4[stroke]{stroke:var(--jp-brand-color4)}.jupyter-wrapper .jp-icon-warn0[fill]{fill:var(--jp-warn-color0)}.jupyter-wrapper .jp-icon-warn1[fill]{fill:var(--jp-warn-color1)}.jupyter-wrapper .jp-icon-warn2[fill]{fill:var(--jp-warn-color2)}.jupyter-wrapper .jp-icon-warn3[fill]{fill:var(--jp-warn-color3)}.jupyter-wrapper .jp-icon-warn0[stroke]{stroke:var(--jp-warn-color0)}.jupyter-wrapper .jp-icon-warn1[stroke]{stroke:var(--jp-warn-color1)}.jupyter-wrapper .jp-icon-warn2[stroke]{stroke:var(--jp-warn-color2)}.jupyter-wrapper .jp-icon-warn3[stroke]{stroke:var(--jp-warn-color3)}.jupyter-wrapper .jp-icon-contrast0[fill]{fill:var(--jp-icon-contrast-color0)}.jupyter-wrapper .jp-icon-contrast1[fill]{fill:var(--jp-icon-contrast-color1)}.jupyter-wrapper .jp-icon-contrast2[fill]{fill:var(--jp-icon-contrast-color2)}.jupyter-wrapper .jp-icon-contrast3[fill]{fill:var(--jp-icon-contrast-color3)}.jupyter-wrapper .jp-icon-contrast0[stroke]{stroke:var(--jp-icon-contrast-color0)}.jupyter-wrapper .jp-icon-contrast1[stroke]{stroke:var(--jp-icon-contrast-color1)}.jupyter-wrapper .jp-icon-contrast2[stroke]{stroke:var(--jp-icon-contrast-color2)}.jupyter-wrapper .jp-icon-contrast3[stroke]{stroke:var(--jp-icon-contrast-color3)}.jupyter-wrapper #setting-editor .jp-PluginList .jp-mod-selected .jp-icon-selectable[fill]{fill:#fff}.jupyter-wrapper #setting-editor .jp-PluginList .jp-mod-selected .jp-icon-selectable-inverse[fill]{fill:var(--jp-brand-color1)}.jupyter-wrapper .jp-DirListing-item.jp-mod-selected .jp-icon-selectable[fill]{fill:#fff}.jupyter-wrapper .jp-DirListing-item.jp-mod-selected .jp-icon-selectable-inverse[fill]{fill:var(--jp-brand-color1)}.jupyter-wrapper #tab-manager .lm-TabBar-tab.jp-mod-active .jp-icon-selectable[fill]{fill:#fff}.jupyter-wrapper #tab-manager .lm-TabBar-tab.jp-mod-active .jp-icon-selectable-inverse[fill]{fill:var(--jp-brand-color1)}.jupyter-wrapper #tab-manager .lm-TabBar-tab.jp-mod-active .jp-icon-hover :hover .jp-icon-selectable[fill]{fill:var(--jp-brand-color1)}.jupyter-wrapper #tab-manager .lm-TabBar-tab.jp-mod-active .jp-icon-hover :hover .jp-icon-selectable-inverse[fill]{fill:#fff}.jupyter-wrapper #tab-manager .lm-TabBar-tab.jp-mod-dirty>.lm-TabBar-tabCloseIcon>:not(:hover)>.jp-icon3[fill]{fill:none}.jupyter-wrapper #tab-manager .lm-TabBar-tab.jp-mod-dirty>.lm-TabBar-tabCloseIcon>:not(:hover)>.jp-icon-busy[fill]{fill:var(--jp-inverse-layout-color3)}.jupyter-wrapper #tab-manager .lm-TabBar-tab.jp-mod-dirty.jp-mod-active>.lm-TabBar-tabCloseIcon>:not(:hover)>.jp-icon-busy[fill]{fill:#fff}.jupyter-wrapper .lm-DockPanel-tabBar .lm-TabBar-tab.lm-mod-closable.jp-mod-dirty>.lm-TabBar-tabCloseIcon>:not(:hover)>.jp-icon3[fill]{fill:none}.jupyter-wrapper .lm-DockPanel-tabBar .lm-TabBar-tab.lm-mod-closable.jp-mod-dirty>.lm-TabBar-tabCloseIcon>:not(:hover)>.jp-icon-busy[fill]{fill:var(--jp-inverse-layout-color3)}.jupyter-wrapper #jp-main-statusbar .jp-mod-selected .jp-icon-selectable[fill]{fill:#fff}.jupyter-wrapper #jp-main-statusbar .jp-mod-selected .jp-icon-selectable-inverse[fill]{fill:var(--jp-brand-color1)}.jupyter-wrapper :root{--jp-warn-color0: var(--md-orange-700)}.jupyter-wrapper .jp-DragIcon{margin-right:4px}.jupyter-wrapper .jp-icon-alt .jp-icon0[fill]{fill:var(--jp-layout-color0)}.jupyter-wrapper .jp-icon-alt .jp-icon1[fill]{fill:var(--jp-layout-color1)}.jupyter-wrapper .jp-icon-alt .jp-icon2[fill]{fill:var(--jp-layout-color2)}.jupyter-wrapper .jp-icon-alt .jp-icon3[fill]{fill:var(--jp-layout-color3)}.jupyter-wrapper .jp-icon-alt .jp-icon4[fill]{fill:var(--jp-layout-color4)}.jupyter-wrapper .jp-icon-alt .jp-icon0[stroke]{stroke:var(--jp-layout-color0)}.jupyter-wrapper .jp-icon-alt .jp-icon1[stroke]{stroke:var(--jp-layout-color1)}.jupyter-wrapper .jp-icon-alt .jp-icon2[stroke]{stroke:var(--jp-layout-color2)}.jupyter-wrapper .jp-icon-alt .jp-icon3[stroke]{stroke:var(--jp-layout-color3)}.jupyter-wrapper .jp-icon-alt .jp-icon4[stroke]{stroke:var(--jp-layout-color4)}.jupyter-wrapper .jp-icon-alt .jp-icon-accent0[fill]{fill:var(--jp-inverse-layout-color0)}.jupyter-wrapper .jp-icon-alt .jp-icon-accent1[fill]{fill:var(--jp-inverse-layout-color1)}.jupyter-wrapper .jp-icon-alt .jp-icon-accent2[fill]{fill:var(--jp-inverse-layout-color2)}.jupyter-wrapper .jp-icon-alt .jp-icon-accent3[fill]{fill:var(--jp-inverse-layout-color3)}.jupyter-wrapper .jp-icon-alt .jp-icon-accent4[fill]{fill:var(--jp-inverse-layout-color4)}.jupyter-wrapper .jp-icon-alt .jp-icon-accent0[stroke]{stroke:var(--jp-inverse-layout-color0)}.jupyter-wrapper .jp-icon-alt .jp-icon-accent1[stroke]{stroke:var(--jp-inverse-layout-color1)}.jupyter-wrapper .jp-icon-alt .jp-icon-accent2[stroke]{stroke:var(--jp-inverse-layout-color2)}.jupyter-wrapper .jp-icon-alt .jp-icon-accent3[stroke]{stroke:var(--jp-inverse-layout-color3)}.jupyter-wrapper .jp-icon-alt .jp-icon-accent4[stroke]{stroke:var(--jp-inverse-layout-color4)}.jupyter-wrapper .jp-icon-hoverShow:not(:hover) svg{display:none !important}.jupyter-wrapper .jp-icon-hover :hover .jp-icon0-hover[fill]{fill:var(--jp-inverse-layout-color0)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon1-hover[fill]{fill:var(--jp-inverse-layout-color1)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon2-hover[fill]{fill:var(--jp-inverse-layout-color2)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon3-hover[fill]{fill:var(--jp-inverse-layout-color3)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon4-hover[fill]{fill:var(--jp-inverse-layout-color4)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon0-hover[stroke]{stroke:var(--jp-inverse-layout-color0)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon1-hover[stroke]{stroke:var(--jp-inverse-layout-color1)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon2-hover[stroke]{stroke:var(--jp-inverse-layout-color2)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon3-hover[stroke]{stroke:var(--jp-inverse-layout-color3)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon4-hover[stroke]{stroke:var(--jp-inverse-layout-color4)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon-accent0-hover[fill]{fill:var(--jp-layout-color0)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon-accent1-hover[fill]{fill:var(--jp-layout-color1)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon-accent2-hover[fill]{fill:var(--jp-layout-color2)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon-accent3-hover[fill]{fill:var(--jp-layout-color3)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon-accent4-hover[fill]{fill:var(--jp-layout-color4)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon-accent0-hover[stroke]{stroke:var(--jp-layout-color0)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon-accent1-hover[stroke]{stroke:var(--jp-layout-color1)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon-accent2-hover[stroke]{stroke:var(--jp-layout-color2)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon-accent3-hover[stroke]{stroke:var(--jp-layout-color3)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon-accent4-hover[stroke]{stroke:var(--jp-layout-color4)}.jupyter-wrapper .jp-icon-hover :hover .jp-icon-none-hover[fill]{fill:none}.jupyter-wrapper .jp-icon-hover :hover .jp-icon-none-hover[stroke]{stroke:none}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon0-hover[fill]{fill:var(--jp-layout-color0)}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon1-hover[fill]{fill:var(--jp-layout-color1)}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon2-hover[fill]{fill:var(--jp-layout-color2)}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon3-hover[fill]{fill:var(--jp-layout-color3)}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon4-hover[fill]{fill:var(--jp-layout-color4)}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon0-hover[stroke]{stroke:var(--jp-layout-color0)}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon1-hover[stroke]{stroke:var(--jp-layout-color1)}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon2-hover[stroke]{stroke:var(--jp-layout-color2)}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon3-hover[stroke]{stroke:var(--jp-layout-color3)}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon4-hover[stroke]{stroke:var(--jp-layout-color4)}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon-accent0-hover[fill]{fill:var(--jp-inverse-layout-color0)}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon-accent1-hover[fill]{fill:var(--jp-inverse-layout-color1)}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon-accent2-hover[fill]{fill:var(--jp-inverse-layout-color2)}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon-accent3-hover[fill]{fill:var(--jp-inverse-layout-color3)}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon-accent4-hover[fill]{fill:var(--jp-inverse-layout-color4)}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon-accent0-hover[stroke]{stroke:var(--jp-inverse-layout-color0)}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon-accent1-hover[stroke]{stroke:var(--jp-inverse-layout-color1)}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon-accent2-hover[stroke]{stroke:var(--jp-inverse-layout-color2)}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon-accent3-hover[stroke]{stroke:var(--jp-inverse-layout-color3)}.jupyter-wrapper .jp-icon-hover.jp-icon-alt :hover .jp-icon-accent4-hover[stroke]{stroke:var(--jp-inverse-layout-color4)}.jupyter-wrapper :focus{outline:unset;outline-offset:unset;-moz-outline-radius:unset}.jupyter-wrapper .jp-Button{border-radius:var(--jp-border-radius);padding:0px 12px;font-size:var(--jp-ui-font-size1)}.jupyter-wrapper button.jp-Button.bp3-button.bp3-minimal:hover{background-color:var(--jp-layout-color2)}.jupyter-wrapper .jp-Button.minimal{color:unset !important}.jupyter-wrapper .jp-Button.jp-ToolbarButtonComponent{text-transform:none}.jupyter-wrapper .jp-InputGroup input{box-sizing:border-box;border-radius:0;background-color:transparent;color:var(--jp-ui-font-color0);box-shadow:inset 0 0 0 var(--jp-border-width) var(--jp-input-border-color)}.jupyter-wrapper .jp-InputGroup input:focus{box-shadow:inset 0 0 0 var(--jp-border-width) var(--jp-input-active-box-shadow-color),inset 0 0 0 3px var(--jp-input-active-box-shadow-color)}.jupyter-wrapper .jp-InputGroup input::placeholder,.jupyter-wrapper input::placeholder{color:var(--jp-ui-font-color3)}.jupyter-wrapper .jp-BPIcon{display:inline-block;vertical-align:middle;margin:auto}.jupyter-wrapper .bp3-icon.jp-BPIcon>svg:not([fill]){fill:var(--jp-inverse-layout-color3)}.jupyter-wrapper .jp-InputGroupAction{padding:6px}.jupyter-wrapper .jp-HTMLSelect.jp-DefaultStyle select{background-color:initial;border:none;border-radius:0;box-shadow:none;color:var(--jp-ui-font-color0);display:block;font-size:var(--jp-ui-font-size1);height:24px;line-height:14px;padding:0 25px 0 10px;text-align:left;-moz-appearance:none;-webkit-appearance:none}.jupyter-wrapper .jp-HTMLSelect.jp-DefaultStyle select:hover,.jupyter-wrapper .jp-HTMLSelect.jp-DefaultStyle select>option{background-color:var(--jp-layout-color2);color:var(--jp-ui-font-color0)}.jupyter-wrapper select{box-sizing:border-box}.jupyter-wrapper .jp-Collapse{display:flex;flex-direction:column;align-items:stretch;border-top:1px solid var(--jp-border-color2);border-bottom:1px solid var(--jp-border-color2)}.jupyter-wrapper .jp-Collapse-header{padding:1px 12px;color:var(--jp-ui-font-color1);background-color:var(--jp-layout-color1);font-size:var(--jp-ui-font-size2)}.jupyter-wrapper .jp-Collapse-header:hover{background-color:var(--jp-layout-color2)}.jupyter-wrapper .jp-Collapse-contents{padding:0px 12px 0px 12px;background-color:var(--jp-layout-color1);color:var(--jp-ui-font-color1);overflow:auto}.jupyter-wrapper :root{--jp-private-commandpalette-search-height: 28px}.jupyter-wrapper .lm-CommandPalette{padding-bottom:0px;color:var(--jp-ui-font-color1);background:var(--jp-layout-color1);font-size:var(--jp-ui-font-size1)}.jupyter-wrapper .lm-CommandPalette-search{padding:4px;background-color:var(--jp-layout-color1);z-index:2}.jupyter-wrapper .lm-CommandPalette-wrapper{overflow:overlay;padding:0px 9px;background-color:var(--jp-input-active-background);height:30px;box-shadow:inset 0 0 0 var(--jp-border-width) var(--jp-input-border-color)}.jupyter-wrapper .lm-CommandPalette.lm-mod-focused .lm-CommandPalette-wrapper{box-shadow:inset 0 0 0 1px var(--jp-input-active-box-shadow-color),inset 0 0 0 3px var(--jp-input-active-box-shadow-color)}.jupyter-wrapper .lm-CommandPalette-wrapper::after{content:\" \";color:#fff;background-color:var(--jp-brand-color1);position:absolute;top:4px;right:4px;height:30px;width:10px;padding:0px 10px;background-image:var(--jp-icon-search-white);background-size:20px;background-repeat:no-repeat;background-position:center}.jupyter-wrapper .lm-CommandPalette-input{background:transparent;width:calc(100% - 18px);float:left;border:none;outline:none;font-size:var(--jp-ui-font-size1);color:var(--jp-ui-font-color0);line-height:var(--jp-private-commandpalette-search-height)}.jupyter-wrapper .lm-CommandPalette-input::-webkit-input-placeholder,.jupyter-wrapper .lm-CommandPalette-input::-moz-placeholder,.jupyter-wrapper .lm-CommandPalette-input:-ms-input-placeholder{color:var(--jp-ui-font-color3);font-size:var(--jp-ui-font-size1)}.jupyter-wrapper .lm-CommandPalette-header:first-child{margin-top:0px}.jupyter-wrapper .lm-CommandPalette-header{border-bottom:solid var(--jp-border-width) var(--jp-border-color2);color:var(--jp-ui-font-color1);cursor:pointer;display:flex;font-size:var(--jp-ui-font-size0);font-weight:600;letter-spacing:1px;margin-top:8px;padding:8px 0 8px 12px;text-transform:uppercase}.jupyter-wrapper .lm-CommandPalette-header.lm-mod-active{background:var(--jp-layout-color2)}.jupyter-wrapper .lm-CommandPalette-header>mark{background-color:transparent;font-weight:bold;color:var(--jp-ui-font-color1)}.jupyter-wrapper .lm-CommandPalette-item{padding:4px 12px 4px 4px;color:var(--jp-ui-font-color1);font-size:var(--jp-ui-font-size1);font-weight:400;display:flex}.jupyter-wrapper .lm-CommandPalette-item.lm-mod-disabled{color:var(--jp-ui-font-color3)}.jupyter-wrapper .lm-CommandPalette-item.lm-mod-active{background:var(--jp-layout-color3)}.jupyter-wrapper .lm-CommandPalette-item.lm-mod-active:hover:not(.lm-mod-disabled){background:var(--jp-layout-color4)}.jupyter-wrapper .lm-CommandPalette-item:hover:not(.lm-mod-active):not(.lm-mod-disabled){background:var(--jp-layout-color2)}.jupyter-wrapper .lm-CommandPalette-itemContent{overflow:hidden}.jupyter-wrapper .lm-CommandPalette-itemLabel>mark{color:var(--jp-ui-font-color0);background-color:transparent;font-weight:bold}.jupyter-wrapper .lm-CommandPalette-item.lm-mod-disabled mark{color:var(--jp-ui-font-color3)}.jupyter-wrapper .lm-CommandPalette-item .lm-CommandPalette-itemIcon{margin:0 4px 0 0;position:relative;width:16px;top:2px;flex:0 0 auto}.jupyter-wrapper .lm-CommandPalette-item.lm-mod-disabled .lm-CommandPalette-itemIcon{opacity:.4}.jupyter-wrapper .lm-CommandPalette-item .lm-CommandPalette-itemShortcut{flex:0 0 auto}.jupyter-wrapper .lm-CommandPalette-itemCaption{display:none}.jupyter-wrapper .lm-CommandPalette-content{background-color:var(--jp-layout-color1)}.jupyter-wrapper .lm-CommandPalette-content:empty:after{content:\"No results\";margin:auto;margin-top:20px;width:100px;display:block;font-size:var(--jp-ui-font-size2);font-family:var(--jp-ui-font-family);font-weight:lighter}.jupyter-wrapper .lm-CommandPalette-emptyMessage{text-align:center;margin-top:24px;line-height:1.32;padding:0px 8px;color:var(--jp-content-font-color3)}.jupyter-wrapper .jp-Dialog{position:absolute;z-index:10000;display:flex;flex-direction:column;align-items:center;justify-content:center;top:0px;left:0px;margin:0;padding:0;width:100%;height:100%;background:var(--jp-dialog-background)}.jupyter-wrapper .jp-Dialog-content{display:flex;flex-direction:column;margin-left:auto;margin-right:auto;background:var(--jp-layout-color1);padding:24px;padding-bottom:12px;min-width:300px;min-height:150px;max-width:1000px;max-height:500px;box-sizing:border-box;box-shadow:var(--jp-elevation-z20);word-wrap:break-word;border-radius:var(--jp-border-radius);font-size:var(--jp-ui-font-size1);color:var(--jp-ui-font-color1)}.jupyter-wrapper .jp-Dialog-button{overflow:visible}.jupyter-wrapper button.jp-Dialog-button:focus{outline:1px solid var(--jp-brand-color1);outline-offset:4px;-moz-outline-radius:0px}.jupyter-wrapper button.jp-Dialog-button:focus::-moz-focus-inner{border:0}.jupyter-wrapper .jp-Dialog-header{flex:0 0 auto;padding-bottom:12px;font-size:var(--jp-ui-font-size3);font-weight:400;color:var(--jp-ui-font-color0)}.jupyter-wrapper .jp-Dialog-body{display:flex;flex-direction:column;flex:1 1 auto;font-size:var(--jp-ui-font-size1);background:var(--jp-layout-color1);overflow:auto}.jupyter-wrapper .jp-Dialog-footer{display:flex;flex-direction:row;justify-content:flex-end;flex:0 0 auto;margin-left:-12px;margin-right:-12px;padding:12px}.jupyter-wrapper .jp-Dialog-title{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.jupyter-wrapper .jp-Dialog-body>.jp-select-wrapper{width:100%}.jupyter-wrapper .jp-Dialog-body>button{padding:0px 16px}.jupyter-wrapper .jp-Dialog-body>label{line-height:1.4;color:var(--jp-ui-font-color0)}.jupyter-wrapper .jp-Dialog-button.jp-mod-styled:not(:last-child){margin-right:12px}.jupyter-wrapper .jp-HoverBox{position:fixed}.jupyter-wrapper .jp-HoverBox.jp-mod-outofview{display:none}.jupyter-wrapper .jp-IFrame{width:100%;height:100%}.jupyter-wrapper .jp-IFrame>iframe{border:none}.jupyter-wrapper body.lm-mod-override-cursor .jp-IFrame{position:relative}.jupyter-wrapper body.lm-mod-override-cursor .jp-IFrame:before{content:\"\";position:absolute;top:0;left:0;right:0;bottom:0;background:transparent}.jupyter-wrapper .jp-MainAreaWidget>:focus{outline:none}.jupyter-wrapper :root{--md-red-50: #ffebee;--md-red-100: #ffcdd2;--md-red-200: #ef9a9a;--md-red-300: #e57373;--md-red-400: #ef5350;--md-red-500: #f44336;--md-red-600: #e53935;--md-red-700: #d32f2f;--md-red-800: #c62828;--md-red-900: #b71c1c;--md-red-A100: #ff8a80;--md-red-A200: #ff5252;--md-red-A400: #ff1744;--md-red-A700: #d50000;--md-pink-50: #fce4ec;--md-pink-100: #f8bbd0;--md-pink-200: #f48fb1;--md-pink-300: #f06292;--md-pink-400: #ec407a;--md-pink-500: #e91e63;--md-pink-600: #d81b60;--md-pink-700: #c2185b;--md-pink-800: #ad1457;--md-pink-900: #880e4f;--md-pink-A100: #ff80ab;--md-pink-A200: #ff4081;--md-pink-A400: #f50057;--md-pink-A700: #c51162;--md-purple-50: #f3e5f5;--md-purple-100: #e1bee7;--md-purple-200: #ce93d8;--md-purple-300: #ba68c8;--md-purple-400: #ab47bc;--md-purple-500: #9c27b0;--md-purple-600: #8e24aa;--md-purple-700: #7b1fa2;--md-purple-800: #6a1b9a;--md-purple-900: #4a148c;--md-purple-A100: #ea80fc;--md-purple-A200: #e040fb;--md-purple-A400: #d500f9;--md-purple-A700: #aa00ff;--md-deep-purple-50: #ede7f6;--md-deep-purple-100: #d1c4e9;--md-deep-purple-200: #b39ddb;--md-deep-purple-300: #9575cd;--md-deep-purple-400: #7e57c2;--md-deep-purple-500: #673ab7;--md-deep-purple-600: #5e35b1;--md-deep-purple-700: #512da8;--md-deep-purple-800: #4527a0;--md-deep-purple-900: #311b92;--md-deep-purple-A100: #b388ff;--md-deep-purple-A200: #7c4dff;--md-deep-purple-A400: #651fff;--md-deep-purple-A700: #6200ea;--md-indigo-50: #e8eaf6;--md-indigo-100: #c5cae9;--md-indigo-200: #9fa8da;--md-indigo-300: #7986cb;--md-indigo-400: #5c6bc0;--md-indigo-500: #3f51b5;--md-indigo-600: #3949ab;--md-indigo-700: #303f9f;--md-indigo-800: #283593;--md-indigo-900: #1a237e;--md-indigo-A100: #8c9eff;--md-indigo-A200: #536dfe;--md-indigo-A400: #3d5afe;--md-indigo-A700: #304ffe;--md-blue-50: #e3f2fd;--md-blue-100: #bbdefb;--md-blue-200: #90caf9;--md-blue-300: #64b5f6;--md-blue-400: #42a5f5;--md-blue-500: #2196f3;--md-blue-600: #1e88e5;--md-blue-700: #1976d2;--md-blue-800: #1565c0;--md-blue-900: #0d47a1;--md-blue-A100: #82b1ff;--md-blue-A200: #448aff;--md-blue-A400: #2979ff;--md-blue-A700: #2962ff;--md-light-blue-50: #e1f5fe;--md-light-blue-100: #b3e5fc;--md-light-blue-200: #81d4fa;--md-light-blue-300: #4fc3f7;--md-light-blue-400: #29b6f6;--md-light-blue-500: #03a9f4;--md-light-blue-600: #039be5;--md-light-blue-700: #0288d1;--md-light-blue-800: #0277bd;--md-light-blue-900: #01579b;--md-light-blue-A100: #80d8ff;--md-light-blue-A200: #40c4ff;--md-light-blue-A400: #00b0ff;--md-light-blue-A700: #0091ea;--md-cyan-50: #e0f7fa;--md-cyan-100: #b2ebf2;--md-cyan-200: #80deea;--md-cyan-300: #4dd0e1;--md-cyan-400: #26c6da;--md-cyan-500: #00bcd4;--md-cyan-600: #00acc1;--md-cyan-700: #0097a7;--md-cyan-800: #00838f;--md-cyan-900: #006064;--md-cyan-A100: #84ffff;--md-cyan-A200: #18ffff;--md-cyan-A400: #00e5ff;--md-cyan-A700: #00b8d4;--md-teal-50: #e0f2f1;--md-teal-100: #b2dfdb;--md-teal-200: #80cbc4;--md-teal-300: #4db6ac;--md-teal-400: #26a69a;--md-teal-500: #009688;--md-teal-600: #00897b;--md-teal-700: #00796b;--md-teal-800: #00695c;--md-teal-900: #004d40;--md-teal-A100: #a7ffeb;--md-teal-A200: #64ffda;--md-teal-A400: #1de9b6;--md-teal-A700: #00bfa5;--md-green-50: #e8f5e9;--md-green-100: #c8e6c9;--md-green-200: #a5d6a7;--md-green-300: #81c784;--md-green-400: #66bb6a;--md-green-500: #4caf50;--md-green-600: #43a047;--md-green-700: #388e3c;--md-green-800: #2e7d32;--md-green-900: #1b5e20;--md-green-A100: #b9f6ca;--md-green-A200: #69f0ae;--md-green-A400: #00e676;--md-green-A700: #00c853;--md-light-green-50: #f1f8e9;--md-light-green-100: #dcedc8;--md-light-green-200: #c5e1a5;--md-light-green-300: #aed581;--md-light-green-400: #9ccc65;--md-light-green-500: #8bc34a;--md-light-green-600: #7cb342;--md-light-green-700: #689f38;--md-light-green-800: #558b2f;--md-light-green-900: #33691e;--md-light-green-A100: #ccff90;--md-light-green-A200: #b2ff59;--md-light-green-A400: #76ff03;--md-light-green-A700: #64dd17;--md-lime-50: #f9fbe7;--md-lime-100: #f0f4c3;--md-lime-200: #e6ee9c;--md-lime-300: #dce775;--md-lime-400: #d4e157;--md-lime-500: #cddc39;--md-lime-600: #c0ca33;--md-lime-700: #afb42b;--md-lime-800: #9e9d24;--md-lime-900: #827717;--md-lime-A100: #f4ff81;--md-lime-A200: #eeff41;--md-lime-A400: #c6ff00;--md-lime-A700: #aeea00;--md-yellow-50: #fffde7;--md-yellow-100: #fff9c4;--md-yellow-200: #fff59d;--md-yellow-300: #fff176;--md-yellow-400: #ffee58;--md-yellow-500: #ffeb3b;--md-yellow-600: #fdd835;--md-yellow-700: #fbc02d;--md-yellow-800: #f9a825;--md-yellow-900: #f57f17;--md-yellow-A100: #ffff8d;--md-yellow-A200: #ffff00;--md-yellow-A400: #ffea00;--md-yellow-A700: #ffd600;--md-amber-50: #fff8e1;--md-amber-100: #ffecb3;--md-amber-200: #ffe082;--md-amber-300: #ffd54f;--md-amber-400: #ffca28;--md-amber-500: #ffc107;--md-amber-600: #ffb300;--md-amber-700: #ffa000;--md-amber-800: #ff8f00;--md-amber-900: #ff6f00;--md-amber-A100: #ffe57f;--md-amber-A200: #ffd740;--md-amber-A400: #ffc400;--md-amber-A700: #ffab00;--md-orange-50: #fff3e0;--md-orange-100: #ffe0b2;--md-orange-200: #ffcc80;--md-orange-300: #ffb74d;--md-orange-400: #ffa726;--md-orange-500: #ff9800;--md-orange-600: #fb8c00;--md-orange-700: #f57c00;--md-orange-800: #ef6c00;--md-orange-900: #e65100;--md-orange-A100: #ffd180;--md-orange-A200: #ffab40;--md-orange-A400: #ff9100;--md-orange-A700: #ff6d00;--md-deep-orange-50: #fbe9e7;--md-deep-orange-100: #ffccbc;--md-deep-orange-200: #ffab91;--md-deep-orange-300: #ff8a65;--md-deep-orange-400: #ff7043;--md-deep-orange-500: #ff5722;--md-deep-orange-600: #f4511e;--md-deep-orange-700: #e64a19;--md-deep-orange-800: #d84315;--md-deep-orange-900: #bf360c;--md-deep-orange-A100: #ff9e80;--md-deep-orange-A200: #ff6e40;--md-deep-orange-A400: #ff3d00;--md-deep-orange-A700: #dd2c00;--md-brown-50: #efebe9;--md-brown-100: #d7ccc8;--md-brown-200: #bcaaa4;--md-brown-300: #a1887f;--md-brown-400: #8d6e63;--md-brown-500: #795548;--md-brown-600: #6d4c41;--md-brown-700: #5d4037;--md-brown-800: #4e342e;--md-brown-900: #3e2723;--md-grey-50: #fafafa;--md-grey-100: #f5f5f5;--md-grey-200: #eeeeee;--md-grey-300: #e0e0e0;--md-grey-400: #bdbdbd;--md-grey-500: #9e9e9e;--md-grey-600: #757575;--md-grey-700: #616161;--md-grey-800: #424242;--md-grey-900: #212121;--md-blue-grey-50: #eceff1;--md-blue-grey-100: #cfd8dc;--md-blue-grey-200: #b0bec5;--md-blue-grey-300: #90a4ae;--md-blue-grey-400: #78909c;--md-blue-grey-500: #607d8b;--md-blue-grey-600: #546e7a;--md-blue-grey-700: #455a64;--md-blue-grey-800: #37474f;--md-blue-grey-900: #263238}.jupyter-wrapper .jp-Spinner{position:absolute;display:flex;justify-content:center;align-items:center;z-index:10;left:0;top:0;width:100%;height:100%;background:var(--jp-layout-color0);outline:none}.jupyter-wrapper .jp-SpinnerContent{font-size:10px;margin:50px auto;text-indent:-9999em;width:3em;height:3em;border-radius:50%;background:var(--jp-brand-color3);background:linear-gradient(to right, #f37626 10%, rgba(255, 255, 255, 0) 42%);position:relative;animation:load3 1s infinite linear,fadeIn 1s}.jupyter-wrapper .jp-SpinnerContent:before{width:50%;height:50%;background:#f37626;border-radius:100% 0 0 0;position:absolute;top:0;left:0;content:\"\"}.jupyter-wrapper .jp-SpinnerContent:after{background:var(--jp-layout-color0);width:75%;height:75%;border-radius:50%;content:\"\";margin:auto;position:absolute;top:0;left:0;bottom:0;right:0}@keyframes fadeIn{0%{opacity:0}100%{opacity:1}}@keyframes load3{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.jupyter-wrapper button.jp-mod-styled{font-size:var(--jp-ui-font-size1);color:var(--jp-ui-font-color0);border:none;box-sizing:border-box;text-align:center;line-height:32px;height:32px;padding:0px 12px;letter-spacing:.8px;outline:none;appearance:none;-webkit-appearance:none;-moz-appearance:none}.jupyter-wrapper input.jp-mod-styled{background:var(--jp-input-background);height:28px;box-sizing:border-box;border:var(--jp-border-width) solid var(--jp-border-color1);padding-left:7px;padding-right:7px;font-size:var(--jp-ui-font-size2);color:var(--jp-ui-font-color0);outline:none;appearance:none;-webkit-appearance:none;-moz-appearance:none}.jupyter-wrapper input.jp-mod-styled:focus{border:var(--jp-border-width) solid var(--md-blue-500);box-shadow:inset 0 0 4px var(--md-blue-300)}.jupyter-wrapper .jp-select-wrapper{display:flex;position:relative;flex-direction:column;padding:1px;background-color:var(--jp-layout-color1);height:28px;box-sizing:border-box;margin-bottom:12px}.jupyter-wrapper .jp-select-wrapper.jp-mod-focused select.jp-mod-styled{border:var(--jp-border-width) solid var(--jp-input-active-border-color);box-shadow:var(--jp-input-box-shadow);background-color:var(--jp-input-active-background)}.jupyter-wrapper select.jp-mod-styled:hover{background-color:var(--jp-layout-color1);cursor:pointer;color:var(--jp-ui-font-color0);background-color:var(--jp-input-hover-background);box-shadow:inset 0 0px 1px rgba(0,0,0,.5)}.jupyter-wrapper select.jp-mod-styled{flex:1 1 auto;height:32px;width:100%;font-size:var(--jp-ui-font-size2);background:var(--jp-input-background);color:var(--jp-ui-font-color0);padding:0 25px 0 8px;border:var(--jp-border-width) solid var(--jp-input-border-color);border-radius:0px;outline:none;appearance:none;-webkit-appearance:none;-moz-appearance:none}.jupyter-wrapper :root{--jp-private-toolbar-height: calc( 28px + var(--jp-border-width) )}.jupyter-wrapper .jp-Toolbar{color:var(--jp-ui-font-color1);flex:0 0 auto;display:flex;flex-direction:row;border-bottom:var(--jp-border-width) solid var(--jp-toolbar-border-color);box-shadow:var(--jp-toolbar-box-shadow);background:var(--jp-toolbar-background);min-height:var(--jp-toolbar-micro-height);padding:2px;z-index:1}.jupyter-wrapper .jp-Toolbar>.jp-Toolbar-item.jp-Toolbar-spacer{flex-grow:1;flex-shrink:1}.jupyter-wrapper .jp-Toolbar-item.jp-Toolbar-kernelStatus{display:inline-block;width:32px;background-repeat:no-repeat;background-position:center;background-size:16px}.jupyter-wrapper .jp-Toolbar>.jp-Toolbar-item{flex:0 0 auto;display:flex;padding-left:1px;padding-right:1px;font-size:var(--jp-ui-font-size1);line-height:var(--jp-private-toolbar-height);height:100%}.jupyter-wrapper div.jp-ToolbarButton{color:transparent;border:none;box-sizing:border-box;outline:none;appearance:none;-webkit-appearance:none;-moz-appearance:none;padding:0px;margin:0px}.jupyter-wrapper button.jp-ToolbarButtonComponent{background:var(--jp-layout-color1);border:none;box-sizing:border-box;outline:none;appearance:none;-webkit-appearance:none;-moz-appearance:none;padding:0px 6px;margin:0px;height:24px;border-radius:var(--jp-border-radius);display:flex;align-items:center;text-align:center;font-size:14px;min-width:unset;min-height:unset}.jupyter-wrapper button.jp-ToolbarButtonComponent:disabled{opacity:.4}.jupyter-wrapper button.jp-ToolbarButtonComponent span{padding:0px;flex:0 0 auto}.jupyter-wrapper button.jp-ToolbarButtonComponent .jp-ToolbarButtonComponent-label{font-size:var(--jp-ui-font-size1);line-height:100%;padding-left:2px;color:var(--jp-ui-font-color1)}.jupyter-wrapper body.p-mod-override-cursor *,.jupyter-wrapper body.lm-mod-override-cursor *{cursor:inherit !important}.jupyter-wrapper .jp-JSONEditor{display:flex;flex-direction:column;width:100%}.jupyter-wrapper .jp-JSONEditor-host{flex:1 1 auto;border:var(--jp-border-width) solid var(--jp-input-border-color);border-radius:0px;background:var(--jp-layout-color0);min-height:50px;padding:1px}.jupyter-wrapper .jp-JSONEditor.jp-mod-error .jp-JSONEditor-host{border-color:red;outline-color:red}.jupyter-wrapper .jp-JSONEditor-header{display:flex;flex:1 0 auto;padding:0 0 0 12px}.jupyter-wrapper .jp-JSONEditor-header label{flex:0 0 auto}.jupyter-wrapper .jp-JSONEditor-commitButton{height:16px;width:16px;background-size:18px;background-repeat:no-repeat;background-position:center}.jupyter-wrapper .jp-JSONEditor-host.jp-mod-focused{background-color:var(--jp-input-active-background);border:1px solid var(--jp-input-active-border-color);box-shadow:var(--jp-input-box-shadow)}.jupyter-wrapper .jp-Editor.jp-mod-dropTarget{border:var(--jp-border-width) solid var(--jp-input-active-border-color);box-shadow:var(--jp-input-box-shadow)}.jupyter-wrapper .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.jupyter-wrapper .CodeMirror-lines{padding:4px 0}.jupyter-wrapper .CodeMirror pre.CodeMirror-line,.jupyter-wrapper .CodeMirror pre.CodeMirror-line-like{padding:0 4px}.jupyter-wrapper .CodeMirror-scrollbar-filler,.jupyter-wrapper .CodeMirror-gutter-filler{background-color:#fff}.jupyter-wrapper .CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.jupyter-wrapper .CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.jupyter-wrapper .CodeMirror-guttermarker{color:#000}.jupyter-wrapper .CodeMirror-guttermarker-subtle{color:#999}.jupyter-wrapper .CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.jupyter-wrapper .CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.jupyter-wrapper .cm-fat-cursor .CodeMirror-cursor{width:auto;border:0 !important;background:#7e7}.jupyter-wrapper .cm-fat-cursor div.CodeMirror-cursors{z-index:1}.jupyter-wrapper .cm-fat-cursor-mark{background-color:rgba(20,255,20,.5);-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite}.jupyter-wrapper .cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.jupyter-wrapper .cm-tab{display:inline-block;text-decoration:inherit}.jupyter-wrapper .CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:0;overflow:hidden}.jupyter-wrapper .CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.jupyter-wrapper .cm-s-default .cm-header{color:blue}.jupyter-wrapper .cm-s-default .cm-quote{color:#090}.jupyter-wrapper .cm-negative{color:#d44}.jupyter-wrapper .cm-positive{color:#292}.jupyter-wrapper .cm-header,.jupyter-wrapper .cm-strong{font-weight:bold}.jupyter-wrapper .cm-em{font-style:italic}.jupyter-wrapper .cm-link{text-decoration:underline}.jupyter-wrapper .cm-strikethrough{text-decoration:line-through}.jupyter-wrapper .cm-s-default .cm-keyword{color:#708}.jupyter-wrapper .cm-s-default .cm-atom{color:#219}.jupyter-wrapper .cm-s-default .cm-number{color:#164}.jupyter-wrapper .cm-s-default .cm-def{color:blue}.jupyter-wrapper .cm-s-default .cm-variable-2{color:#05a}.jupyter-wrapper .cm-s-default .cm-variable-3,.jupyter-wrapper .cm-s-default .cm-type{color:#085}.jupyter-wrapper .cm-s-default .cm-comment{color:#a50}.jupyter-wrapper .cm-s-default .cm-string{color:#a11}.jupyter-wrapper .cm-s-default .cm-string-2{color:#f50}.jupyter-wrapper .cm-s-default .cm-meta{color:#555}.jupyter-wrapper .cm-s-default .cm-qualifier{color:#555}.jupyter-wrapper .cm-s-default .cm-builtin{color:#30a}.jupyter-wrapper .cm-s-default .cm-bracket{color:#997}.jupyter-wrapper .cm-s-default .cm-tag{color:#170}.jupyter-wrapper .cm-s-default .cm-attribute{color:#00c}.jupyter-wrapper .cm-s-default .cm-hr{color:#999}.jupyter-wrapper .cm-s-default .cm-link{color:#00c}.jupyter-wrapper .cm-s-default .cm-error{color:red}.jupyter-wrapper .cm-invalidchar{color:red}.jupyter-wrapper .CodeMirror-composing{border-bottom:2px solid}.jupyter-wrapper div.CodeMirror span.CodeMirror-matchingbracket{color:#0b0}.jupyter-wrapper div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#a22}.jupyter-wrapper .CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.jupyter-wrapper .CodeMirror-activeline-background{background:#e8f2ff}.jupyter-wrapper .CodeMirror{position:relative;overflow:hidden;background:#fff}.jupyter-wrapper .CodeMirror-scroll{overflow:scroll !important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:none;position:relative}.jupyter-wrapper .CodeMirror-sizer{position:relative;border-right:30px solid transparent}.jupyter-wrapper .CodeMirror-vscrollbar,.jupyter-wrapper .CodeMirror-hscrollbar,.jupyter-wrapper .CodeMirror-scrollbar-filler,.jupyter-wrapper .CodeMirror-gutter-filler{position:absolute;z-index:6;display:none}.jupyter-wrapper .CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.jupyter-wrapper .CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.jupyter-wrapper .CodeMirror-scrollbar-filler{right:0;bottom:0}.jupyter-wrapper .CodeMirror-gutter-filler{left:0;bottom:0}.jupyter-wrapper .CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.jupyter-wrapper .CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.jupyter-wrapper .CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:none !important;border:none !important}.jupyter-wrapper .CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.jupyter-wrapper .CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.jupyter-wrapper .CodeMirror-gutter-wrapper ::selection{background-color:transparent}.jupyter-wrapper .CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.jupyter-wrapper .CodeMirror-lines{cursor:text;min-height:1px}.jupyter-wrapper .CodeMirror pre.CodeMirror-line,.jupyter-wrapper .CodeMirror pre.CodeMirror-line-like{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:transparent;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.jupyter-wrapper .CodeMirror-wrap pre.CodeMirror-line,.jupyter-wrapper .CodeMirror-wrap pre.CodeMirror-line-like{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.jupyter-wrapper .CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.jupyter-wrapper .CodeMirror-linewidget{position:relative;z-index:2;padding:.1px}.jupyter-wrapper .CodeMirror-rtl pre{direction:rtl}.jupyter-wrapper .CodeMirror-code{outline:none}.jupyter-wrapper .CodeMirror-scroll,.jupyter-wrapper .CodeMirror-sizer,.jupyter-wrapper .CodeMirror-gutter,.jupyter-wrapper .CodeMirror-gutters,.jupyter-wrapper .CodeMirror-linenumber{-moz-box-sizing:content-box;box-sizing:content-box}.jupyter-wrapper .CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.jupyter-wrapper .CodeMirror-cursor{position:absolute;pointer-events:none}.jupyter-wrapper .CodeMirror-measure pre{position:static}.jupyter-wrapper div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}.jupyter-wrapper div.CodeMirror-dragcursors{visibility:visible}.jupyter-wrapper .CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.jupyter-wrapper .CodeMirror-selected{background:#d9d9d9}.jupyter-wrapper .CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.jupyter-wrapper .CodeMirror-crosshair{cursor:crosshair}.jupyter-wrapper .CodeMirror-line::selection,.jupyter-wrapper .CodeMirror-line>span::selection,.jupyter-wrapper .CodeMirror-line>span>span::selection{background:#d7d4f0}.jupyter-wrapper .CodeMirror-line::-moz-selection,.jupyter-wrapper .CodeMirror-line>span::-moz-selection,.jupyter-wrapper .CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.jupyter-wrapper .cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.jupyter-wrapper .cm-force-border{padding-right:.1px}@media print{.jupyter-wrapper .CodeMirror div.CodeMirror-cursors{visibility:hidden}}.jupyter-wrapper .cm-tab-wrap-hack:after{content:\"\"}.jupyter-wrapper span.CodeMirror-selectedtext{background:none}.jupyter-wrapper .CodeMirror-dialog{position:absolute;left:0;right:0;background:inherit;z-index:15;padding:.1em .8em;overflow:hidden;color:inherit}.jupyter-wrapper .CodeMirror-dialog-top{border-bottom:1px solid #eee;top:0}.jupyter-wrapper .CodeMirror-dialog-bottom{border-top:1px solid #eee;bottom:0}.jupyter-wrapper .CodeMirror-dialog input{border:none;outline:none;background:transparent;width:20em;color:inherit;font-family:monospace}.jupyter-wrapper .CodeMirror-dialog button{font-size:70%}.jupyter-wrapper .CodeMirror-foldmarker{color:blue;text-shadow:#b9f 1px 1px 2px,#b9f -1px -1px 2px,#b9f 1px -1px 2px,#b9f -1px 1px 2px;font-family:arial;line-height:.3;cursor:pointer}.jupyter-wrapper .CodeMirror-foldgutter{width:.7em}.jupyter-wrapper .CodeMirror-foldgutter-open,.jupyter-wrapper .CodeMirror-foldgutter-folded{cursor:pointer}.jupyter-wrapper .CodeMirror-foldgutter-open:after{content:\"\u25be\"}.jupyter-wrapper .CodeMirror-foldgutter-folded:after{content:\"\u25b8\"}.jupyter-wrapper .cm-s-material.CodeMirror{background-color:#263238;color:#eff}.jupyter-wrapper .cm-s-material .CodeMirror-gutters{background:#263238;color:#546e7a;border:none}.jupyter-wrapper .cm-s-material .CodeMirror-guttermarker,.jupyter-wrapper .cm-s-material .CodeMirror-guttermarker-subtle,.jupyter-wrapper .cm-s-material .CodeMirror-linenumber{color:#546e7a}.jupyter-wrapper .cm-s-material .CodeMirror-cursor{border-left:1px solid #fc0}.jupyter-wrapper .cm-s-material div.CodeMirror-selected{background:rgba(128,203,196,.2)}.jupyter-wrapper .cm-s-material.CodeMirror-focused div.CodeMirror-selected{background:rgba(128,203,196,.2)}.jupyter-wrapper .cm-s-material .CodeMirror-line::selection,.jupyter-wrapper .cm-s-material .CodeMirror-line>span::selection,.jupyter-wrapper .cm-s-material .CodeMirror-line>span>span::selection{background:rgba(128,203,196,.2)}.jupyter-wrapper .cm-s-material .CodeMirror-line::-moz-selection,.jupyter-wrapper .cm-s-material .CodeMirror-line>span::-moz-selection,.jupyter-wrapper .cm-s-material .CodeMirror-line>span>span::-moz-selection{background:rgba(128,203,196,.2)}.jupyter-wrapper .cm-s-material .CodeMirror-activeline-background{background:rgba(0,0,0,.5)}.jupyter-wrapper .cm-s-material .cm-keyword{color:#c792ea}.jupyter-wrapper .cm-s-material .cm-operator{color:#89ddff}.jupyter-wrapper .cm-s-material .cm-variable-2{color:#eff}.jupyter-wrapper .cm-s-material .cm-variable-3,.jupyter-wrapper .cm-s-material .cm-type{color:#f07178}.jupyter-wrapper .cm-s-material .cm-builtin{color:#ffcb6b}.jupyter-wrapper .cm-s-material .cm-atom{color:#f78c6c}.jupyter-wrapper .cm-s-material .cm-number{color:#ff5370}.jupyter-wrapper .cm-s-material .cm-def{color:#82aaff}.jupyter-wrapper .cm-s-material .cm-string{color:#c3e88d}.jupyter-wrapper .cm-s-material .cm-string-2{color:#f07178}.jupyter-wrapper .cm-s-material .cm-comment{color:#546e7a}.jupyter-wrapper .cm-s-material .cm-variable{color:#f07178}.jupyter-wrapper .cm-s-material .cm-tag{color:#ff5370}.jupyter-wrapper .cm-s-material .cm-meta{color:#ffcb6b}.jupyter-wrapper .cm-s-material .cm-attribute{color:#c792ea}.jupyter-wrapper .cm-s-material .cm-property{color:#c792ea}.jupyter-wrapper .cm-s-material .cm-qualifier{color:#decb6b}.jupyter-wrapper .cm-s-material .cm-variable-3,.jupyter-wrapper .cm-s-material .cm-type{color:#decb6b}.jupyter-wrapper .cm-s-material .cm-error{color:#fff;background-color:#ff5370}.jupyter-wrapper .cm-s-material .CodeMirror-matchingbracket{text-decoration:underline;color:#fff !important}.jupyter-wrapper .cm-s-zenburn .CodeMirror-gutters{background:#3f3f3f !important}.jupyter-wrapper .cm-s-zenburn .CodeMirror-foldgutter-open,.jupyter-wrapper .CodeMirror-foldgutter-folded{color:#999}.jupyter-wrapper .cm-s-zenburn .CodeMirror-cursor{border-left:1px solid #fff}.jupyter-wrapper .cm-s-zenburn{background-color:#3f3f3f;color:#dcdccc}.jupyter-wrapper .cm-s-zenburn span.cm-builtin{color:#dcdccc;font-weight:bold}.jupyter-wrapper .cm-s-zenburn span.cm-comment{color:#7f9f7f}.jupyter-wrapper .cm-s-zenburn span.cm-keyword{color:#f0dfaf;font-weight:bold}.jupyter-wrapper .cm-s-zenburn span.cm-atom{color:#bfebbf}.jupyter-wrapper .cm-s-zenburn span.cm-def{color:#dcdccc}.jupyter-wrapper .cm-s-zenburn span.cm-variable{color:#dfaf8f}.jupyter-wrapper .cm-s-zenburn span.cm-variable-2{color:#dcdccc}.jupyter-wrapper .cm-s-zenburn span.cm-string{color:#cc9393}.jupyter-wrapper .cm-s-zenburn span.cm-string-2{color:#cc9393}.jupyter-wrapper .cm-s-zenburn span.cm-number{color:#dcdccc}.jupyter-wrapper .cm-s-zenburn span.cm-tag{color:#93e0e3}.jupyter-wrapper .cm-s-zenburn span.cm-property{color:#dfaf8f}.jupyter-wrapper .cm-s-zenburn span.cm-attribute{color:#dfaf8f}.jupyter-wrapper .cm-s-zenburn span.cm-qualifier{color:#7cb8bb}.jupyter-wrapper .cm-s-zenburn span.cm-meta{color:#f0dfaf}.jupyter-wrapper .cm-s-zenburn span.cm-header{color:#f0efd0}.jupyter-wrapper .cm-s-zenburn span.cm-operator{color:#f0efd0}.jupyter-wrapper .cm-s-zenburn span.CodeMirror-matchingbracket{box-sizing:border-box;background:transparent;border-bottom:1px solid}.jupyter-wrapper .cm-s-zenburn span.CodeMirror-nonmatchingbracket{border-bottom:1px solid;background:none}.jupyter-wrapper .cm-s-zenburn .CodeMirror-activeline{background:#000}.jupyter-wrapper .cm-s-zenburn .CodeMirror-activeline-background{background:#000}.jupyter-wrapper .cm-s-zenburn div.CodeMirror-selected{background:#545454}.jupyter-wrapper .cm-s-zenburn .CodeMirror-focused div.CodeMirror-selected{background:#4f4f4f}.jupyter-wrapper .cm-s-abcdef.CodeMirror{background:#0f0f0f;color:#defdef}.jupyter-wrapper .cm-s-abcdef div.CodeMirror-selected{background:#515151}.jupyter-wrapper .cm-s-abcdef .CodeMirror-line::selection,.jupyter-wrapper .cm-s-abcdef .CodeMirror-line>span::selection,.jupyter-wrapper .cm-s-abcdef .CodeMirror-line>span>span::selection{background:rgba(56,56,56,.99)}.jupyter-wrapper .cm-s-abcdef .CodeMirror-line::-moz-selection,.jupyter-wrapper .cm-s-abcdef .CodeMirror-line>span::-moz-selection,.jupyter-wrapper .cm-s-abcdef .CodeMirror-line>span>span::-moz-selection{background:rgba(56,56,56,.99)}.jupyter-wrapper .cm-s-abcdef .CodeMirror-gutters{background:#555;border-right:2px solid #314151}.jupyter-wrapper .cm-s-abcdef .CodeMirror-guttermarker{color:#222}.jupyter-wrapper .cm-s-abcdef .CodeMirror-guttermarker-subtle{color:azure}.jupyter-wrapper .cm-s-abcdef .CodeMirror-linenumber{color:#fff}.jupyter-wrapper .cm-s-abcdef .CodeMirror-cursor{border-left:1px solid lime}.jupyter-wrapper .cm-s-abcdef span.cm-keyword{color:#b8860b;font-weight:bold}.jupyter-wrapper .cm-s-abcdef span.cm-atom{color:#77f}.jupyter-wrapper .cm-s-abcdef span.cm-number{color:violet}.jupyter-wrapper .cm-s-abcdef span.cm-def{color:#fffabc}.jupyter-wrapper .cm-s-abcdef span.cm-variable{color:#abcdef}.jupyter-wrapper .cm-s-abcdef span.cm-variable-2{color:#cacbcc}.jupyter-wrapper .cm-s-abcdef span.cm-variable-3,.jupyter-wrapper .cm-s-abcdef span.cm-type{color:#def}.jupyter-wrapper .cm-s-abcdef span.cm-property{color:#fedcba}.jupyter-wrapper .cm-s-abcdef span.cm-operator{color:#ff0}.jupyter-wrapper .cm-s-abcdef span.cm-comment{color:#7a7b7c;font-style:italic}.jupyter-wrapper .cm-s-abcdef span.cm-string{color:#2b4}.jupyter-wrapper .cm-s-abcdef span.cm-meta{color:#c9f}.jupyter-wrapper .cm-s-abcdef span.cm-qualifier{color:#fff700}.jupyter-wrapper .cm-s-abcdef span.cm-builtin{color:#30aabc}.jupyter-wrapper .cm-s-abcdef span.cm-bracket{color:#8a8a8a}.jupyter-wrapper .cm-s-abcdef span.cm-tag{color:#fd4}.jupyter-wrapper .cm-s-abcdef span.cm-attribute{color:#df0}.jupyter-wrapper .cm-s-abcdef span.cm-error{color:red}.jupyter-wrapper .cm-s-abcdef span.cm-header{color:#7fffd4;font-weight:bold}.jupyter-wrapper .cm-s-abcdef span.cm-link{color:#8a2be2}.jupyter-wrapper .cm-s-abcdef .CodeMirror-activeline-background{background:#314151}.jupyter-wrapper .cm-s-base16-light.CodeMirror{background:#f5f5f5;color:#202020}.jupyter-wrapper .cm-s-base16-light div.CodeMirror-selected{background:#e0e0e0}.jupyter-wrapper .cm-s-base16-light .CodeMirror-line::selection,.jupyter-wrapper .cm-s-base16-light .CodeMirror-line>span::selection,.jupyter-wrapper .cm-s-base16-light .CodeMirror-line>span>span::selection{background:#e0e0e0}.jupyter-wrapper .cm-s-base16-light .CodeMirror-line::-moz-selection,.jupyter-wrapper .cm-s-base16-light .CodeMirror-line>span::-moz-selection,.jupyter-wrapper .cm-s-base16-light .CodeMirror-line>span>span::-moz-selection{background:#e0e0e0}.jupyter-wrapper .cm-s-base16-light .CodeMirror-gutters{background:#f5f5f5;border-right:0px}.jupyter-wrapper .cm-s-base16-light .CodeMirror-guttermarker{color:#ac4142}.jupyter-wrapper .cm-s-base16-light .CodeMirror-guttermarker-subtle{color:#b0b0b0}.jupyter-wrapper .cm-s-base16-light .CodeMirror-linenumber{color:#b0b0b0}.jupyter-wrapper .cm-s-base16-light .CodeMirror-cursor{border-left:1px solid #505050}.jupyter-wrapper .cm-s-base16-light span.cm-comment{color:#8f5536}.jupyter-wrapper .cm-s-base16-light span.cm-atom{color:#aa759f}.jupyter-wrapper .cm-s-base16-light span.cm-number{color:#aa759f}.jupyter-wrapper .cm-s-base16-light span.cm-property,.jupyter-wrapper .cm-s-base16-light span.cm-attribute{color:#90a959}.jupyter-wrapper .cm-s-base16-light span.cm-keyword{color:#ac4142}.jupyter-wrapper .cm-s-base16-light span.cm-string{color:#f4bf75}.jupyter-wrapper .cm-s-base16-light span.cm-variable{color:#90a959}.jupyter-wrapper .cm-s-base16-light span.cm-variable-2{color:#6a9fb5}.jupyter-wrapper .cm-s-base16-light span.cm-def{color:#d28445}.jupyter-wrapper .cm-s-base16-light span.cm-bracket{color:#202020}.jupyter-wrapper .cm-s-base16-light span.cm-tag{color:#ac4142}.jupyter-wrapper .cm-s-base16-light span.cm-link{color:#aa759f}.jupyter-wrapper .cm-s-base16-light span.cm-error{background:#ac4142;color:#505050}.jupyter-wrapper .cm-s-base16-light .CodeMirror-activeline-background{background:#dddcdc}.jupyter-wrapper .cm-s-base16-light .CodeMirror-matchingbracket{color:#f5f5f5 !important;background-color:#6a9fb5 !important}.jupyter-wrapper .cm-s-base16-dark.CodeMirror{background:#151515;color:#e0e0e0}.jupyter-wrapper .cm-s-base16-dark div.CodeMirror-selected{background:#303030}.jupyter-wrapper .cm-s-base16-dark .CodeMirror-line::selection,.jupyter-wrapper .cm-s-base16-dark .CodeMirror-line>span::selection,.jupyter-wrapper .cm-s-base16-dark .CodeMirror-line>span>span::selection{background:rgba(48,48,48,.99)}.jupyter-wrapper .cm-s-base16-dark .CodeMirror-line::-moz-selection,.jupyter-wrapper .cm-s-base16-dark .CodeMirror-line>span::-moz-selection,.jupyter-wrapper .cm-s-base16-dark .CodeMirror-line>span>span::-moz-selection{background:rgba(48,48,48,.99)}.jupyter-wrapper .cm-s-base16-dark .CodeMirror-gutters{background:#151515;border-right:0px}.jupyter-wrapper .cm-s-base16-dark .CodeMirror-guttermarker{color:#ac4142}.jupyter-wrapper .cm-s-base16-dark .CodeMirror-guttermarker-subtle{color:#505050}.jupyter-wrapper .cm-s-base16-dark .CodeMirror-linenumber{color:#505050}.jupyter-wrapper .cm-s-base16-dark .CodeMirror-cursor{border-left:1px solid #b0b0b0}.jupyter-wrapper .cm-s-base16-dark span.cm-comment{color:#8f5536}.jupyter-wrapper .cm-s-base16-dark span.cm-atom{color:#aa759f}.jupyter-wrapper .cm-s-base16-dark span.cm-number{color:#aa759f}.jupyter-wrapper .cm-s-base16-dark span.cm-property,.jupyter-wrapper .cm-s-base16-dark span.cm-attribute{color:#90a959}.jupyter-wrapper .cm-s-base16-dark span.cm-keyword{color:#ac4142}.jupyter-wrapper .cm-s-base16-dark span.cm-string{color:#f4bf75}.jupyter-wrapper .cm-s-base16-dark span.cm-variable{color:#90a959}.jupyter-wrapper .cm-s-base16-dark span.cm-variable-2{color:#6a9fb5}.jupyter-wrapper .cm-s-base16-dark span.cm-def{color:#d28445}.jupyter-wrapper .cm-s-base16-dark span.cm-bracket{color:#e0e0e0}.jupyter-wrapper .cm-s-base16-dark span.cm-tag{color:#ac4142}.jupyter-wrapper .cm-s-base16-dark span.cm-link{color:#aa759f}.jupyter-wrapper .cm-s-base16-dark span.cm-error{background:#ac4142;color:#b0b0b0}.jupyter-wrapper .cm-s-base16-dark .CodeMirror-activeline-background{background:#202020}.jupyter-wrapper .cm-s-base16-dark .CodeMirror-matchingbracket{text-decoration:underline;color:#fff !important}.jupyter-wrapper .cm-s-dracula.CodeMirror,.jupyter-wrapper .cm-s-dracula .CodeMirror-gutters{background-color:#282a36 !important;color:#f8f8f2 !important;border:none}.jupyter-wrapper .cm-s-dracula .CodeMirror-gutters{color:#282a36}.jupyter-wrapper .cm-s-dracula .CodeMirror-cursor{border-left:solid thin #f8f8f0}.jupyter-wrapper .cm-s-dracula .CodeMirror-linenumber{color:#6d8a88}.jupyter-wrapper .cm-s-dracula .CodeMirror-selected{background:rgba(255,255,255,.1)}.jupyter-wrapper .cm-s-dracula .CodeMirror-line::selection,.jupyter-wrapper .cm-s-dracula .CodeMirror-line>span::selection,.jupyter-wrapper .cm-s-dracula .CodeMirror-line>span>span::selection{background:rgba(255,255,255,.1)}.jupyter-wrapper .cm-s-dracula .CodeMirror-line::-moz-selection,.jupyter-wrapper .cm-s-dracula .CodeMirror-line>span::-moz-selection,.jupyter-wrapper .cm-s-dracula .CodeMirror-line>span>span::-moz-selection{background:rgba(255,255,255,.1)}.jupyter-wrapper .cm-s-dracula span.cm-comment{color:#6272a4}.jupyter-wrapper .cm-s-dracula span.cm-string,.jupyter-wrapper .cm-s-dracula span.cm-string-2{color:#f1fa8c}.jupyter-wrapper .cm-s-dracula span.cm-number{color:#bd93f9}.jupyter-wrapper .cm-s-dracula span.cm-variable{color:#50fa7b}.jupyter-wrapper .cm-s-dracula span.cm-variable-2{color:#fff}.jupyter-wrapper .cm-s-dracula span.cm-def{color:#50fa7b}.jupyter-wrapper .cm-s-dracula span.cm-operator{color:#ff79c6}.jupyter-wrapper .cm-s-dracula span.cm-keyword{color:#ff79c6}.jupyter-wrapper .cm-s-dracula span.cm-atom{color:#bd93f9}.jupyter-wrapper .cm-s-dracula span.cm-meta{color:#f8f8f2}.jupyter-wrapper .cm-s-dracula span.cm-tag{color:#ff79c6}.jupyter-wrapper .cm-s-dracula span.cm-attribute{color:#50fa7b}.jupyter-wrapper .cm-s-dracula span.cm-qualifier{color:#50fa7b}.jupyter-wrapper .cm-s-dracula span.cm-property{color:#66d9ef}.jupyter-wrapper .cm-s-dracula span.cm-builtin{color:#50fa7b}.jupyter-wrapper .cm-s-dracula span.cm-variable-3,.jupyter-wrapper .cm-s-dracula span.cm-type{color:#ffb86c}.jupyter-wrapper .cm-s-dracula .CodeMirror-activeline-background{background:rgba(255,255,255,.1)}.jupyter-wrapper .cm-s-dracula .CodeMirror-matchingbracket{text-decoration:underline;color:#fff !important}.jupyter-wrapper .cm-s-hopscotch.CodeMirror{background:#322931;color:#d5d3d5}.jupyter-wrapper .cm-s-hopscotch div.CodeMirror-selected{background:#433b42 !important}.jupyter-wrapper .cm-s-hopscotch .CodeMirror-gutters{background:#322931;border-right:0px}.jupyter-wrapper .cm-s-hopscotch .CodeMirror-linenumber{color:#797379}.jupyter-wrapper .cm-s-hopscotch .CodeMirror-cursor{border-left:1px solid #989498 !important}.jupyter-wrapper .cm-s-hopscotch span.cm-comment{color:#b33508}.jupyter-wrapper .cm-s-hopscotch span.cm-atom{color:#c85e7c}.jupyter-wrapper .cm-s-hopscotch span.cm-number{color:#c85e7c}.jupyter-wrapper .cm-s-hopscotch span.cm-property,.jupyter-wrapper .cm-s-hopscotch span.cm-attribute{color:#8fc13e}.jupyter-wrapper .cm-s-hopscotch span.cm-keyword{color:#dd464c}.jupyter-wrapper .cm-s-hopscotch span.cm-string{color:#fdcc59}.jupyter-wrapper .cm-s-hopscotch span.cm-variable{color:#8fc13e}.jupyter-wrapper .cm-s-hopscotch span.cm-variable-2{color:#1290bf}.jupyter-wrapper .cm-s-hopscotch span.cm-def{color:#fd8b19}.jupyter-wrapper .cm-s-hopscotch span.cm-error{background:#dd464c;color:#989498}.jupyter-wrapper .cm-s-hopscotch span.cm-bracket{color:#d5d3d5}.jupyter-wrapper .cm-s-hopscotch span.cm-tag{color:#dd464c}.jupyter-wrapper .cm-s-hopscotch span.cm-link{color:#c85e7c}.jupyter-wrapper .cm-s-hopscotch .CodeMirror-matchingbracket{text-decoration:underline;color:#fff !important}.jupyter-wrapper .cm-s-hopscotch .CodeMirror-activeline-background{background:#302020}.jupyter-wrapper .cm-s-mbo.CodeMirror{background:#2c2c2c;color:#ffffec}.jupyter-wrapper .cm-s-mbo div.CodeMirror-selected{background:#716c62}.jupyter-wrapper .cm-s-mbo .CodeMirror-line::selection,.jupyter-wrapper .cm-s-mbo .CodeMirror-line>span::selection,.jupyter-wrapper .cm-s-mbo .CodeMirror-line>span>span::selection{background:rgba(113,108,98,.99)}.jupyter-wrapper .cm-s-mbo .CodeMirror-line::-moz-selection,.jupyter-wrapper .cm-s-mbo .CodeMirror-line>span::-moz-selection,.jupyter-wrapper .cm-s-mbo .CodeMirror-line>span>span::-moz-selection{background:rgba(113,108,98,.99)}.jupyter-wrapper .cm-s-mbo .CodeMirror-gutters{background:#4e4e4e;border-right:0px}.jupyter-wrapper .cm-s-mbo .CodeMirror-guttermarker{color:#fff}.jupyter-wrapper .cm-s-mbo .CodeMirror-guttermarker-subtle{color:gray}.jupyter-wrapper .cm-s-mbo .CodeMirror-linenumber{color:#dadada}.jupyter-wrapper .cm-s-mbo .CodeMirror-cursor{border-left:1px solid #ffffec}.jupyter-wrapper .cm-s-mbo span.cm-comment{color:#95958a}.jupyter-wrapper .cm-s-mbo span.cm-atom{color:#00a8c6}.jupyter-wrapper .cm-s-mbo span.cm-number{color:#00a8c6}.jupyter-wrapper .cm-s-mbo span.cm-property,.jupyter-wrapper .cm-s-mbo span.cm-attribute{color:#9ddfe9}.jupyter-wrapper .cm-s-mbo span.cm-keyword{color:#ffb928}.jupyter-wrapper .cm-s-mbo span.cm-string{color:#ffcf6c}.jupyter-wrapper .cm-s-mbo span.cm-string.cm-property{color:#ffffec}.jupyter-wrapper .cm-s-mbo span.cm-variable{color:#ffffec}.jupyter-wrapper .cm-s-mbo span.cm-variable-2{color:#00a8c6}.jupyter-wrapper .cm-s-mbo span.cm-def{color:#ffffec}.jupyter-wrapper .cm-s-mbo span.cm-bracket{color:#fffffc;font-weight:bold}.jupyter-wrapper .cm-s-mbo span.cm-tag{color:#9ddfe9}.jupyter-wrapper .cm-s-mbo span.cm-link{color:#f54b07}.jupyter-wrapper .cm-s-mbo span.cm-error{border-bottom:#636363;color:#ffffec}.jupyter-wrapper .cm-s-mbo span.cm-qualifier{color:#ffffec}.jupyter-wrapper .cm-s-mbo .CodeMirror-activeline-background{background:#494b41}.jupyter-wrapper .cm-s-mbo .CodeMirror-matchingbracket{color:#ffb928 !important}.jupyter-wrapper .cm-s-mbo .CodeMirror-matchingtag{background:rgba(255,255,255,.37)}.jupyter-wrapper .cm-s-mdn-like.CodeMirror{color:#999;background-color:#fff}.jupyter-wrapper .cm-s-mdn-like div.CodeMirror-selected{background:#cfc}.jupyter-wrapper .cm-s-mdn-like .CodeMirror-line::selection,.jupyter-wrapper .cm-s-mdn-like .CodeMirror-line>span::selection,.jupyter-wrapper .cm-s-mdn-like .CodeMirror-line>span>span::selection{background:#cfc}.jupyter-wrapper .cm-s-mdn-like .CodeMirror-line::-moz-selection,.jupyter-wrapper .cm-s-mdn-like .CodeMirror-line>span::-moz-selection,.jupyter-wrapper .cm-s-mdn-like .CodeMirror-line>span>span::-moz-selection{background:#cfc}.jupyter-wrapper .cm-s-mdn-like .CodeMirror-gutters{background:#f8f8f8;border-left:6px solid rgba(0,83,159,.65);color:#333}.jupyter-wrapper .cm-s-mdn-like .CodeMirror-linenumber{color:#aaa;padding-left:8px}.jupyter-wrapper .cm-s-mdn-like .CodeMirror-cursor{border-left:2px solid #222}.jupyter-wrapper .cm-s-mdn-like .cm-keyword{color:#6262ff}.jupyter-wrapper .cm-s-mdn-like .cm-atom{color:#f90}.jupyter-wrapper .cm-s-mdn-like .cm-number{color:#ca7841}.jupyter-wrapper .cm-s-mdn-like .cm-def{color:#8da6ce}.jupyter-wrapper .cm-s-mdn-like span.cm-variable-2,.jupyter-wrapper .cm-s-mdn-like span.cm-tag{color:#690}.jupyter-wrapper .cm-s-mdn-like span.cm-variable-3,.jupyter-wrapper .cm-s-mdn-like span.cm-def,.jupyter-wrapper .cm-s-mdn-like span.cm-type{color:#07a}.jupyter-wrapper .cm-s-mdn-like .cm-variable{color:#07a}.jupyter-wrapper .cm-s-mdn-like .cm-property{color:#905}.jupyter-wrapper .cm-s-mdn-like .cm-qualifier{color:#690}.jupyter-wrapper .cm-s-mdn-like .cm-operator{color:#cda869}.jupyter-wrapper .cm-s-mdn-like .cm-comment{color:#777;font-weight:normal}.jupyter-wrapper .cm-s-mdn-like .cm-string{color:#07a;font-style:italic}.jupyter-wrapper .cm-s-mdn-like .cm-string-2{color:#bd6b18}.jupyter-wrapper .cm-s-mdn-like .cm-meta{color:#000}.jupyter-wrapper .cm-s-mdn-like .cm-builtin{color:#9b7536}.jupyter-wrapper .cm-s-mdn-like .cm-tag{color:#997643}.jupyter-wrapper .cm-s-mdn-like .cm-attribute{color:#d6bb6d}.jupyter-wrapper .cm-s-mdn-like .cm-header{color:#ff6400}.jupyter-wrapper .cm-s-mdn-like .cm-hr{color:#aeaeae}.jupyter-wrapper .cm-s-mdn-like .cm-link{color:#ad9361;font-style:italic;text-decoration:none}.jupyter-wrapper .cm-s-mdn-like .cm-error{border-bottom:1px solid red}.jupyter-wrapper div.cm-s-mdn-like .CodeMirror-activeline-background{background:#efefff}.jupyter-wrapper div.cm-s-mdn-like span.CodeMirror-matchingbracket{outline:1px solid gray;color:inherit}.jupyter-wrapper .cm-s-mdn-like.CodeMirror{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFcAAAAyCAYAAAAp8UeFAAAHvklEQVR42s2b63bcNgyEQZCSHCdt2vd/0tWF7I+Q6XgMXiTtuvU5Pl57ZQKkKHzEAOtF5KeIJBGJ8uvL599FRFREZhFx8DeXv8trn68RuGaC8TRfo3SNp9dlDDHedyLyTUTeRWStXKPZrjtpZxaRw5hPqozRs1N8/enzIiQRWcCgy4MUA0f+XWliDhyL8Lfyvx7ei/Ae3iQFHyw7U/59pQVIMEEPEz0G7XiwdRjzSfC3UTtz9vchIntxvry5iMgfIhJoEflOz2CQr3F5h/HfeFe+GTdLaKcu9L8LTeQb/R/7GgbsfKedyNdoHsN31uRPWrfZ5wsj/NzzRQHuToIdU3ahwnsKPxXCjJITuOsi7XLc7SG/v5GdALs7wf8JjTFiB5+QvTEfRyGOfX3Lrx8wxyQi3sNq46O7QahQiCsRFgqddjBouVEHOKDgXAQHD9gJCr5sMKkEdjwsarG/ww3BMHBU7OBjXnzdyY7SfCxf5/z6ATccrwlKuwC/jhznnPF4CgVzhhVf4xp2EixcBActO75iZ8/fM9zAs2OMzKdslgXWJ9XG8PQoOAMA5fGcsvORgv0doBXyHrCwfLJAOwo71QLNkb8n2Pl6EWiR7OCibtkPaz4Kc/0NNAze2gju3zOwekALDaCFPI5vjPFmgGY5AZqyGEvH1x7QfIb8YtxMnA/b+QQ0aQDAwc6JMFg8CbQZ4qoYEEHbRwNojuK3EHwd7VALSgq+MNDKzfT58T8qdpADrgW0GmgcAS1lhzztJmkAzcPNOQbsWEALBDSlMKUG0Eq4CLAQWvEVQ9WU57gZJwZtgPO3r9oBTQ9WO8TjqXINx8R0EYpiZEUWOF3FxkbJkgU9B2f41YBrIj5ZfsQa0M5kTgiAAqM3ShXLgu8XMqcrQBvJ0CL5pnTsfMB13oB8athpAq2XOQmcGmoACCLydx7nToa23ATaSIY2ichfOdPTGxlasXMLaL0MLZAOwAKIM+y8CmicobGdCcbbK9DzN+yYGVoNNI5iUKTMyYOjPse4A8SM1MmcXgU0toOq1yO/v8FOxlASyc7TgeYaAMBJHcY1CcCwGI/TK4AmDbDyKYBBtFUkRwto8gygiQEaByFgJ00BH2M8JWwQS1nafDXQCidWyOI8AcjDCSjCLk8ngObuAm3JAHAdubAmOaK06V8MNEsKPJOhobSprwQa6gD7DclRQdqcwL4zxqgBrQcabUiBLclRDKAlWp+etPkBaNMA0AKlrHwTdEByZAA4GM+SNluSY6wAzcMNewxmgig5Ks0nkrSpBvSaQHMdKTBAnLojOdYyGpQ254602ZILPdTD1hdlggdIm74jbTp8vDwF5ZYUeLWGJpWsh6XNyXgcYwVoJQTEhhTYkxzZjiU5npU2TaB979TQehlaAVq4kaGpiPwwwLkYUuBbQwocyQTv1tA0+1UFWoJF3iv1oq+qoSk8EQdJmwHkziIF7oOZk14EGitibAdjLYYK78H5vZOhtWpoI0ATGHs0Q8OMb4Ey+2bU2UYztCtA0wFAs7TplGLRVQCcqaFdGSPCeTI1QNIC52iWNzof6Uib7xjEp07mNNoUYmVosVItHrHzRlLgBn9LFyRHaQCtVUMbtTNhoXWiTOO9k/V8BdAc1Oq0ArSQs6/5SU0hckNy9NnXqQY0PGYo5dWJ7nINaN6o958FWin27aBaWRka1r5myvLOAm0j30eBJqCxHLReVclxhxOEN2JfDWjxBtAC7MIH1fVaGdoOp4qJYDgKtKPSFNID2gSnGldrCqkFZ+5UeQXQBIRrSwocbdZYQT/2LwRahBPBXoHrB8nxaGROST62DKUbQOMMzZIC9abkuELfQzQALWTnDNAm8KHWFOJgJ5+SHIvTPcmx1xQyZRhNL5Qci689aXMEaN/uNIWkEwDAvFpOZmgsBaaGnbs1NPa1Jm32gBZAIh1pCtG7TSH4aE0y1uVY4uqoFPisGlpP2rSA5qTecWn5agK6BzSpgAyD+wFaqhnYoSZ1Vwr8CmlTQbrcO3ZaX0NAEyMbYaAlyquFoLKK3SPby9CeVUPThrSJmkCAE0CrKUQadi4DrdSlWhmah0YL9z9vClH59YGbHx1J8VZTyAjQepJjmXwAKTDQI3omc3p1U4gDUf6RfcdYfrUp5ClAi2J3Ba6UOXGo+K+bQrjjssitG2SJzshaLwMtXgRagUNpYYoVkMSBLM+9GGiJZMvduG6DRZ4qc04DMPtQQxOjEtACmhO7K1AbNbQDEggZyJwscFpAGwENhoBeUwh3bWolhe8BTYVKxQEWrSUn/uhcM5KhvUu/+eQu0Lzhi+VrK0PrZZNDQKs9cpYUuFYgMVpD4/NxenJTiMCNqdUEUf1qZWjppLT5qSkkUZbCwkbZMSuVnu80hfSkzRbQeqCZSAh6huR4VtoM2gHAlLf72smuWgE+VV7XpE25Ab2WFDgyhnSuKbs4GuGzCjR+tIoUuMFg3kgcWKLTwRqanJQ2W00hAsenfaApRC42hbCvK1SlE0HtE9BGgneJO+ELamitD1YjjOYnNYVcraGhtKkW0EqVVeDx733I2NH581k1NNxNLG0i0IJ8/NjVaOZ0tYZ2Vtr0Xv7tPV3hkWp9EFkgS/J0vosngTaSoaG06WHi+xObQkaAdlbanP8B2+2l0f90LmUAAAAASUVORK5CYII=)}.jupyter-wrapper .cm-s-seti.CodeMirror{background-color:#151718 !important;color:#cfd2d1 !important;border:none}.jupyter-wrapper .cm-s-seti .CodeMirror-gutters{color:#404b53;background-color:#0e1112;border:none}.jupyter-wrapper .cm-s-seti .CodeMirror-cursor{border-left:solid thin #f8f8f0}.jupyter-wrapper .cm-s-seti .CodeMirror-linenumber{color:#6d8a88}.jupyter-wrapper .cm-s-seti.CodeMirror-focused div.CodeMirror-selected{background:rgba(255,255,255,.1)}.jupyter-wrapper .cm-s-seti .CodeMirror-line::selection,.jupyter-wrapper .cm-s-seti .CodeMirror-line>span::selection,.jupyter-wrapper .cm-s-seti .CodeMirror-line>span>span::selection{background:rgba(255,255,255,.1)}.jupyter-wrapper .cm-s-seti .CodeMirror-line::-moz-selection,.jupyter-wrapper .cm-s-seti .CodeMirror-line>span::-moz-selection,.jupyter-wrapper .cm-s-seti .CodeMirror-line>span>span::-moz-selection{background:rgba(255,255,255,.1)}.jupyter-wrapper .cm-s-seti span.cm-comment{color:#41535b}.jupyter-wrapper .cm-s-seti span.cm-string,.jupyter-wrapper .cm-s-seti span.cm-string-2{color:#55b5db}.jupyter-wrapper .cm-s-seti span.cm-number{color:#cd3f45}.jupyter-wrapper .cm-s-seti span.cm-variable{color:#55b5db}.jupyter-wrapper .cm-s-seti span.cm-variable-2{color:#a074c4}.jupyter-wrapper .cm-s-seti span.cm-def{color:#55b5db}.jupyter-wrapper .cm-s-seti span.cm-keyword{color:#ff79c6}.jupyter-wrapper .cm-s-seti span.cm-operator{color:#9fca56}.jupyter-wrapper .cm-s-seti span.cm-keyword{color:#e6cd69}.jupyter-wrapper .cm-s-seti span.cm-atom{color:#cd3f45}.jupyter-wrapper .cm-s-seti span.cm-meta{color:#55b5db}.jupyter-wrapper .cm-s-seti span.cm-tag{color:#55b5db}.jupyter-wrapper .cm-s-seti span.cm-attribute{color:#9fca56}.jupyter-wrapper .cm-s-seti span.cm-qualifier{color:#9fca56}.jupyter-wrapper .cm-s-seti span.cm-property{color:#a074c4}.jupyter-wrapper .cm-s-seti span.cm-variable-3,.jupyter-wrapper .cm-s-seti span.cm-type{color:#9fca56}.jupyter-wrapper .cm-s-seti span.cm-builtin{color:#9fca56}.jupyter-wrapper .cm-s-seti .CodeMirror-activeline-background{background:#101213}.jupyter-wrapper .cm-s-seti .CodeMirror-matchingbracket{text-decoration:underline;color:#fff !important}.jupyter-wrapper .solarized.base03{color:#002b36}.jupyter-wrapper .solarized.base02{color:#073642}.jupyter-wrapper .solarized.base01{color:#586e75}.jupyter-wrapper .solarized.base00{color:#657b83}.jupyter-wrapper .solarized.base0{color:#839496}.jupyter-wrapper .solarized.base1{color:#93a1a1}.jupyter-wrapper .solarized.base2{color:#eee8d5}.jupyter-wrapper .solarized.base3{color:#fdf6e3}.jupyter-wrapper .solarized.solar-yellow{color:#b58900}.jupyter-wrapper .solarized.solar-orange{color:#cb4b16}.jupyter-wrapper .solarized.solar-red{color:#dc322f}.jupyter-wrapper .solarized.solar-magenta{color:#d33682}.jupyter-wrapper .solarized.solar-violet{color:#6c71c4}.jupyter-wrapper .solarized.solar-blue{color:#268bd2}.jupyter-wrapper .solarized.solar-cyan{color:#2aa198}.jupyter-wrapper .solarized.solar-green{color:#859900}.jupyter-wrapper .cm-s-solarized{line-height:1.45em;color-profile:sRGB;rendering-intent:auto}.jupyter-wrapper .cm-s-solarized.cm-s-dark{color:#839496;background-color:#002b36;text-shadow:#002b36 0 1px}.jupyter-wrapper .cm-s-solarized.cm-s-light{background-color:#fdf6e3;color:#657b83;text-shadow:#eee8d5 0 1px}.jupyter-wrapper .cm-s-solarized .CodeMirror-widget{text-shadow:none}.jupyter-wrapper .cm-s-solarized .cm-header{color:#586e75}.jupyter-wrapper .cm-s-solarized .cm-quote{color:#93a1a1}.jupyter-wrapper .cm-s-solarized .cm-keyword{color:#cb4b16}.jupyter-wrapper .cm-s-solarized .cm-atom{color:#d33682}.jupyter-wrapper .cm-s-solarized .cm-number{color:#d33682}.jupyter-wrapper .cm-s-solarized .cm-def{color:#2aa198}.jupyter-wrapper .cm-s-solarized .cm-variable{color:#839496}.jupyter-wrapper .cm-s-solarized .cm-variable-2{color:#b58900}.jupyter-wrapper .cm-s-solarized .cm-variable-3,.jupyter-wrapper .cm-s-solarized .cm-type{color:#6c71c4}.jupyter-wrapper .cm-s-solarized .cm-property{color:#2aa198}.jupyter-wrapper .cm-s-solarized .cm-operator{color:#6c71c4}.jupyter-wrapper .cm-s-solarized .cm-comment{color:#586e75;font-style:italic}.jupyter-wrapper .cm-s-solarized .cm-string{color:#859900}.jupyter-wrapper .cm-s-solarized .cm-string-2{color:#b58900}.jupyter-wrapper .cm-s-solarized .cm-meta{color:#859900}.jupyter-wrapper .cm-s-solarized .cm-qualifier{color:#b58900}.jupyter-wrapper .cm-s-solarized .cm-builtin{color:#d33682}.jupyter-wrapper .cm-s-solarized .cm-bracket{color:#cb4b16}.jupyter-wrapper .cm-s-solarized .CodeMirror-matchingbracket{color:#859900}.jupyter-wrapper .cm-s-solarized .CodeMirror-nonmatchingbracket{color:#dc322f}.jupyter-wrapper .cm-s-solarized .cm-tag{color:#93a1a1}.jupyter-wrapper .cm-s-solarized .cm-attribute{color:#2aa198}.jupyter-wrapper .cm-s-solarized .cm-hr{color:transparent;border-top:1px solid #586e75;display:block}.jupyter-wrapper .cm-s-solarized .cm-link{color:#93a1a1;cursor:pointer}.jupyter-wrapper .cm-s-solarized .cm-special{color:#6c71c4}.jupyter-wrapper .cm-s-solarized .cm-em{color:#999;text-decoration:underline;text-decoration-style:dotted}.jupyter-wrapper .cm-s-solarized .cm-error,.jupyter-wrapper .cm-s-solarized .cm-invalidchar{color:#586e75;border-bottom:1px dotted #dc322f}.jupyter-wrapper .cm-s-solarized.cm-s-dark div.CodeMirror-selected{background:#073642}.jupyter-wrapper .cm-s-solarized.cm-s-dark.CodeMirror ::selection{background:rgba(7,54,66,.99)}.jupyter-wrapper .cm-s-solarized.cm-s-dark .CodeMirror-line::-moz-selection,.jupyter-wrapper .cm-s-dark .CodeMirror-line>span::-moz-selection,.jupyter-wrapper .cm-s-dark .CodeMirror-line>span>span::-moz-selection{background:rgba(7,54,66,.99)}.jupyter-wrapper .cm-s-solarized.cm-s-light div.CodeMirror-selected{background:#eee8d5}.jupyter-wrapper .cm-s-solarized.cm-s-light .CodeMirror-line::selection,.jupyter-wrapper .cm-s-light .CodeMirror-line>span::selection,.jupyter-wrapper .cm-s-light .CodeMirror-line>span>span::selection{background:#eee8d5}.jupyter-wrapper .cm-s-solarized.cm-s-light .CodeMirror-line::-moz-selection,.jupyter-wrapper .cm-s-ligh .CodeMirror-line>span::-moz-selection,.jupyter-wrapper .cm-s-ligh .CodeMirror-line>span>span::-moz-selection{background:#eee8d5}.jupyter-wrapper .cm-s-solarized.CodeMirror{-moz-box-shadow:inset 7px 0 12px -6px #000;-webkit-box-shadow:inset 7px 0 12px -6px #000;box-shadow:inset 7px 0 12px -6px #000}.jupyter-wrapper .cm-s-solarized .CodeMirror-gutters{border-right:0}.jupyter-wrapper .cm-s-solarized.cm-s-dark .CodeMirror-gutters{background-color:#073642}.jupyter-wrapper .cm-s-solarized.cm-s-dark .CodeMirror-linenumber{color:#586e75;text-shadow:#021014 0 -1px}.jupyter-wrapper .cm-s-solarized.cm-s-light .CodeMirror-gutters{background-color:#eee8d5}.jupyter-wrapper .cm-s-solarized.cm-s-light .CodeMirror-linenumber{color:#839496}.jupyter-wrapper .cm-s-solarized .CodeMirror-linenumber{padding:0 5px}.jupyter-wrapper .cm-s-solarized .CodeMirror-guttermarker-subtle{color:#586e75}.jupyter-wrapper .cm-s-solarized.cm-s-dark .CodeMirror-guttermarker{color:#ddd}.jupyter-wrapper .cm-s-solarized.cm-s-light .CodeMirror-guttermarker{color:#cb4b16}.jupyter-wrapper .cm-s-solarized .CodeMirror-gutter .CodeMirror-gutter-text{color:#586e75}.jupyter-wrapper .cm-s-solarized .CodeMirror-cursor{border-left:1px solid #819090}.jupyter-wrapper .cm-s-solarized.cm-s-light.cm-fat-cursor .CodeMirror-cursor{background:#7e7}.jupyter-wrapper .cm-s-solarized.cm-s-light .cm-animate-fat-cursor{background-color:#7e7}.jupyter-wrapper .cm-s-solarized.cm-s-dark.cm-fat-cursor .CodeMirror-cursor{background:#586e75}.jupyter-wrapper .cm-s-solarized.cm-s-dark .cm-animate-fat-cursor{background-color:#586e75}.jupyter-wrapper .cm-s-solarized.cm-s-dark .CodeMirror-activeline-background{background:rgba(255,255,255,.06)}.jupyter-wrapper .cm-s-solarized.cm-s-light .CodeMirror-activeline-background{background:rgba(0,0,0,.06)}.jupyter-wrapper .cm-s-the-matrix.CodeMirror{background:#000;color:lime}.jupyter-wrapper .cm-s-the-matrix div.CodeMirror-selected{background:#2d2d2d}.jupyter-wrapper .cm-s-the-matrix .CodeMirror-line::selection,.jupyter-wrapper .cm-s-the-matrix .CodeMirror-line>span::selection,.jupyter-wrapper .cm-s-the-matrix .CodeMirror-line>span>span::selection{background:rgba(45,45,45,.99)}.jupyter-wrapper .cm-s-the-matrix .CodeMirror-line::-moz-selection,.jupyter-wrapper .cm-s-the-matrix .CodeMirror-line>span::-moz-selection,.jupyter-wrapper .cm-s-the-matrix .CodeMirror-line>span>span::-moz-selection{background:rgba(45,45,45,.99)}.jupyter-wrapper .cm-s-the-matrix .CodeMirror-gutters{background:#060;border-right:2px solid lime}.jupyter-wrapper .cm-s-the-matrix .CodeMirror-guttermarker{color:lime}.jupyter-wrapper .cm-s-the-matrix .CodeMirror-guttermarker-subtle{color:#fff}.jupyter-wrapper .cm-s-the-matrix .CodeMirror-linenumber{color:#fff}.jupyter-wrapper .cm-s-the-matrix .CodeMirror-cursor{border-left:1px solid lime}.jupyter-wrapper .cm-s-the-matrix span.cm-keyword{color:#008803;font-weight:bold}.jupyter-wrapper .cm-s-the-matrix span.cm-atom{color:#3ff}.jupyter-wrapper .cm-s-the-matrix span.cm-number{color:#ffb94f}.jupyter-wrapper .cm-s-the-matrix span.cm-def{color:#99c}.jupyter-wrapper .cm-s-the-matrix span.cm-variable{color:#f6c}.jupyter-wrapper .cm-s-the-matrix span.cm-variable-2{color:#c6f}.jupyter-wrapper .cm-s-the-matrix span.cm-variable-3,.jupyter-wrapper .cm-s-the-matrix span.cm-type{color:#96f}.jupyter-wrapper .cm-s-the-matrix span.cm-property{color:#62ffa0}.jupyter-wrapper .cm-s-the-matrix span.cm-operator{color:#999}.jupyter-wrapper .cm-s-the-matrix span.cm-comment{color:#ccc}.jupyter-wrapper .cm-s-the-matrix span.cm-string{color:#39c}.jupyter-wrapper .cm-s-the-matrix span.cm-meta{color:#c9f}.jupyter-wrapper .cm-s-the-matrix span.cm-qualifier{color:#fff700}.jupyter-wrapper .cm-s-the-matrix span.cm-builtin{color:#30a}.jupyter-wrapper .cm-s-the-matrix span.cm-bracket{color:#cc7}.jupyter-wrapper .cm-s-the-matrix span.cm-tag{color:#ffbd40}.jupyter-wrapper .cm-s-the-matrix span.cm-attribute{color:#fff700}.jupyter-wrapper .cm-s-the-matrix span.cm-error{color:red}.jupyter-wrapper .cm-s-the-matrix .CodeMirror-activeline-background{background:#040}.jupyter-wrapper .cm-s-xq-light span.cm-keyword{line-height:1em;font-weight:bold;color:#5a5cad}.jupyter-wrapper .cm-s-xq-light span.cm-atom{color:#6c8cd5}.jupyter-wrapper .cm-s-xq-light span.cm-number{color:#164}.jupyter-wrapper .cm-s-xq-light span.cm-def{text-decoration:underline}.jupyter-wrapper .cm-s-xq-light span.cm-variable{color:#000}.jupyter-wrapper .cm-s-xq-light span.cm-variable-2{color:#000}.jupyter-wrapper .cm-s-xq-light span.cm-variable-3,.jupyter-wrapper .cm-s-xq-light span.cm-type{color:#000}.jupyter-wrapper .cm-s-xq-light span.cm-comment{color:#0080ff;font-style:italic}.jupyter-wrapper .cm-s-xq-light span.cm-string{color:red}.jupyter-wrapper .cm-s-xq-light span.cm-meta{color:#ff0}.jupyter-wrapper .cm-s-xq-light span.cm-qualifier{color:gray}.jupyter-wrapper .cm-s-xq-light span.cm-builtin{color:#7ea656}.jupyter-wrapper .cm-s-xq-light span.cm-bracket{color:#cc7}.jupyter-wrapper .cm-s-xq-light span.cm-tag{color:#3f7f7f}.jupyter-wrapper .cm-s-xq-light span.cm-attribute{color:#7f007f}.jupyter-wrapper .cm-s-xq-light span.cm-error{color:red}.jupyter-wrapper .cm-s-xq-light .CodeMirror-activeline-background{background:#e8f2ff}.jupyter-wrapper .cm-s-xq-light .CodeMirror-matchingbracket{outline:1px solid gray;color:#000 !important;background:#ff0}.jupyter-wrapper .CodeMirror{line-height:var(--jp-code-line-height);font-size:var(--jp-code-font-size);font-family:var(--jp-code-font-family);border:0;border-radius:0;height:auto}.jupyter-wrapper .CodeMirror pre{padding:0 var(--jp-code-padding)}.jupyter-wrapper .jp-CodeMirrorEditor[data-type=inline] .CodeMirror-dialog{background-color:var(--jp-layout-color0);color:var(--jp-content-font-color1)}.jupyter-wrapper .CodeMirror-lines{padding:var(--jp-code-padding) 0}.jupyter-wrapper .CodeMirror-linenumber{padding:0 8px}.jupyter-wrapper .jp-CodeMirrorEditor-static{margin:var(--jp-code-padding)}.jupyter-wrapper .jp-CodeMirrorEditor,.jupyter-wrapper .jp-CodeMirrorEditor-static{cursor:text}.jupyter-wrapper .jp-CodeMirrorEditor[data-type=inline] .CodeMirror-cursor{border-left:var(--jp-code-cursor-width0) solid var(--jp-editor-cursor-color)}@media screen and (min-width: 2138px)and (max-width: 4319px){.jupyter-wrapper .jp-CodeMirrorEditor[data-type=inline] .CodeMirror-cursor{border-left:var(--jp-code-cursor-width1) solid var(--jp-editor-cursor-color)}}@media screen and (min-width: 4320px){.jupyter-wrapper .jp-CodeMirrorEditor[data-type=inline] .CodeMirror-cursor{border-left:var(--jp-code-cursor-width2) solid var(--jp-editor-cursor-color)}}.jupyter-wrapper .CodeMirror.jp-mod-readOnly .CodeMirror-cursor{display:none}.jupyter-wrapper .CodeMirror-gutters{border-right:1px solid var(--jp-border-color2);background-color:var(--jp-layout-color0)}.jupyter-wrapper .jp-CollaboratorCursor{border-left:5px solid transparent;border-right:5px solid transparent;border-top:none;border-bottom:3px solid;background-clip:content-box;margin-left:-5px;margin-right:-5px}.jupyter-wrapper .CodeMirror-selectedtext.cm-searching{background-color:var(--jp-search-selected-match-background-color) !important;color:var(--jp-search-selected-match-color) !important}.jupyter-wrapper .cm-searching{background-color:var(--jp-search-unselected-match-background-color) !important;color:var(--jp-search-unselected-match-color) !important}.jupyter-wrapper .CodeMirror-focused .CodeMirror-selected{background-color:var(--jp-editor-selected-focused-background)}.jupyter-wrapper .CodeMirror-selected{background-color:var(--jp-editor-selected-background)}.jupyter-wrapper .jp-CollaboratorCursor-hover{position:absolute;z-index:1;transform:translateX(-50%);color:#fff;border-radius:3px;padding-left:4px;padding-right:4px;padding-top:1px;padding-bottom:1px;text-align:center;font-size:var(--jp-ui-font-size1);white-space:nowrap}.jupyter-wrapper .jp-CodeMirror-ruler{border-left:1px dashed var(--jp-border-color2)}.jupyter-wrapper .CodeMirror.cm-s-jupyter{background:var(--jp-layout-color0);color:var(--jp-content-font-color1)}.jupyter-wrapper .jp-CodeConsole .CodeMirror.cm-s-jupyter,.jupyter-wrapper .jp-Notebook .CodeMirror.cm-s-jupyter{background:transparent}.jupyter-wrapper .cm-s-jupyter .CodeMirror-cursor{border-left:var(--jp-code-cursor-width0) solid var(--jp-editor-cursor-color)}.jupyter-wrapper .cm-s-jupyter span.cm-keyword{color:var(--jp-mirror-editor-keyword-color);font-weight:bold}.jupyter-wrapper .cm-s-jupyter span.cm-atom{color:var(--jp-mirror-editor-atom-color)}.jupyter-wrapper .cm-s-jupyter span.cm-number{color:var(--jp-mirror-editor-number-color)}.jupyter-wrapper .cm-s-jupyter span.cm-def{color:var(--jp-mirror-editor-def-color)}.jupyter-wrapper .cm-s-jupyter span.cm-variable{color:var(--jp-mirror-editor-variable-color)}.jupyter-wrapper .cm-s-jupyter span.cm-variable-2{color:var(--jp-mirror-editor-variable-2-color)}.jupyter-wrapper .cm-s-jupyter span.cm-variable-3{color:var(--jp-mirror-editor-variable-3-color)}.jupyter-wrapper .cm-s-jupyter span.cm-punctuation{color:var(--jp-mirror-editor-punctuation-color)}.jupyter-wrapper .cm-s-jupyter span.cm-property{color:var(--jp-mirror-editor-property-color)}.jupyter-wrapper .cm-s-jupyter span.cm-operator{color:var(--jp-mirror-editor-operator-color);font-weight:bold}.jupyter-wrapper .cm-s-jupyter span.cm-comment{color:var(--jp-mirror-editor-comment-color);font-style:italic}.jupyter-wrapper .cm-s-jupyter span.cm-string{color:var(--jp-mirror-editor-string-color)}.jupyter-wrapper .cm-s-jupyter span.cm-string-2{color:var(--jp-mirror-editor-string-2-color)}.jupyter-wrapper .cm-s-jupyter span.cm-meta{color:var(--jp-mirror-editor-meta-color)}.jupyter-wrapper .cm-s-jupyter span.cm-qualifier{color:var(--jp-mirror-editor-qualifier-color)}.jupyter-wrapper .cm-s-jupyter span.cm-builtin{color:var(--jp-mirror-editor-builtin-color)}.jupyter-wrapper .cm-s-jupyter span.cm-bracket{color:var(--jp-mirror-editor-bracket-color)}.jupyter-wrapper .cm-s-jupyter span.cm-tag{color:var(--jp-mirror-editor-tag-color)}.jupyter-wrapper .cm-s-jupyter span.cm-attribute{color:var(--jp-mirror-editor-attribute-color)}.jupyter-wrapper .cm-s-jupyter span.cm-header{color:var(--jp-mirror-editor-header-color)}.jupyter-wrapper .cm-s-jupyter span.cm-quote{color:var(--jp-mirror-editor-quote-color)}.jupyter-wrapper .cm-s-jupyter span.cm-link{color:var(--jp-mirror-editor-link-color)}.jupyter-wrapper .cm-s-jupyter span.cm-error{color:var(--jp-mirror-editor-error-color)}.jupyter-wrapper .cm-s-jupyter span.cm-hr{color:#999}.jupyter-wrapper .cm-s-jupyter span.cm-tab{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAYAAAAkuj5RAAAAAXNSR0IArs4c6QAAAGFJREFUSMft1LsRQFAQheHPowAKoACx3IgEKtaEHujDjORSgWTH/ZOdnZOcM/sgk/kFFWY0qV8foQwS4MKBCS3qR6ixBJvElOobYAtivseIE120FaowJPN75GMu8j/LfMwNjh4HUpwg4LUAAAAASUVORK5CYII=);background-position:right;background-repeat:no-repeat}.jupyter-wrapper .cm-s-jupyter .CodeMirror-activeline-background,.jupyter-wrapper .cm-s-jupyter .CodeMirror-gutter{background-color:var(--jp-layout-color2)}.jupyter-wrapper .jp-RenderedLatex{color:var(--jp-content-font-color1);font-size:var(--jp-content-font-size1);line-height:var(--jp-content-line-height)}.jupyter-wrapper .jp-OutputArea-output.jp-RenderedLatex{padding:var(--jp-code-padding);text-align:left}.jupyter-wrapper .jp-MimeDocument{outline:none}.jupyter-wrapper :root{--jp-private-filebrowser-button-height: 28px;--jp-private-filebrowser-button-width: 48px}.jupyter-wrapper .jp-FileBrowser{display:flex;flex-direction:column;color:var(--jp-ui-font-color1);background:var(--jp-layout-color1);font-size:var(--jp-ui-font-size1)}.jupyter-wrapper .jp-FileBrowser-toolbar.jp-Toolbar{border-bottom:none;height:auto;margin:var(--jp-toolbar-header-margin);box-shadow:none}.jupyter-wrapper .jp-BreadCrumbs{flex:0 0 auto;margin:4px 12px}.jupyter-wrapper .jp-BreadCrumbs-item{margin:0px 2px;padding:0px 2px;border-radius:var(--jp-border-radius);cursor:pointer}.jupyter-wrapper .jp-BreadCrumbs-item:hover{background-color:var(--jp-layout-color2)}.jupyter-wrapper .jp-BreadCrumbs-item:first-child{margin-left:0px}.jupyter-wrapper .jp-BreadCrumbs-item.jp-mod-dropTarget{background-color:var(--jp-brand-color2);opacity:.7}.jupyter-wrapper .jp-FileBrowser-toolbar.jp-Toolbar{padding:0px}.jupyter-wrapper .jp-FileBrowser-toolbar.jp-Toolbar{justify-content:space-evenly}.jupyter-wrapper .jp-FileBrowser-toolbar.jp-Toolbar .jp-Toolbar-item{flex:1}.jupyter-wrapper .jp-FileBrowser-toolbar.jp-Toolbar .jp-ToolbarButtonComponent{width:100%}.jupyter-wrapper .jp-DirListing{flex:1 1 auto;display:flex;flex-direction:column;outline:0}.jupyter-wrapper .jp-DirListing-header{flex:0 0 auto;display:flex;flex-direction:row;overflow:hidden;border-top:var(--jp-border-width) solid var(--jp-border-color2);border-bottom:var(--jp-border-width) solid var(--jp-border-color1);box-shadow:var(--jp-toolbar-box-shadow);z-index:2}.jupyter-wrapper .jp-DirListing-headerItem{padding:4px 12px 2px 12px;font-weight:500}.jupyter-wrapper .jp-DirListing-headerItem:hover{background:var(--jp-layout-color2)}.jupyter-wrapper .jp-DirListing-headerItem.jp-id-name{flex:1 0 84px}.jupyter-wrapper .jp-DirListing-headerItem.jp-id-modified{flex:0 0 112px;border-left:var(--jp-border-width) solid var(--jp-border-color2);text-align:right}.jupyter-wrapper .jp-DirListing-narrow .jp-id-modified,.jupyter-wrapper .jp-DirListing-narrow .jp-DirListing-itemModified{display:none}.jupyter-wrapper .jp-DirListing-headerItem.jp-mod-selected{font-weight:600}.jupyter-wrapper .jp-DirListing-content{flex:1 1 auto;margin:0;padding:0;list-style-type:none;overflow:auto;background-color:var(--jp-layout-color1)}.jupyter-wrapper .jp-DirListing.jp-mod-native-drop .jp-DirListing-content{outline:5px dashed rgba(128,128,128,.5);outline-offset:-10px;cursor:copy}.jupyter-wrapper .jp-DirListing-item{display:flex;flex-direction:row;padding:4px 12px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.jupyter-wrapper .jp-DirListing-item.jp-mod-selected{color:#fff;background:var(--jp-brand-color1)}.jupyter-wrapper .jp-DirListing-item.jp-mod-dropTarget{background:var(--jp-brand-color3)}.jupyter-wrapper .jp-DirListing-item:hover:not(.jp-mod-selected){background:var(--jp-layout-color2)}.jupyter-wrapper .jp-DirListing-itemIcon{flex:0 0 20px;margin-right:4px}.jupyter-wrapper .jp-DirListing-itemText{flex:1 0 64px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;user-select:none}.jupyter-wrapper .jp-DirListing-itemModified{flex:0 0 125px;text-align:right}.jupyter-wrapper .jp-DirListing-editor{flex:1 0 64px;outline:none;border:none}.jupyter-wrapper .jp-DirListing-item.jp-mod-running .jp-DirListing-itemIcon:before{color:#32cd32;content:\"\u25cf\";font-size:8px;position:absolute;left:-8px}.jupyter-wrapper .jp-DirListing-item.lm-mod-drag-image,.jupyter-wrapper .jp-DirListing-item.jp-mod-selected.lm-mod-drag-image{font-size:var(--jp-ui-font-size1);padding-left:4px;margin-left:4px;width:160px;background-color:var(--jp-ui-inverse-font-color2);box-shadow:var(--jp-elevation-z2);border-radius:0px;color:var(--jp-ui-font-color1);transform:translateX(-40%) translateY(-58%)}.jupyter-wrapper .jp-DirListing-deadSpace{flex:1 1 auto;margin:0;padding:0;list-style-type:none;overflow:auto;background-color:var(--jp-layout-color1)}.jupyter-wrapper .jp-Document{min-width:120px;min-height:120px;outline:none}.jupyter-wrapper .jp-FileDialog.jp-mod-conflict input{color:red}.jupyter-wrapper .jp-FileDialog .jp-new-name-title{margin-top:12px}.jupyter-wrapper .jp-OutputArea{overflow-y:auto}.jupyter-wrapper .jp-OutputArea-child{display:flex;flex-direction:row}.jupyter-wrapper .jp-OutputPrompt{flex:0 0 var(--jp-cell-prompt-width);color:var(--jp-cell-outprompt-font-color);font-family:var(--jp-cell-prompt-font-family);padding:var(--jp-code-padding);letter-spacing:var(--jp-cell-prompt-letter-spacing);line-height:var(--jp-code-line-height);font-size:var(--jp-code-font-size);border:var(--jp-border-width) solid transparent;opacity:var(--jp-cell-prompt-opacity);text-align:right;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.jupyter-wrapper .jp-OutputArea-output{height:auto;overflow:auto;user-select:text;-moz-user-select:text;-webkit-user-select:text;-ms-user-select:text}.jupyter-wrapper .jp-OutputArea-child .jp-OutputArea-output{flex-grow:1;flex-shrink:1}.jupyter-wrapper .jp-OutputArea-output.jp-mod-isolated{width:100%;display:block}.jupyter-wrapper body.lm-mod-override-cursor .jp-OutputArea-output.jp-mod-isolated{position:relative}.jupyter-wrapper body.lm-mod-override-cursor .jp-OutputArea-output.jp-mod-isolated:before{content:\"\";position:absolute;top:0;left:0;right:0;bottom:0;background:transparent}.jupyter-wrapper .jp-OutputArea-output pre{border:none;margin:0px;padding:0px;overflow-x:auto;overflow-y:auto;word-break:break-all;word-wrap:break-word;white-space:pre-wrap}.jupyter-wrapper .jp-OutputArea-output.jp-RenderedHTMLCommon table{margin-left:0;margin-right:0}.jupyter-wrapper .jp-OutputArea-output dl,.jupyter-wrapper .jp-OutputArea-output dt,.jupyter-wrapper .jp-OutputArea-output dd{display:block}.jupyter-wrapper .jp-OutputArea-output dl{width:100%;overflow:hidden;padding:0;margin:0}.jupyter-wrapper .jp-OutputArea-output dt{font-weight:bold;float:left;width:20%;padding:0;margin:0}.jupyter-wrapper .jp-OutputArea-output dd{float:left;width:80%;padding:0;margin:0}.jupyter-wrapper .jp-OutputArea .jp-OutputArea .jp-OutputArea-prompt{display:none}.jupyter-wrapper .jp-OutputArea-output.jp-OutputArea-executeResult{margin-left:0px;flex:1 1 auto}.jupyter-wrapper .jp-OutputArea-executeResult.jp-RenderedText{padding-top:var(--jp-code-padding)}.jupyter-wrapper .jp-OutputArea-stdin{line-height:var(--jp-code-line-height);padding-top:var(--jp-code-padding);display:flex}.jupyter-wrapper .jp-Stdin-prompt{color:var(--jp-content-font-color0);padding-right:var(--jp-code-padding);vertical-align:baseline;flex:0 0 auto}.jupyter-wrapper .jp-Stdin-input{font-family:var(--jp-code-font-family);font-size:inherit;color:inherit;background-color:inherit;width:42%;min-width:200px;vertical-align:baseline;padding:0em .25em;margin:0em .25em;flex:0 0 70%}.jupyter-wrapper .jp-Stdin-input:focus{box-shadow:none}.jupyter-wrapper .jp-LinkedOutputView .jp-OutputArea{height:100%;display:block}.jupyter-wrapper .jp-LinkedOutputView .jp-OutputArea-output:only-child{height:100%}.jupyter-wrapper .jp-Collapser{flex:0 0 var(--jp-cell-collapser-width);padding:0px;margin:0px;border:none;outline:none;background:transparent;border-radius:var(--jp-border-radius);opacity:1}.jupyter-wrapper .jp-Collapser-child{display:block;width:100%;box-sizing:border-box;position:absolute;top:0px;bottom:0px}.jupyter-wrapper .jp-CellHeader,.jupyter-wrapper .jp-CellFooter{height:0px;width:100%;padding:0px;margin:0px;border:none;outline:none;background:transparent}.jupyter-wrapper .jp-InputArea{display:flex;flex-direction:row}.jupyter-wrapper .jp-InputArea-editor{flex:1 1 auto}.jupyter-wrapper .jp-InputArea-editor{border:var(--jp-border-width) solid var(--jp-cell-editor-border-color);border-radius:0px;background:var(--jp-cell-editor-background)}.jupyter-wrapper .jp-InputPrompt{flex:0 0 var(--jp-cell-prompt-width);color:var(--jp-cell-inprompt-font-color);font-family:var(--jp-cell-prompt-font-family);padding:var(--jp-code-padding);letter-spacing:var(--jp-cell-prompt-letter-spacing);opacity:var(--jp-cell-prompt-opacity);line-height:var(--jp-code-line-height);font-size:var(--jp-code-font-size);border:var(--jp-border-width) solid transparent;opacity:var(--jp-cell-prompt-opacity);text-align:right;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.jupyter-wrapper .jp-Placeholder{display:flex;flex-direction:row;flex:1 1 auto}.jupyter-wrapper .jp-Placeholder-prompt{box-sizing:border-box}.jupyter-wrapper .jp-Placeholder-content{flex:1 1 auto;border:none;background:transparent;height:20px;box-sizing:border-box}.jupyter-wrapper .jp-Placeholder-content .jp-MoreHorizIcon{width:32px;height:16px;border:1px solid transparent;border-radius:var(--jp-border-radius)}.jupyter-wrapper .jp-Placeholder-content .jp-MoreHorizIcon:hover{border:1px solid var(--jp-border-color1);box-shadow:0px 0px 2px 0px rgba(0,0,0,.25);background-color:var(--jp-layout-color0)}.jupyter-wrapper :root{--jp-private-cell-scrolling-output-offset: 5px}.jupyter-wrapper .jp-Cell{padding:var(--jp-cell-padding);margin:0px;border:none;outline:none;background:transparent}.jupyter-wrapper .jp-Cell-inputWrapper,.jupyter-wrapper .jp-Cell-outputWrapper{display:flex;flex-direction:row;padding:0px;margin:0px;overflow:visible}.jupyter-wrapper .jp-Cell-inputArea,.jupyter-wrapper .jp-Cell-outputArea{flex:1 1 auto}.jupyter-wrapper .jp-Cell.jp-mod-noOutputs .jp-Cell-outputCollapser{border:none !important;background:transparent !important}.jupyter-wrapper .jp-Cell:not(.jp-mod-noOutputs) .jp-Cell-outputCollapser{min-height:var(--jp-cell-collapser-min-height)}.jupyter-wrapper .jp-Cell:not(.jp-mod-noOutputs) .jp-Cell-outputWrapper{margin-top:5px}.jupyter-wrapper .jp-OutputArea-executeResult .jp-RenderedText.jp-OutputArea-output{padding-top:var(--jp-code-padding)}.jupyter-wrapper .jp-CodeCell.jp-mod-outputsScrolled .jp-Cell-outputArea{overflow-y:auto;max-height:200px;box-shadow:inset 0 0 6px 2px rgba(0,0,0,.3);margin-left:var(--jp-private-cell-scrolling-output-offset)}.jupyter-wrapper .jp-CodeCell.jp-mod-outputsScrolled .jp-OutputArea-prompt{flex:0 0 calc(var(--jp-cell-prompt-width) - var(--jp-private-cell-scrolling-output-offset))}.jupyter-wrapper .jp-MarkdownOutput{flex:1 1 auto;margin-top:0;margin-bottom:0;padding-left:var(--jp-code-padding)}.jupyter-wrapper .jp-MarkdownOutput.jp-RenderedHTMLCommon{overflow:auto}.jupyter-wrapper .jp-NotebookPanel-toolbar{padding:2px}.jupyter-wrapper .jp-Toolbar-item.jp-Notebook-toolbarCellType .jp-select-wrapper.jp-mod-focused{border:none;box-shadow:none}.jupyter-wrapper .jp-Notebook-toolbarCellTypeDropdown select{height:24px;font-size:var(--jp-ui-font-size1);line-height:14px;border-radius:0;display:block}.jupyter-wrapper .jp-Notebook-toolbarCellTypeDropdown span{top:5px !important}.jupyter-wrapper :root{--jp-private-notebook-dragImage-width: 304px;--jp-private-notebook-dragImage-height: 36px;--jp-private-notebook-selected-color: var(--md-blue-400);--jp-private-notebook-active-color: var(--md-green-400)}.jupyter-wrapper .jp-NotebookPanel{display:block;height:100%}.jupyter-wrapper .jp-NotebookPanel.jp-Document{min-width:240px;min-height:120px}.jupyter-wrapper .jp-Notebook{padding:var(--jp-notebook-padding);outline:none;overflow:auto;background:var(--jp-layout-color0)}.jupyter-wrapper .jp-Notebook.jp-mod-scrollPastEnd::after{display:block;content:\"\";min-height:var(--jp-notebook-scroll-padding)}.jupyter-wrapper .jp-Notebook .jp-Cell{overflow:visible}.jupyter-wrapper .jp-Notebook .jp-Cell .jp-InputPrompt{cursor:move}.jupyter-wrapper .jp-Notebook .jp-Cell:not(.jp-mod-active) .jp-InputPrompt{opacity:var(--jp-cell-prompt-not-active-opacity);color:var(--jp-cell-prompt-not-active-font-color)}.jupyter-wrapper .jp-Notebook .jp-Cell:not(.jp-mod-active) .jp-OutputPrompt{opacity:var(--jp-cell-prompt-not-active-opacity);color:var(--jp-cell-prompt-not-active-font-color)}.jupyter-wrapper .jp-Notebook .jp-Cell.jp-mod-active .jp-Collapser{background:var(--jp-brand-color1)}.jupyter-wrapper .jp-Notebook .jp-Cell .jp-Collapser:hover{box-shadow:var(--jp-elevation-z2);background:var(--jp-brand-color1);opacity:var(--jp-cell-collapser-not-active-hover-opacity)}.jupyter-wrapper .jp-Notebook .jp-Cell.jp-mod-active .jp-Collapser:hover{background:var(--jp-brand-color0);opacity:1}.jupyter-wrapper .jp-Notebook.jp-mod-commandMode .jp-Cell.jp-mod-selected{background:var(--jp-notebook-multiselected-color)}.jupyter-wrapper .jp-Notebook.jp-mod-commandMode .jp-Cell.jp-mod-active.jp-mod-selected:not(.jp-mod-multiSelected){background:transparent}.jupyter-wrapper .jp-Notebook.jp-mod-editMode .jp-Cell.jp-mod-active .jp-InputArea-editor{border:var(--jp-border-width) solid var(--jp-cell-editor-active-border-color);box-shadow:var(--jp-input-box-shadow);background-color:var(--jp-cell-editor-active-background)}.jupyter-wrapper .jp-Notebook-cell.jp-mod-dropSource{opacity:.5}.jupyter-wrapper .jp-Notebook-cell.jp-mod-dropTarget,.jupyter-wrapper .jp-Notebook.jp-mod-commandMode .jp-Notebook-cell.jp-mod-active.jp-mod-selected.jp-mod-dropTarget{border-top-color:var(--jp-private-notebook-selected-color);border-top-style:solid;border-top-width:2px}.jupyter-wrapper .jp-dragImage{display:flex;flex-direction:row;width:var(--jp-private-notebook-dragImage-width);height:var(--jp-private-notebook-dragImage-height);border:var(--jp-border-width) solid var(--jp-cell-editor-border-color);background:var(--jp-cell-editor-background);overflow:visible}.jupyter-wrapper .jp-dragImage-singlePrompt{box-shadow:2px 2px 4px 0px rgba(0,0,0,.12)}.jupyter-wrapper .jp-dragImage .jp-dragImage-content{flex:1 1 auto;z-index:2;font-size:var(--jp-code-font-size);font-family:var(--jp-code-font-family);line-height:var(--jp-code-line-height);padding:var(--jp-code-padding);border:var(--jp-border-width) solid var(--jp-cell-editor-border-color);background:var(--jp-cell-editor-background-color);color:var(--jp-content-font-color3);text-align:left;margin:4px 4px 4px 0px}.jupyter-wrapper .jp-dragImage .jp-dragImage-prompt{flex:0 0 auto;min-width:36px;color:var(--jp-cell-inprompt-font-color);padding:var(--jp-code-padding);padding-left:12px;font-family:var(--jp-cell-prompt-font-family);letter-spacing:var(--jp-cell-prompt-letter-spacing);line-height:1.9;font-size:var(--jp-code-font-size);border:var(--jp-border-width) solid transparent}.jupyter-wrapper .jp-dragImage-multipleBack{z-index:-1;position:absolute;height:32px;width:300px;top:8px;left:8px;background:var(--jp-layout-color2);border:var(--jp-border-width) solid var(--jp-input-border-color);box-shadow:2px 2px 4px 0px rgba(0,0,0,.12)}.jupyter-wrapper .jp-NotebookTools{display:block;min-width:var(--jp-sidebar-min-width);color:var(--jp-ui-font-color1);background:var(--jp-layout-color1);font-size:var(--jp-ui-font-size1);overflow:auto}.jupyter-wrapper .jp-NotebookTools-tool{padding:0px 12px 0 12px}.jupyter-wrapper .jp-ActiveCellTool{padding:12px;background-color:var(--jp-layout-color1);border-top:none !important}.jupyter-wrapper .jp-ActiveCellTool .jp-InputArea-prompt{flex:0 0 auto;padding-left:0px}.jupyter-wrapper .jp-ActiveCellTool .jp-InputArea-editor{flex:1 1 auto;background:var(--jp-cell-editor-background);border-color:var(--jp-cell-editor-border-color)}.jupyter-wrapper .jp-ActiveCellTool .jp-InputArea-editor .CodeMirror{background:transparent}.jupyter-wrapper .jp-MetadataEditorTool{flex-direction:column;padding:12px 0px 12px 0px}.jupyter-wrapper .jp-RankedPanel>:not(:first-child){margin-top:12px}.jupyter-wrapper .jp-KeySelector select.jp-mod-styled{font-size:var(--jp-ui-font-size1);color:var(--jp-ui-font-color0);border:var(--jp-border-width) solid var(--jp-border-color1)}.jupyter-wrapper .jp-KeySelector label,.jupyter-wrapper .jp-MetadataEditorTool label{line-height:1.4}.jupyter-wrapper .jp-mod-presentationMode .jp-Notebook{--jp-content-font-size1: var(--jp-content-presentation-font-size1);--jp-code-font-size: var(--jp-code-presentation-font-size)}.jupyter-wrapper .jp-mod-presentationMode .jp-Notebook .jp-Cell .jp-InputPrompt,.jupyter-wrapper .jp-mod-presentationMode .jp-Notebook .jp-Cell .jp-OutputPrompt{flex:0 0 110px}.jupyter-wrapper .md-typeset__scrollwrap{margin:0}.jupyter-wrapper .jp-MarkdownOutput{padding:0}.jupyter-wrapper h1 .anchor-link,.jupyter-wrapper h2 .anchor-link,.jupyter-wrapper h3 .anchor-link,.jupyter-wrapper h4 .anchor-link,.jupyter-wrapper h5 .anchor-link,.jupyter-wrapper h6 .anchor-link{display:none;margin-left:.5rem;color:var(--md-default-fg-color--lighter)}.jupyter-wrapper h1 .anchor-link:hover,.jupyter-wrapper h2 .anchor-link:hover,.jupyter-wrapper h3 .anchor-link:hover,.jupyter-wrapper h4 .anchor-link:hover,.jupyter-wrapper h5 .anchor-link:hover,.jupyter-wrapper h6 .anchor-link:hover{text-decoration:none;color:var(--md-accent-fg-color)}.jupyter-wrapper h1:hover .anchor-link,.jupyter-wrapper h2:hover .anchor-link,.jupyter-wrapper h3:hover .anchor-link,.jupyter-wrapper h4:hover .anchor-link,.jupyter-wrapper h5:hover .anchor-link,.jupyter-wrapper h6:hover .anchor-link{display:inline-block}.jupyter-wrapper .jp-Cell-inputWrapper .jp-InputPrompt{display:none}.jupyter-wrapper .jp-CodeCell .jp-Cell-inputWrapper .jp-InputPrompt{display:block}.jupyter-wrapper .highlight pre{overflow:auto}.jupyter-wrapper .celltoolbar{border:none;background:#eee;border-radius:2px 2px 0px 0px;width:100%;height:29px;padding-right:4px;box-orient:horizontal;box-align:stretch;display:flex;flex-direction:row;align-items:stretch;box-pack:end;justify-content:flex-start;display:-webkit-flex}.jupyter-wrapper .celltoolbar .tags_button_container{display:flex}.jupyter-wrapper .celltoolbar .tags_button_container .tag-container{display:flex;flex-direction:row;flex-grow:1;overflow:hidden;position:relative}.jupyter-wrapper .celltoolbar .tags_button_container .tag-container .cell-tag{background-color:#fff;white-space:nowrap;margin:3px 4px;padding:0 4px;border-radius:1px;border:1px solid #ccc;box-shadow:none;width:inherit;font-size:11px;font-family:\"Roboto Mono\",SFMono-Regular,Consolas,Menlo,monospace;height:22px;display:inline-block}.jupyter-wrapper .jp-InputArea-editor{width:1px}.jupyter-wrapper .jp-InputPrompt{overflow:unset}.jupyter-wrapper .jp-OutputPrompt{overflow:unset}.jupyter-wrapper .jp-RenderedText{font-size:var(--jp-code-font-size)}.jupyter-wrapper .highlight-ipynb{overflow:auto}.jupyter-wrapper .highlight-ipynb pre{margin:0;padding:5px 10px}.jupyter-wrapper table.dataframe{margin-left:auto;margin-right:auto;border:none;border-collapse:collapse;border-spacing:0;color:#000;font-size:12px;table-layout:fixed}.jupyter-wrapper table.dataframe thead{border-bottom:1px solid #000;vertical-align:bottom}.jupyter-wrapper table.dataframe tr,.jupyter-wrapper table.dataframe th,.jupyter-wrapper table.dataframe td{text-align:right;vertical-align:middle;padding:.5em .5em;line-height:normal;white-space:normal;max-width:none;border:none}.jupyter-wrapper table.dataframe th{font-weight:bold}.jupyter-wrapper table.dataframe tbody tr:nth-child(odd){background:#f5f5f5}.jupyter-wrapper table.dataframe tbody tr:hover{background:rgba(66,165,245,.2)}.jupyter-wrapper *+table{margin-top:1em}.jupyter-wrapper .jp-InputArea-editor{position:relative}.jupyter-wrapper .zeroclipboard-container{position:absolute;top:-3px;right:0;z-index:1000}.jupyter-wrapper .zeroclipboard-container clipboard-copy{-webkit-appearance:button;-moz-appearance:button;padding:7px 5px;font:11px system-ui,sans-serif;display:inline-block;cursor:default}.jupyter-wrapper .zeroclipboard-container .clipboard-copy-icon{padding:4px 4px 2px;color:#57606a;vertical-align:text-bottom}.jupyter-wrapper .clipboard-copy-txt{display:none}[data-md-color-scheme=slate] .clipboard-copy-icon{color:#fff !important}[data-md-color-scheme=slate] table.dataframe{color:#e9ebfc}[data-md-color-scheme=slate] table.dataframe thead{border-bottom:1px solid rgba(233,235,252,.12)}[data-md-color-scheme=slate] table.dataframe tbody tr:nth-child(odd){background:#222}[data-md-color-scheme=slate] table.dataframe tbody tr:hover{background:rgba(66,165,245,.2)} /*# sourceMappingURL=mkdocs-jupyter.css.map*/ init_mathjax = function() { if (window.MathJax) { // MathJax loaded MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: \"AMS\", useLabelIds: true } }, tex2jax: { inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ], displayMath: [ ['$$','$$'], [\"\\\\[\",\"\\\\]\"] ], processEscapes: true, processEnvironments: true }, displayAlign: 'center', CommonHTML: { linebreaks: { automatic: true } } }); MathJax.Hub.Queue([\"Typeset\", MathJax.Hub]); } } init_mathjax(); Nominal2OrdinalEncoder Example \u00b6 Synthetic data sets will be used to demonstrate the usage of the Nominal2OrdinalEncoder class. While scikit-learn provides utility functions such as make_regression and make_classification , neither of these support the inclusion of nominal/categorical predictor variables. As a result, a synthetic data-generating function demonstrated at The UnivariateScreener class from this package will also be used to demonstrate the use of information-based measures on both the orginal numeric predictor variables as well as the Nominal2Ordinal encoded features. In [1]: Copied! % load_ext autoreload % autoreload 2 %load_ext autoreload %autoreload 2 Classification Example \u00b6 Generate synthetic dataset \u00b6 In [2]: Copied! from sklearn.datasets import make_classification import pandas as pd n_obs = 10000 n_features = 100 X , y = make_classification ( n_samples = n_obs , n_features = n_features , n_informative = 10 , n_redundant = 0 , n_classes = 2 , flip_y = 0.2 , random_state = 42 ) X = pd . DataFrame ( X , columns = [ f 'x { i } ' for i in range ( n_features )]) y = pd . Series ( y , name = 'target' ) from sklearn.datasets import make_classification import pandas as pd n_obs = 10000 n_features = 100 X, y = make_classification( n_samples=n_obs, n_features=n_features, n_informative=10, n_redundant=0, n_classes=2, flip_y=0.2, random_state=42) X = pd.DataFrame(X, columns=[f'x{i}' for i in range(n_features)]) y = pd.Series(y, name='target') Examine univariate relationship with target \u00b6 In [4]: Copied! from narrowgate.screeners import UnivariateScreener from narrowgate.screeners import UnivariateScreener In [5]: Copied! uni_screen = \\ UnivariateScreener ( nbins_predictors = 5 , nbins_target = 5 , information_criterion = 'mutual_information' , mcpt_reps = 100 , cscv_subsets = 6 ) uni_screen . screen ( X , y ) uni_screen = \\ UnivariateScreener( nbins_predictors=5, nbins_target=5, information_criterion='mutual_information', mcpt_reps=100, cscv_subsets=6) uni_screen.screen(X, y) PROCESSING 100 variables ... TOTAL COLUMNS PROCESSED: 100 - Processing time: 3.987596 s Begin MCPT reps ... 0%| | 0/100 [00:00<?, ?it/s] Begin CSCV reps ... 0%| | 0/20 [00:00<?, ?it/s] Out[5]: <narrowgate.screeners.univariate.base.UnivariateScreener at 0x7f762e980790> In [6]: Copied! uni_screen . results . head ( 15 ) uni_screen.results.head(15) UNIVARIATE SCREENER RESULTS --------------------------- Number of observations: 10000 Number of predictors: 100 Target variable name: target Number of MCPT reps: 100 Number of CSCV subsets: 6 Number of bins (predictors): 5 Number of bins (target): 5 MCPT permutation method: complete Information Criterion: Mutual Information Out[6]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Variable mutual_information Solo p-value Unbiased p-value P(<=median) 0 x91 0.0873 0.01 0.01 0.00 1 x13 0.0421 0.01 0.01 0.00 2 x95 0.0243 0.01 0.01 0.00 3 x54 0.0190 0.01 0.01 0.00 4 x57 0.0183 0.01 0.01 0.00 5 x48 0.0172 0.01 0.01 0.00 6 x87 0.0149 0.01 0.01 0.00 7 x71 0.0009 0.01 0.18 0.05 8 x96 0.0007 0.01 0.52 0.05 9 x11 0.0006 0.08 0.87 0.25 10 x41 0.0006 0.03 0.93 0.00 11 x33 0.0005 0.04 0.96 0.10 12 x55 0.0005 0.04 0.97 0.05 13 x82 0.0005 0.08 0.98 0.15 14 x24 0.0005 0.05 0.98 0.20 The above univariate screening results indicate that there indeed appears to be 10 variables within the synthetic data set with a non-random relationship with the binary target variable. These 'signal' variables are the first 10 listed in the results DataFrame printed above. In order to test out the Nominal2Ordinal encoding capability, the second variable in the results list will be discretized to create a categorical variable which should also possess a non-random relationship with the target variable. After the variable is discretized, Nominal2Ordinal encoding will be performed on the categorical variable in the modified data set and the modified data set will be screened again. Discretize 2nd most informative variable \u00b6 In [21]: Copied! var_to_discretize = uni_screen . results . Variable [ 1 ] new_var = f ' { var_to_discretize } _binned' X [ new_var ] = pd . cut ( X [ var_to_discretize ], bins = 8 ) var_to_discretize = uni_screen.results.Variable[1] new_var = f'{var_to_discretize}_binned' X[new_var] = pd.cut(X[var_to_discretize], bins=8) UNIVARIATE SCREENER RESULTS --------------------------- Number of observations: 10000 Number of predictors: 100 Target variable name: target Number of MCPT reps: 100 Number of CSCV subsets: 6 Number of bins (predictors): 5 Number of bins (target): 5 MCPT permutation method: complete Information Criterion: Mutual Information Perform Nominal2Ordinal encoding \u00b6 In [20]: Copied! X . columns X.columns Out[20]: Index(['x0', 'x1', 'x2', 'x3', 'x4', 'x5', 'x6', 'x7', 'x8', 'x9', ... 'x91', 'x92', 'x93', 'x94', 'x95', 'x96', 'x97', 'x98', 'x99', 'x13_binned'], dtype='object', length=101) In [ ]: Copied!","title":"Example"},{"location":"notebooks/nominal2ordinal/#nominal2ordinalencoder-example","text":"Synthetic data sets will be used to demonstrate the usage of the Nominal2OrdinalEncoder class. While scikit-learn provides utility functions such as make_regression and make_classification , neither of these support the inclusion of nominal/categorical predictor variables. As a result, a synthetic data-generating function demonstrated at The UnivariateScreener class from this package will also be used to demonstrate the use of information-based measures on both the orginal numeric predictor variables as well as the Nominal2Ordinal encoded features. In [1]: Copied! % load_ext autoreload % autoreload 2 %load_ext autoreload %autoreload 2","title":"Nominal2OrdinalEncoder Example"},{"location":"notebooks/nominal2ordinal/#classification-example","text":"","title":"Classification Example"},{"location":"notebooks/nominal2ordinal/#generate-synthetic-dataset","text":"In [2]: Copied! from sklearn.datasets import make_classification import pandas as pd n_obs = 10000 n_features = 100 X , y = make_classification ( n_samples = n_obs , n_features = n_features , n_informative = 10 , n_redundant = 0 , n_classes = 2 , flip_y = 0.2 , random_state = 42 ) X = pd . DataFrame ( X , columns = [ f 'x { i } ' for i in range ( n_features )]) y = pd . Series ( y , name = 'target' ) from sklearn.datasets import make_classification import pandas as pd n_obs = 10000 n_features = 100 X, y = make_classification( n_samples=n_obs, n_features=n_features, n_informative=10, n_redundant=0, n_classes=2, flip_y=0.2, random_state=42) X = pd.DataFrame(X, columns=[f'x{i}' for i in range(n_features)]) y = pd.Series(y, name='target')","title":"Generate synthetic dataset"},{"location":"notebooks/nominal2ordinal/#examine-univariate-relationship-with-target","text":"In [4]: Copied! from narrowgate.screeners import UnivariateScreener from narrowgate.screeners import UnivariateScreener In [5]: Copied! uni_screen = \\ UnivariateScreener ( nbins_predictors = 5 , nbins_target = 5 , information_criterion = 'mutual_information' , mcpt_reps = 100 , cscv_subsets = 6 ) uni_screen . screen ( X , y ) uni_screen = \\ UnivariateScreener( nbins_predictors=5, nbins_target=5, information_criterion='mutual_information', mcpt_reps=100, cscv_subsets=6) uni_screen.screen(X, y) PROCESSING 100 variables ... TOTAL COLUMNS PROCESSED: 100 - Processing time: 3.987596 s Begin MCPT reps ... 0%| | 0/100 [00:00<?, ?it/s] Begin CSCV reps ... 0%| | 0/20 [00:00<?, ?it/s] Out[5]: <narrowgate.screeners.univariate.base.UnivariateScreener at 0x7f762e980790> In [6]: Copied! uni_screen . results . head ( 15 ) uni_screen.results.head(15) UNIVARIATE SCREENER RESULTS --------------------------- Number of observations: 10000 Number of predictors: 100 Target variable name: target Number of MCPT reps: 100 Number of CSCV subsets: 6 Number of bins (predictors): 5 Number of bins (target): 5 MCPT permutation method: complete Information Criterion: Mutual Information Out[6]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Variable mutual_information Solo p-value Unbiased p-value P(<=median) 0 x91 0.0873 0.01 0.01 0.00 1 x13 0.0421 0.01 0.01 0.00 2 x95 0.0243 0.01 0.01 0.00 3 x54 0.0190 0.01 0.01 0.00 4 x57 0.0183 0.01 0.01 0.00 5 x48 0.0172 0.01 0.01 0.00 6 x87 0.0149 0.01 0.01 0.00 7 x71 0.0009 0.01 0.18 0.05 8 x96 0.0007 0.01 0.52 0.05 9 x11 0.0006 0.08 0.87 0.25 10 x41 0.0006 0.03 0.93 0.00 11 x33 0.0005 0.04 0.96 0.10 12 x55 0.0005 0.04 0.97 0.05 13 x82 0.0005 0.08 0.98 0.15 14 x24 0.0005 0.05 0.98 0.20 The above univariate screening results indicate that there indeed appears to be 10 variables within the synthetic data set with a non-random relationship with the binary target variable. These 'signal' variables are the first 10 listed in the results DataFrame printed above. In order to test out the Nominal2Ordinal encoding capability, the second variable in the results list will be discretized to create a categorical variable which should also possess a non-random relationship with the target variable. After the variable is discretized, Nominal2Ordinal encoding will be performed on the categorical variable in the modified data set and the modified data set will be screened again.","title":"Examine univariate relationship with target"},{"location":"notebooks/nominal2ordinal/#discretize-2nd-most-informative-variable","text":"In [21]: Copied! var_to_discretize = uni_screen . results . Variable [ 1 ] new_var = f ' { var_to_discretize } _binned' X [ new_var ] = pd . cut ( X [ var_to_discretize ], bins = 8 ) var_to_discretize = uni_screen.results.Variable[1] new_var = f'{var_to_discretize}_binned' X[new_var] = pd.cut(X[var_to_discretize], bins=8) UNIVARIATE SCREENER RESULTS --------------------------- Number of observations: 10000 Number of predictors: 100 Target variable name: target Number of MCPT reps: 100 Number of CSCV subsets: 6 Number of bins (predictors): 5 Number of bins (target): 5 MCPT permutation method: complete Information Criterion: Mutual Information","title":"Discretize 2nd most informative variable"},{"location":"notebooks/nominal2ordinal/#perform-nominal2ordinal-encoding","text":"In [20]: Copied! X . columns X.columns Out[20]: Index(['x0', 'x1', 'x2', 'x3', 'x4', 'x5', 'x6', 'x7', 'x8', 'x9', ... 'x91', 'x92', 'x93', 'x94', 'x95', 'x96', 'x97', 'x98', 'x99', 'x13_binned'], dtype='object', length=101) In [ ]: Copied!","title":"Perform Nominal2Ordinal encoding"},{"location":"screeners/bivariate/","text":"BivariateScreener \u00a4 BivariateScreener ( nbins_predictors = 3 , nbins_target = 3 , mcpt_type = \"complete\" , mcpt_reps = 100 , information_criterion = \"mutual_information\" , ) Feature screening class for evaluating interactive relationships between two predictor variables and a target variable. Univariate relationships can be evaluated with the UnivariateScreener class. Unlike the UnivariateScreener, only information-based measures are available for use as evaluation criteria with this class. This requires discretization (binning) of the predictor and target variables. The following information measures are available: Mutual Information Uncertainty Reduction Target Variable Types \u00a4 BivariateScreener functionality works best with binary and continuous target variables. While it can be used in a multi-class classification setting, special care will have to be taken by the practitioner by setting the nbins_target parameter to the number of classes present in the target variable at the time of class instantiation. Categorical Predictor Variables \u00a4 Similar to UnivariateScreener, it is highly recommended that any categorical predictor variables be transformed into continuous variables via TargetEncoding or Nominal2Ordinal encoding prior to performing screening. This is especially true for those predictor variables with high cardinality as setting the nbins_predictors parameter to a large number will partition all continous variables into the given large number of bins. Doing so will require an increase use of memory and computing resources and is discouraged. References \u00a4 Masters, Timothy. (2016) \"Data Mining Algorithms in C++\". pp. 91-139. Parameters: Name Type Description Default nbins_target int number of bins into which the target variable will be partitioned. Must be an integer value greater than 1. If the target variable is unable to be partitioned into the desired number of bins due to fewer unique values being present within the target variable, then the number of bins will automatically be adjusted downwards to support the maximum number of possible bins. 3 nbins_predictors int number of bins into which the predictor variables will be partitioned. Must be an integer value greater than 1. If any of the predictor variables are unable to be partitioned into the desired number of bins due to fewer unique values being present, then the number of bins will automatically be adjusted downwards to support the maximum number of possible bins for that variable only. All other predictor variables will be partitioned into the requested number of bins. 3 mcpt_type str Valid options: \"complete\" \"cyclic\" Type of permutation to perform on the target variable when evaluating the confidence that a predictor variable's relationship with the target variable is non-random in nature. \"complete\" : shuffles the target variable values \"cyclic\" : used when target variable possesses serial correlation. Chooses a random row and copies the original target variable values in sequence beginning at this row. Excess target values are then 'wrapped' to first row in the dataset such that the last original target variable value will be located in the position just prior to the chosen random row. \"complete\" mcpt_reps int Number of target variable permutations to perform. For best results, this number should exceed the number of predictor variables in the data set. 100 information_criterion str Valid options: \"mutual_information\" \"uncertainty_reduction\" The information-based measure used in evaluating a non-random relationship between a predictor variable and the target variable. 'mutual_information' Source code in narrowgate/screeners/bivariate/base.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def __init__ ( self , nbins_predictors : int = 3 , nbins_target : int = 3 , mcpt_type : str = \"complete\" , mcpt_reps : int = 100 , information_criterion : str = \"mutual_information\" ): \"\"\" Parameters ---------- nbins_target : number of bins into which the target variable will be partitioned. Must be an integer value greater than 1. If the target variable is unable to be partitioned into the desired number of bins due to fewer unique values being present within the target variable, then the number of bins will automatically be adjusted downwards to support the maximum number of possible bins. nbins_predictors : number of bins into which the predictor variables will be partitioned. Must be an integer value greater than 1. If any of the predictor variables are unable to be partitioned into the desired number of bins due to fewer unique values being present, then the number of bins will automatically be adjusted downwards to support the maximum number of possible bins for that variable only. All other predictor variables will be partitioned into the requested number of bins. mcpt_type : {\"complete\", \"cyclic\"} Valid options: - **\"complete\"** - **\"cyclic\"** Type of permutation to perform on the target variable when evaluating the confidence that a predictor variable's relationship with the target variable is non-random in nature. **\"complete\"**: shuffles the target variable values **\"cyclic\"**: used when target variable possesses serial correlation. Chooses a random row and copies the original target variable values in sequence beginning at this row. Excess target values are then 'wrapped' to first row in the dataset such that the last original target variable value will be located in the position just prior to the chosen random row. mcpt_reps : Number of target variable permutations to perform. For best results, this number should exceed the number of predictor variables in the data set. information_criterion : Valid options: - **\"mutual_information\"** - **\"uncertainty_reduction\"** The information-based measure used in evaluating a non-random relationship between a predictor variable and the target variable. \"\"\" assert isinstance ( nbins_predictors , int ) assert nbins_predictors > 1 assert isinstance ( nbins_target , int ) assert nbins_target > 1 info_crits = \\ [ 'mutual_information' , 'uncertainty_reduction' ] assert information_criterion in info_crits if isinstance ( mcpt_reps , int ): assert mcpt_type in [ \"complete\" , \"cyclic\" ] if mcpt_reps < 1 : mcpt_reps = 0 else : raise TypeError ( \"'mcpt_reps' parameter must be a non-negative integer!\" ) self . nbins_target = nbins_target self . nbins_predictors = nbins_predictors self . mcpt_type = mcpt_type self . mcpt_reps = mcpt_reps self . information_criterion = information_criterion self . crits_ = None self . solo_pval_ = None self . unbiased_pval_ = None self . p_median_pval_ = None return None screen \u00a4 screen ( X , y , target = None ) Executes univariate screening. Prior to execution validates and transforms X and y inputs. Parameters: Name Type Description Default X Union [ pd . DataFrame , np . ndarray ] predictor variable dataset pandas DataFrame or numpy multi-dimensional array representing the values of the predictor variables to be screened in relation to the target variable, y . required y Union [ pd . Series , np . array ] target variable series pandas Series or numpy 1-D array representing the values of the target variable. Values must be numerical ( int or float ) and cannot be of type object . required target Optional [ str ] Valid options: None \"cpu\" \"gpu\" Indicates the device where the screening calculations should take place. Although faster, \"gpu\" functionality is brittle and should be considered experimental at this time. None Source code in narrowgate/screeners/bivariate/base.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def screen ( self , X : Union [ pd . DataFrame , np . ndarray ], y : Union [ pd . Series , np . array ], target : Optional [ str ] = None ): \"\"\" Executes univariate screening. Prior to execution validates and transforms `X` and `y` inputs. Parameters ---------- X : predictor variable dataset pandas DataFrame or numpy multi-dimensional array representing the values of the predictor variables to be screened in relation to the target variable, `y`. y : target variable series pandas Series or numpy 1-D array representing the values of the target variable. Values must be numerical (`int` or `float`) and cannot be of type `object`. target : Valid options: * **None** * **\"cpu\"** * **\"gpu\"** Indicates the device where the screening calculations should take place. Although faster, \"gpu\" functionality is brittle and should be considered experimental at this time. \"\"\" if target is None : target = 'cpu' else : assert target in [ 'cpu' , 'gpu' ] # Validate objects being passed in if isinstance ( X , pd . DataFrame ): X_raw , y_raw , X_cols , self . target_name = \\ validate_pandas_inputs ( X , y ) self . predictor_columns = X_raw . columns . tolist () self . n_obs = X_raw . shape [ 0 ] elif isinstance ( X , np . ndarray ): import math X_raw , y_raw , X_cols , self . target_name = validate_numpy_inputs ( X , y ) nvars = X_raw . shape [ 1 ] npad = int ( math . floor ( math . log10 ( abs ( nvars )))) + 1 self . predictor_columns = \\ [ 'var' + f ' { i } ' . zfill ( npad ) for i in range ( nvars )] self . n_obs = X_raw . shape [ 0 ] else : raise TypeError ( f \"Unsupported type for 'X': { type ( X ) } \" ) ############################################################ ## Convert information_measure to shorthand for functions ## ############################################################ if self . information_criterion == 'mutual_information' : info_name = 'mi' else : # information_criterion == 'uncertainty_reduction' info_name = 'ur' ####################################################### # TO-DO: Validate data # Convert any NaN values or categorical variables? # or just fail? ####################################################### if target == 'cpu' : from ._cpu import prepare_data from ._cpu import mcpt_bivariate_screen X_dict = \\ prepare_data ( X_raw , nbins = self . nbins_predictors , verbose = True ) # preserve the column pairs for use when reporting results self . column_pairs = X_dict [ 'col_pairs' ] . copy () self . crits_ , self . solo_pval_ , self . unbiased_pval_ = \\ mcpt_bivariate_screen ( X_dict , y_raw , y_nbins = self . nbins_target , information_measure = info_name , mcpt_nreps = self . mcpt_reps , mcpt_type = self . mcpt_type ) results \u00a4 results () A pandas DataFrame representing the calculated results produced from running screen . Consolidates the following instance attributes into a more digestable and comparable format: crits solo_pval unbiased_pval p_median_pval (if cscv_subsets > 0) Source code in narrowgate/screeners/bivariate/base.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 @property def results ( self ): \"\"\" A pandas DataFrame representing the calculated results produced from running `screen`. Consolidates the following instance attributes into a more digestable and comparable format: * `crits` * `solo_pval` * `unbiased_pval` * `p_median_pval` (if `cscv_subsets` > 0) \"\"\" if not self . crits_ is None : print ( \"BIVARIATE SCREENER RESULTS\" ) print ( \"---------------------------\" ) print ( f \"Number of observations: { self . n_obs } \" ) print ( f \"Number of predictors: { len ( self . predictor_columns ) } \" ) print ( f \"Target variable name: { self . target_name } \" ) print ( f \"Number of MCPT reps: { self . mcpt_reps } \" ) print ( f \"Number of bins (predictors): { self . nbins_predictors } \" ) print ( f \"Number of bins (target): { self . nbins_target } \" ) print ( f \"MCPT permutation method: { self . mcpt_type } \" ) if self . information_criterion == 'mutual_information' : info_crit_str = 'Mutual Information' elif self . information_criterion == 'uncertainty_reduction' : info_crit_str = 'Uncertainty Reduction' print ( f \"Information Criterion: { info_crit_str } \" ) var_series_1 = \\ pd . Series ( [ self . predictor_columns [ i ] for i in self . column_pairs [:, 0 ]], name = 'Variable 1' ) var_series_2 = \\ pd . Series ( [ self . predictor_columns [ i ] for i in self . column_pairs [:, 1 ]], name = 'Variable 2' ) col_names = [ info_crit_str , 'Solo p-value' , 'Unbiased p-value' ] results_mat = \\ np . hstack (( self . crits_ . reshape ( - 1 , 1 ), self . solo_pval_ . reshape ( - 1 , 1 ), self . unbiased_pval_ . reshape ( - 1 , 1 ))) results_df = \\ pd . DataFrame ( results_mat , columns = col_names ) results_df . insert ( 0 , 'Variable 2' , var_series_2 ) results_df . insert ( 0 , 'Variable 1' , var_series_1 ) results_df = \\ results_df . sort_values ( by = info_crit_str , ascending = False ) results_df . reset_index ( drop = True , inplace = True ) else : print ( \"No screening results available!\" ) results_df = None return results_df crits \u00a4 crits () Pandas DataFrame of information measures representing the interactive relationship of sets of two predictor variables with a target variable. Source code in narrowgate/screeners/bivariate/base.py 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 @property def crits ( self ): \"\"\" Pandas DataFrame of information measures representing the interactive relationship of sets of two predictor variables with a target variable. \"\"\" if self . crits_ is not None : var_series_1 = \\ pd . Series ( [ self . predictor_columns [ i ] for i in self . column_pairs [:, 0 ]], name = 'Variable 1' ) var_series_2 = \\ pd . Series ( [ self . predictor_columns [ i ] for i in self . column_pairs [:, 1 ]], name = 'Variable 2' ) crits_series = \\ pd . Series ( self . crits_ , name = self . information_criterion ) crits_df = \\ pd . concat ([ var_series_1 , var_series_2 , crits_series ], axis = 1 ) else : print ( \"No screening results available!\" ) crits_df = None return crits_df","title":"BivariateScreener"},{"location":"screeners/bivariate/#narrowgate.screeners.BivariateScreener","text":"BivariateScreener ( nbins_predictors = 3 , nbins_target = 3 , mcpt_type = \"complete\" , mcpt_reps = 100 , information_criterion = \"mutual_information\" , ) Feature screening class for evaluating interactive relationships between two predictor variables and a target variable. Univariate relationships can be evaluated with the UnivariateScreener class. Unlike the UnivariateScreener, only information-based measures are available for use as evaluation criteria with this class. This requires discretization (binning) of the predictor and target variables. The following information measures are available: Mutual Information Uncertainty Reduction","title":"BivariateScreener"},{"location":"screeners/bivariate/#narrowgate.screeners.BivariateScreener--target-variable-types","text":"BivariateScreener functionality works best with binary and continuous target variables. While it can be used in a multi-class classification setting, special care will have to be taken by the practitioner by setting the nbins_target parameter to the number of classes present in the target variable at the time of class instantiation.","title":"Target Variable Types"},{"location":"screeners/bivariate/#narrowgate.screeners.BivariateScreener--categorical-predictor-variables","text":"Similar to UnivariateScreener, it is highly recommended that any categorical predictor variables be transformed into continuous variables via TargetEncoding or Nominal2Ordinal encoding prior to performing screening. This is especially true for those predictor variables with high cardinality as setting the nbins_predictors parameter to a large number will partition all continous variables into the given large number of bins. Doing so will require an increase use of memory and computing resources and is discouraged.","title":"Categorical Predictor Variables"},{"location":"screeners/bivariate/#narrowgate.screeners.BivariateScreener--references","text":"Masters, Timothy. (2016) \"Data Mining Algorithms in C++\". pp. 91-139. Parameters: Name Type Description Default nbins_target int number of bins into which the target variable will be partitioned. Must be an integer value greater than 1. If the target variable is unable to be partitioned into the desired number of bins due to fewer unique values being present within the target variable, then the number of bins will automatically be adjusted downwards to support the maximum number of possible bins. 3 nbins_predictors int number of bins into which the predictor variables will be partitioned. Must be an integer value greater than 1. If any of the predictor variables are unable to be partitioned into the desired number of bins due to fewer unique values being present, then the number of bins will automatically be adjusted downwards to support the maximum number of possible bins for that variable only. All other predictor variables will be partitioned into the requested number of bins. 3 mcpt_type str Valid options: \"complete\" \"cyclic\" Type of permutation to perform on the target variable when evaluating the confidence that a predictor variable's relationship with the target variable is non-random in nature. \"complete\" : shuffles the target variable values \"cyclic\" : used when target variable possesses serial correlation. Chooses a random row and copies the original target variable values in sequence beginning at this row. Excess target values are then 'wrapped' to first row in the dataset such that the last original target variable value will be located in the position just prior to the chosen random row. \"complete\" mcpt_reps int Number of target variable permutations to perform. For best results, this number should exceed the number of predictor variables in the data set. 100 information_criterion str Valid options: \"mutual_information\" \"uncertainty_reduction\" The information-based measure used in evaluating a non-random relationship between a predictor variable and the target variable. 'mutual_information' Source code in narrowgate/screeners/bivariate/base.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def __init__ ( self , nbins_predictors : int = 3 , nbins_target : int = 3 , mcpt_type : str = \"complete\" , mcpt_reps : int = 100 , information_criterion : str = \"mutual_information\" ): \"\"\" Parameters ---------- nbins_target : number of bins into which the target variable will be partitioned. Must be an integer value greater than 1. If the target variable is unable to be partitioned into the desired number of bins due to fewer unique values being present within the target variable, then the number of bins will automatically be adjusted downwards to support the maximum number of possible bins. nbins_predictors : number of bins into which the predictor variables will be partitioned. Must be an integer value greater than 1. If any of the predictor variables are unable to be partitioned into the desired number of bins due to fewer unique values being present, then the number of bins will automatically be adjusted downwards to support the maximum number of possible bins for that variable only. All other predictor variables will be partitioned into the requested number of bins. mcpt_type : {\"complete\", \"cyclic\"} Valid options: - **\"complete\"** - **\"cyclic\"** Type of permutation to perform on the target variable when evaluating the confidence that a predictor variable's relationship with the target variable is non-random in nature. **\"complete\"**: shuffles the target variable values **\"cyclic\"**: used when target variable possesses serial correlation. Chooses a random row and copies the original target variable values in sequence beginning at this row. Excess target values are then 'wrapped' to first row in the dataset such that the last original target variable value will be located in the position just prior to the chosen random row. mcpt_reps : Number of target variable permutations to perform. For best results, this number should exceed the number of predictor variables in the data set. information_criterion : Valid options: - **\"mutual_information\"** - **\"uncertainty_reduction\"** The information-based measure used in evaluating a non-random relationship between a predictor variable and the target variable. \"\"\" assert isinstance ( nbins_predictors , int ) assert nbins_predictors > 1 assert isinstance ( nbins_target , int ) assert nbins_target > 1 info_crits = \\ [ 'mutual_information' , 'uncertainty_reduction' ] assert information_criterion in info_crits if isinstance ( mcpt_reps , int ): assert mcpt_type in [ \"complete\" , \"cyclic\" ] if mcpt_reps < 1 : mcpt_reps = 0 else : raise TypeError ( \"'mcpt_reps' parameter must be a non-negative integer!\" ) self . nbins_target = nbins_target self . nbins_predictors = nbins_predictors self . mcpt_type = mcpt_type self . mcpt_reps = mcpt_reps self . information_criterion = information_criterion self . crits_ = None self . solo_pval_ = None self . unbiased_pval_ = None self . p_median_pval_ = None return None","title":"References"},{"location":"screeners/bivariate/#narrowgate.screeners.bivariate.base.BivariateScreener.screen","text":"screen ( X , y , target = None ) Executes univariate screening. Prior to execution validates and transforms X and y inputs. Parameters: Name Type Description Default X Union [ pd . DataFrame , np . ndarray ] predictor variable dataset pandas DataFrame or numpy multi-dimensional array representing the values of the predictor variables to be screened in relation to the target variable, y . required y Union [ pd . Series , np . array ] target variable series pandas Series or numpy 1-D array representing the values of the target variable. Values must be numerical ( int or float ) and cannot be of type object . required target Optional [ str ] Valid options: None \"cpu\" \"gpu\" Indicates the device where the screening calculations should take place. Although faster, \"gpu\" functionality is brittle and should be considered experimental at this time. None Source code in narrowgate/screeners/bivariate/base.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def screen ( self , X : Union [ pd . DataFrame , np . ndarray ], y : Union [ pd . Series , np . array ], target : Optional [ str ] = None ): \"\"\" Executes univariate screening. Prior to execution validates and transforms `X` and `y` inputs. Parameters ---------- X : predictor variable dataset pandas DataFrame or numpy multi-dimensional array representing the values of the predictor variables to be screened in relation to the target variable, `y`. y : target variable series pandas Series or numpy 1-D array representing the values of the target variable. Values must be numerical (`int` or `float`) and cannot be of type `object`. target : Valid options: * **None** * **\"cpu\"** * **\"gpu\"** Indicates the device where the screening calculations should take place. Although faster, \"gpu\" functionality is brittle and should be considered experimental at this time. \"\"\" if target is None : target = 'cpu' else : assert target in [ 'cpu' , 'gpu' ] # Validate objects being passed in if isinstance ( X , pd . DataFrame ): X_raw , y_raw , X_cols , self . target_name = \\ validate_pandas_inputs ( X , y ) self . predictor_columns = X_raw . columns . tolist () self . n_obs = X_raw . shape [ 0 ] elif isinstance ( X , np . ndarray ): import math X_raw , y_raw , X_cols , self . target_name = validate_numpy_inputs ( X , y ) nvars = X_raw . shape [ 1 ] npad = int ( math . floor ( math . log10 ( abs ( nvars )))) + 1 self . predictor_columns = \\ [ 'var' + f ' { i } ' . zfill ( npad ) for i in range ( nvars )] self . n_obs = X_raw . shape [ 0 ] else : raise TypeError ( f \"Unsupported type for 'X': { type ( X ) } \" ) ############################################################ ## Convert information_measure to shorthand for functions ## ############################################################ if self . information_criterion == 'mutual_information' : info_name = 'mi' else : # information_criterion == 'uncertainty_reduction' info_name = 'ur' ####################################################### # TO-DO: Validate data # Convert any NaN values or categorical variables? # or just fail? ####################################################### if target == 'cpu' : from ._cpu import prepare_data from ._cpu import mcpt_bivariate_screen X_dict = \\ prepare_data ( X_raw , nbins = self . nbins_predictors , verbose = True ) # preserve the column pairs for use when reporting results self . column_pairs = X_dict [ 'col_pairs' ] . copy () self . crits_ , self . solo_pval_ , self . unbiased_pval_ = \\ mcpt_bivariate_screen ( X_dict , y_raw , y_nbins = self . nbins_target , information_measure = info_name , mcpt_nreps = self . mcpt_reps , mcpt_type = self . mcpt_type )","title":"screen()"},{"location":"screeners/bivariate/#narrowgate.screeners.bivariate.base.BivariateScreener.results","text":"results () A pandas DataFrame representing the calculated results produced from running screen . Consolidates the following instance attributes into a more digestable and comparable format: crits solo_pval unbiased_pval p_median_pval (if cscv_subsets > 0) Source code in narrowgate/screeners/bivariate/base.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 @property def results ( self ): \"\"\" A pandas DataFrame representing the calculated results produced from running `screen`. Consolidates the following instance attributes into a more digestable and comparable format: * `crits` * `solo_pval` * `unbiased_pval` * `p_median_pval` (if `cscv_subsets` > 0) \"\"\" if not self . crits_ is None : print ( \"BIVARIATE SCREENER RESULTS\" ) print ( \"---------------------------\" ) print ( f \"Number of observations: { self . n_obs } \" ) print ( f \"Number of predictors: { len ( self . predictor_columns ) } \" ) print ( f \"Target variable name: { self . target_name } \" ) print ( f \"Number of MCPT reps: { self . mcpt_reps } \" ) print ( f \"Number of bins (predictors): { self . nbins_predictors } \" ) print ( f \"Number of bins (target): { self . nbins_target } \" ) print ( f \"MCPT permutation method: { self . mcpt_type } \" ) if self . information_criterion == 'mutual_information' : info_crit_str = 'Mutual Information' elif self . information_criterion == 'uncertainty_reduction' : info_crit_str = 'Uncertainty Reduction' print ( f \"Information Criterion: { info_crit_str } \" ) var_series_1 = \\ pd . Series ( [ self . predictor_columns [ i ] for i in self . column_pairs [:, 0 ]], name = 'Variable 1' ) var_series_2 = \\ pd . Series ( [ self . predictor_columns [ i ] for i in self . column_pairs [:, 1 ]], name = 'Variable 2' ) col_names = [ info_crit_str , 'Solo p-value' , 'Unbiased p-value' ] results_mat = \\ np . hstack (( self . crits_ . reshape ( - 1 , 1 ), self . solo_pval_ . reshape ( - 1 , 1 ), self . unbiased_pval_ . reshape ( - 1 , 1 ))) results_df = \\ pd . DataFrame ( results_mat , columns = col_names ) results_df . insert ( 0 , 'Variable 2' , var_series_2 ) results_df . insert ( 0 , 'Variable 1' , var_series_1 ) results_df = \\ results_df . sort_values ( by = info_crit_str , ascending = False ) results_df . reset_index ( drop = True , inplace = True ) else : print ( \"No screening results available!\" ) results_df = None return results_df","title":"results()"},{"location":"screeners/bivariate/#narrowgate.screeners.bivariate.base.BivariateScreener.crits","text":"crits () Pandas DataFrame of information measures representing the interactive relationship of sets of two predictor variables with a target variable. Source code in narrowgate/screeners/bivariate/base.py 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 @property def crits ( self ): \"\"\" Pandas DataFrame of information measures representing the interactive relationship of sets of two predictor variables with a target variable. \"\"\" if self . crits_ is not None : var_series_1 = \\ pd . Series ( [ self . predictor_columns [ i ] for i in self . column_pairs [:, 0 ]], name = 'Variable 1' ) var_series_2 = \\ pd . Series ( [ self . predictor_columns [ i ] for i in self . column_pairs [:, 1 ]], name = 'Variable 2' ) crits_series = \\ pd . Series ( self . crits_ , name = self . information_criterion ) crits_df = \\ pd . concat ([ var_series_1 , var_series_2 , crits_series ], axis = 1 ) else : print ( \"No screening results available!\" ) crits_df = None return crits_df","title":"crits()"},{"location":"screeners/fsca/","text":"FSCA \u00a4 FSCA ( n_components = 3 , method = \"ordered\" , dropna = False , standardize = True , ) Bases: BaseEstimator Forward Selection Component Analysis class. This class attempts to solve several issues that may be encountered when traditional Principal Component Analysis is performed. These issues are: Required use of all variables and component interpretability when evaluating a high-dimensional data set Excessive collinearity among variables Potential lack of meaningful contribution to the data set's explainable variance by one or more variables. The algorithm presented in the references below (and implemented in this class) takes a step towards addressing the above challenges. It does so by intelligently selecting a subset of a user-defined number of variables present in the data set which represent the majority of the explained variance exhibited by all variables in the dataset. The class offers three variable selection options available via the method parameter: \"pca\" - no selection. All variables used. \"ordered\" - traditional forward selection method using method described in Puggini & McLoone \"refined\" - forward selction with backward refinement as described in Masters It is highly recommended to use the \"refined\" method if variable selection is desired. Refinement is implemented in a multi-threaded manner for significant performance improvements. Automatic Determination of Number of Variables \u00a4 It can often be challenging for the practitioner to know exactly how many components to select during component analysis. Furthermore, in the case of FSCA, since the number of components will equal the number of variables selected by the algorithm, finding an ideal value is increasingly important. This class offers a method proposed by Horn in 1965 that calculates components of random matrices which are the same shape as the dataset being evaluated. The method then compares the average (or median) eigenvalues from the iterations with random matrices to the eigenvalues obtained with the actual dataset. Since this method requires performing decomposition of many (potentially large) matrices, it can be extremely time-consuming. Other methods for automatically detecting the optimal number of components exist and will look to be added as options in future development work. Utilizing this method is as easy as setting n_components=None when initializing the class instance. For more information on Horn's method, please consult the provided references. Variable Clustering \u00a4 Finally, as an added bonus, this class provides a Hierarchical Clustering algorithm implementation to cluster similar variables into common subspaces. This assists the practitioner in detecting variables which are highly collinear with one another. This clustering method, combined with UnivariateScreener , is a powerful tool to assist the practitioner in removing redundancy from the data set being examined while retaining those variales with the highest informational relationship with a target variable. The optimal number of clusters is automatically determined via the silhouette score. The support of additional clustering metrics for optimal cluster number determination is a work item on the roadmap. For more information on using this method, please refer to the documentation provided in the cluster method. Selector and Transformer Functionality \u00a4 Because this class has both a variable selection and variable transformation component to it, it serves as a base class for both a Selector class as well as a Transformer class that can be used with a scikit-learn Pipeline . For more information on these classes, please refer to their documentation: FSCASelector FSCATransformer For more information on any of the specific algorithm details implemented within this class, please refer to the References below. References \u00a4 Masters, Timothy. (2019). \"Extracting and Selecting Features for Data Mining: Algorithms in C++ and CUDA\". pp. 11-51. Puggini, L., McLoone, S. (2017). \"Forward Selection Component Analysis: Algorithms and Applications\". IEEE Transactions on Pattern Analysis and Machine Intelligence, 39(12), 2395-2408. https://doi.org/10.1109/TPAMI.2017.2648792 Masters, Timothy. (2016). \"Data Mining Algorithms in C++\". pp. 234-254. Horn, J. (1965). \"A rationale and test for the number of factors in factor analysis.\" Psychometrika, 30(2), pp. 179-185. Parameters: Name Type Description Default n_components Optional [ int ] Number of principal components to use. This number also equates to the number of variables that will be 'selected' from the dataset. If None , then Horn's method will be used to automatically determine the number of components to use and variables to select. Note: Horn's method will substantially increase the runtime of fit method as it is dependent on the number of observations present in the dataset. 3 method str Valid options: {\"pca\", \"ordered\", \"refined\"} Method to use in the variable selection process \"pca\" - no selection. All variables used. \"ordered\" - traditional forward selection method using method described in Puggini & McLoone \"refined\" - forward selction with backward refinement as described in Masters reference (2019) 'ordered' dropna bool flag for indicating whether NaN values will be removed from consideration during standardization and component execution. False standardize bool flag for indicating whether data should be mean-centered and scaled to unit variance prior to fitting the components. This should almosts always be set to True . True Source code in narrowgate/screeners/fsca/base.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def __init__ ( self , n_components : Optional [ int ] = 3 , method : str = \"ordered\" , dropna : bool = False , standardize : bool = True ): \"\"\" Parameters ---------- n_components : Number of principal components to use. This number also equates to the number of variables that will be 'selected' from the dataset. If `None`, then Horn's method will be used to automatically determine the number of components to use and variables to select. **Note:** Horn's method will substantially increase the runtime of `fit` method as it is dependent on the number of observations present in the dataset. method : Valid options: {\"pca\", \"ordered\", \"refined\"} Method to use in the variable selection process * **\"pca\"** - no selection. All variables used. * **\"ordered\"** - traditional forward selection method using method described in Puggini & McLoone * **\"refined\"** - forward selction with backward refinement as described in Masters reference (2019) dropna : flag for indicating whether NaN values will be removed from consideration during standardization and component execution. standardize : flag for indicating whether data should be mean-centered and scaled to unit variance prior to fitting the components. This should almosts always be set to `True`. \"\"\" if method not in [ 'pca' , 'ordered' , 'refined' ]: raise AttributeError ( \"'method' parameter must be one of the following: \" + \"'pca', 'ordered', or 'refined'\" ) self . method = method if isinstance ( n_components , int ): assert n_components > 1 self . n_components = n_components elif n_components is None : self . n_components = 0 else : raise ValueError ( \"'n_components' parameter must be an integer value greater \" + \"than 1 or 'None' in order to use Horn's method to \" + \"automatically determine the number of components/variables \" + \"to select!\" ) self . eigvals = None self . eigvecs = None self . kept_columns = None self . kept_column_names = None self . dropna = dropna self . standardize = standardize self . verbose = None return None fit \u00a4 fit ( X , y = None , verbose = True ) Fits an FSCA object based on a pandas DataFrame X Parameters: Name Type Description Default X pd . DataFrame pandas DataFrame of exogenous variables required y None always None Must be present due to scikit-learn's BaseEstimator which is needed for Mixin capability. However, is not needed for functionality within the class itself. None verbose bool boolean to indicate whether method progress updates should be reported to the user via the console. Formal logging may be a preferred option as a future improvement. True Source code in narrowgate/screeners/fsca/base.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 def fit ( self , X : pd . DataFrame , y : None = None , verbose : bool = True ): \"\"\" Fits an FSCA object based on a pandas DataFrame `X` Parameters ---------- X pandas DataFrame of exogenous variables y always **None** Must be present due to scikit-learn's BaseEstimator which is needed for `Mixin`capability. However, is not needed for functionality within the class itself. verbose boolean to indicate whether method progress updates should be reported to the user via the console. Formal logging may be a preferred option as a future improvement. \"\"\" self . verbose = verbose # Prior to performing any work, do a quick search for any variables # being passed in that have exactly zero variab assert isinstance ( X , pd . DataFrame ) self . feature_names_in_ = X . columns . tolist () self . n_feature_names_in_ = X . shape [ 1 ] zero_var_mask = X . nunique () == 1 if any ( zero_var_mask ): zero_var_idx = np . where ( zero_var_mask )[ 0 ] zero_var_names = X . columns [ zero_var_idx ] . tolist () data . drop ( labels = zero_var_names , axis = 1 , inplace = True ) print ( 'ALERT! The following columns have zero variance and must ' + f \"be dropped for algorithm stability: { ', ' . join ( zero_var_names ) } \" ) self . npred = X . shape [ 1 ] # Find mean and stdev of the data. # If there are a different number of NA's in each column # of the data, then the covariance matrix will not have # a diagonal of 1.0. In order to account for this, then # only the rows that are entirely non-NA need to be used # to calculate the mean and std for each variable. if self . dropna : self . mean = X . dropna () . mean () self . std = X . dropna () . std () X_work = ( X . dropna () - self . mean ) else : self . mean = X . mean () self . std = X . std () X_work = ( X - self . mean ) if self . standardize : X_work /= self . std self . n_samples = X_work . shape [ 0 ] # Original paper only centers (zero-mean) (p.16). # Masters standardizes and therefore the covariance # matrix is actually the correlation matrix with diagonal # values of 1. self . covar = X_work . cov () ######################################## ## mean squared correlation DataFrame ## ######################################## kept_columns = np . array ([], dtype = np . int64 ) crit_list = [] for i in range ( self . npred ): crit = \\ newvar_crit_nb ( self . covar . values , kept_columns , trial_col = i ) # 'crit' includes correlation with itself ... remove it crit = ( crit - 1 ) / ( self . npred - 1 ) crit_list . append ( crit ) self . corr = \\ pd . Series ( crit_list , index = X_work . columns , name = 'mean_sq_corr' ) ##################################################### ## Compute eigenstructure of the covariance matrix ## ##################################################### self . eigvals , self . eigvecs = np . linalg . eig ( self . covar ) # numpy doesn't guarantee ordered eigenvalues. # order them from greatest to least along with their respective # eigenvectors eig_sort_idx = np . argsort ( self . eigvals )[:: - 1 ] self . eigvals = self . eigvals [ eig_sort_idx ] self . eigvecs = self . eigvecs [:, eig_sort_idx ] # Account for any negative eigenvalues neg_eigval_mask = self . eigvals < 0 self . eigvals [ neg_eigval_mask ] = 0 # Set 1.e-9 as an arbitrary value to determine the number # of unique eigenvectors available during 'transform'. self . n_unique_eigval = np . sum ( self . eigvals > 1.e-9 ) self . eigval_cum = \\ 100 * np . cumsum ( self . eigvals ) / np . sum ( self . eigvals ) ######################################################## ## Compute the eigvalues using Horn's method ## ## - This helps determine the optimal number of ## ## components to retain ## ######################################################## if not self . n_components : if self . verbose : print ( \"Calculating Horn's eigenvalue matrix ... \" ) print ( f \"Number of observations: { self . n_samples } \" ) print ( f \"Number of variables: { self . npred } \" ) # Determine the number of iterations to use for Horn's method. # If there are an extreme number of variables being evaluated in the # original data set, it is worthwhile to consider dropping the number # of random iterations performed. Doing so will make the value to # determine the number of components to choose less stable, but will # speed up the 'fit' considerably. if self . npred > 500 : n_iters = 10 else : n_iters = 50 if self . verbose : print ( f \"Number of Monte Carlo reps: { n_iters } \" ) self . horns_eigenvalue_matrix = \\ horns_method ( self . n_samples , self . npred , n_iters ) self . orig_eigvals = self . eigvals . copy () horns_eigval_median = \\ np . median ( self . horns_eigenvalue_matrix , axis = 0 ) n_comp_mask = self . orig_eigvals >= horns_eigval_median n_horns_comps = np . max ( np . where ( n_comp_mask )[ 0 ]) + 1 if self . verbose : print ( f \"Setting number of components to { n_horns_comps } \" ) self . n_components = n_horns_comps ############################################################ ## Eigenvector and Principal Component Factors DataFrames ## ############################################################ if isinstance ( X_work , pd . DataFrame ): self . eigvecs = \\ pd . DataFrame ( self . eigvecs , index = X_work . columns , columns = [ f 'PC { i } ' for i in range ( self . eigvecs . shape [ 1 ])]) self . pc_factors = \\ np . multiply ( self . eigvecs . iloc [:,: self . n_unique_eigval ], np . sqrt ( self . eigvals [: self . n_unique_eigval ])) #################################################### # If method == 'pca', then calculations stop here. # #################################################### if self . method in [ 'ordered' , 'refined' ]: # first variable selected = greatest corr. to other variables. self . kept_columns = np . array ([ np . argmax ( self . corr . values )]) # Move on to the stepwise component selection # The best (max multiple-R) column is in best_column, so start with it. # If the correlation matrix is singular (one or more zero eigenvalues) # then reduce the correlations enough to make it nonsingular. # This is crucial, because some of the tests that we now use # involve inverting Z'Z, so it must be nonsingular. # Should require just one pass to eliminate singularity while ( self . eigvals [ - 1 ] <= 0.0 ): if self . verbose : print ( \"NOTE: Adjusting correlations because some variables are collinear\" ) # perturb the non-diagonal values for j in range ( 1 , self . npred ): for k in range ( j ): self . covar . iloc [ j , k ] *= 0.99999 self . covar . iloc [ k , j ] = self . covar . iloc [ j , k ] self . eigvals , self . eigvecs = np . linalg . eig ( self . covar ) # numpy doesn't guarantee ordered eigenvalues. # order them along with their respective eigenvectors eig_sort_idx = np . argsort ( self . eigvals )[:: - 1 ] self . eigvals = self . eigvals [ eig_sort_idx ] self . eigvecs = self . eigvecs [:, eig_sort_idx ] # Count the kept variables. # This value will eventually equal 'n_components' when complete # except in pathological cases nkept = 1 best_crit = - 1.e50 if self . verbose : print ( \"Commencing stepwise construction with \" + f \" { X_work . columns [ self . kept_columns [ 0 ]] } \" ) # While we still need to keep more components while nkept < self . n_components : # Will flag if we got a good new column best_column = - 1 # Try all columns (predictors) for icol in range ( self . npred ): # If the column has already been selected, skip it if not icol in self . kept_columns : crit = \\ newvar_crit_nb ( self . covar . values , self . kept_columns , trial_col = icol ) # Debug print #print(f\" Trial: {data.columns[icol]} = {crit}\") if crit > best_crit : best_crit = crit best_column = icol # Check if a best_column was found if best_column < 0 : # Then must be done adding columns. # Getting here would be pathological. # Adding a column should ALWAYS improve the criterion # Unless there is some perfect collinearity, but # that was eliminated earlier if self . verbose : print ( \"WARNING... Adding a new column failed to improve \" + \"the criterion!\" ) break if self . verbose : print ( f \" - Added { X_work . columns [ best_column ] } for \" + f \"criterion= { best_crit } \" ) self . kept_columns = np . append ( self . kept_columns , best_column ) nkept += 1 if self . method == 'refined' : best_crit , crit_matrix = \\ spbr_nb ( self . covar . values , self . kept_columns ) max_crit = np . max ( crit_matrix ) if max_crit > best_crit : refined_idxs = np . argwhere ( crit_matrix == max_crit ) old_col_idx = refined_idxs [ 0 , 0 ] new_col_idx = refined_idxs [ 0 , 1 ] old_col_name = \\ X_work . columns [ self . kept_columns [ old_col_idx ]] new_col_name = X_work . columns [ new_col_idx ] if self . verbose : print ( f \" - Replaced { old_col_name } with \" + f \" { new_col_name } to get criterion = { max_crit } \" ) self . kept_columns [ old_col_idx ] = new_col_idx else : if self . verbose : print ( f \" - no refinement needed\" ) self . kept_column_names = \\ X_work . columns [ self . kept_columns ] . to_list () if self . method == 'ordered' : # The values stored in 'B' are the coefficients of the 'kept_columns' # that can be used to produce out-of-sample components based on the # 'ordered' FSCA process. # These components are approximately orthogonal. # They are listed in decreasing order of variance capture by the variables # The order of the variables is independent of the user's choice in the # number of variables to compute although the coefficients may vary somewhat # according to the number of components. B = self . _calculate_ordered_coefficients ( X ) # Create a DataFrame linking the coefficents in B to the kept columns # as well as the components comp_col_names = \\ [ f 'FSCA_ORD_C { i } ' for i in range ( len ( self . kept_column_names ))] self . weights = \\ pd . DataFrame ( B , index = self . kept_column_names , columns = comp_col_names ) else : ############################## ## self.method == 'refined' ## ############################## self . _calculate_refined_coefficients ( X ) return self transform \u00a4 transform ( X ) Transforms pandas DataFrame, X , by returning the components calculated during fit method execution. Returns: Type Description pd.DataFrame pandas DataFrame of FSCA components Parameters: Name Type Description Default X pd . DataFrame pandas DataFrame to transform required Source code in narrowgate/screeners/fsca/base.py 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 def transform ( self , X : pd . DataFrame ) -> pd . DataFrame : \"\"\" Transforms pandas DataFrame, `X`, by returning the components calculated during `fit` method execution. Returns ------- pd.DataFrame : pandas DataFrame of FSCA components Parameters ---------- X : pandas DataFrame to transform \"\"\" # confirm number of columns are the same as what was 'fit' assert ( X . shape [ 1 ] == self . mean . shape [ 0 ]) if self . method == 'pca' : output = self . _pca_transform ( X ) elif self . method == 'ordered' : output = self . _ordered_transform ( X ) else : # self.method = 'refined' output = self . _refined_transform ( X ) return output cluster \u00a4 cluster ( cluster_type = \"centroid\" , min_clusters = 2 , max_clusters = None , metric = \"silhouette\" , verbose = False , ) Method for clustering variables into similar subspaces. Utilizes principal components, hierarchical clustering, and a clustering metric in order to determine optimal number of clusters/subspacess in the data set. Requires that fit method be called prior to execution as a dependency exists on the instance member pc_factors . Utilizes n_components when determining the clusters. Parameters: Name Type Description Default cluster_type str string indicating the clustering type to use. Options: \"centroid\" - recalculates component centroids for cluster as each new variable is added to cluster (preferred). \"other\" - uses component values of dominant variable in cluster as centroid. In other words, the component values of the first variable selected into the cluster determine the cluster centroid for the cluster even as new variables are added to the cluster. 'centroid' min_clusters int minimum number of clusters to consider when determining the optimal number of clusters 2 max_clusters Optional [ int ] maximum number of clusters to consider when determining the optimal number of clusters. This number should be less than the number of components present in pc_factors and greater than min_clusters None metric str cluster metric to use when determining the optimal number of clusters. Options include: \"silhouette\" 'silhouette' verbose bool boolean flag for indicating whether progress updates on method execution should be reported to the user via the console. False Attributes: Name Type Description clusters pd.Series pandas Series that contains the name of the variable as the index and the cluster number for that variable as the value. References \u00a4 Source code in narrowgate/screeners/fsca/base.py 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 def cluster ( self , cluster_type : str = 'centroid' , min_clusters : int = 2 , max_clusters : Optional [ int ] = None , metric : str = 'silhouette' , verbose : bool = False ): \"\"\" Method for clustering variables into similar subspaces. Utilizes principal components, hierarchical clustering, and a clustering metric in order to determine optimal number of clusters/subspacess in the data set. Requires that `fit` method be called prior to execution as a dependency exists on the instance member `pc_factors`. Utilizes `n_components` when determining the clusters. Parameters ---------- cluster_type : string indicating the clustering type to use. Options: **\"centroid\"** - recalculates component centroids for cluster as each new variable is added to cluster (preferred). **\"other\"** - uses component values of dominant variable in cluster as centroid. In other words, the component values of the first variable selected into the cluster determine the cluster centroid for the cluster even as new variables are added to the cluster. min_clusters : minimum number of clusters to consider when determining the optimal number of clusters max_clusters : maximum number of clusters to consider when determining the optimal number of clusters. This number should be less than the number of components present in `pc_factors` and greater than `min_clusters` metric : cluster metric to use when determining the optimal number of clusters. Options include: **\"silhouette\"** verbose : boolean flag for indicating whether progress updates on method execution should be reported to the user via the console. Attributes ---------- clusters : pd.Series pandas Series that contains the name of the variable as the index and the cluster number for that variable as the value. References ---------- \"\"\" from ._cluster import cluster_variables from ...utils.cluster import silhouette_nb , find_optimal_cluster from statistics import mode assert isinstance ( min_clusters , int ) check_is_fitted ( self , 'pc_factors' ) # If max_clusters is None, then set to the number of components n_pc_factors = self . pc_factors . shape [ 1 ] if max_clusters is None : max_clusters = n_pc_factors else : assert isinstance ( max_clusters , int ) assert max_clusters > min_clusters assert max_clusters <= n_pc_factors print ( \"Performing hierarchical clustering ...\" ) cluster_results = self . _cluster_variables ( cluster_type , verbose ) print ( \"Calculating clustering performance ...\" ) factors = self . pc_factors . iloc [:,: self . n_components ] sil_list = dict () count = 0 for name , result_iter in reversed ( cluster_results . items ()): count += 1 if count >= min_clusters and count <= max_clusters : try : silhouette , dist , cluster_dist = \\ silhouette_nb ( factors . values , result_iter [ 'cluster_id' ], result_iter [ 'n_in_group' ], result_iter [ 'centroids' ] . values ) sil_mean = np . mean ( silhouette ) sil_list [ name ] = sil_mean except : pass elif count > max_clusters : break print ( \"Selecting optimal cluster ...\" ) sil_cluster_values = list ( sil_list . values ()) best_iter_list = [] for i in range ( 2 , 20 ): best_iter , best_score = \\ find_optimal_cluster ( sil_cluster_values , max_since_best_iter = i ) best_iter_list . append ( best_iter ) n_clusters_optimal = str ( mode ( best_iter_list )) optimal_cluster_membership = \\ cluster_results [ n_clusters_optimal ][ 'cluster_id' ] self . clusters = \\ pd . Series ( optimal_cluster_membership , index = self . pc_factors . index , name = 'cluster_id' ) if verbose : print ( \"Complete.\" ) _calculate_ordered_coefficients \u00a4 _calculate_ordered_coefficients ( X ) Class method called when method='ordered' Computes components of input data, X with no backward refinement. The columns used in creating the components are strictly ordered by variable. Variables ara added in order of increasing ability to reconstruct the dataset, and no variable replacement is performed. The implication is that the components are independent of the number of components requested by the user. Also, the first component will be the first variable selected (that having maximum mean squared correlation). The second component will be the second variable with the projection of the first variable removed. In general, each component will be that variable (in the order selected) with the contributions of all prior variables removed via a Gram-Schmidt orthogonalization process. Source code in narrowgate/screeners/fsca/base.py 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 def _calculate_ordered_coefficients ( self , X ): \"\"\" Class method called when `method='ordered'` Computes components of input data, `X` with no backward refinement. The columns used in creating the components are strictly ordered by variable. Variables ara added in order of increasing ability to reconstruct the dataset, and no variable replacement is performed. The implication is that the components are independent of the number of components requested by the user. Also, the first component will be the first variable selected (that having maximum mean squared correlation). The second component will be the second variable with the projection of the first variable removed. In general, each component will be that variable (in the order selected) with the contributions of all prior variables removed via a Gram-Schmidt orthogonalization process. \"\"\" # confirm that 'kept_column_names' are present in 'data' assert all ([ col in X . columns for col in self . kept_column_names ]) n_cases = X . shape [ 0 ] # At this point, the best subset of nkept = n_components predictors # have been found. # Regardless of whether method = 'ordered' or 'refined', # we will need the outer product Z'Z in covar. # Compute it now. covar = X [ self . kept_column_names ] . cov () # original code has n_cases populating the diagonal for the ordered # coefficients calculation. The 'refined' calculation uses the # covariance matrix as-is. np . fill_diagonal ( covar . values , n_cases ) # Compute and save the components for the entire dataset. output = gram_schmidt_nb ( X [ self . kept_column_names ] . values ) # GramSchmidt leaves the columns unit length # we want their sum of squares to be n_cases so that they have # unit standard deviation. output *= np . sqrt ( n_cases ) # 'output' contains the orthogonalized kept variables. # We could just use these as the created variables, but that would make # it impossible to create corresponding OOS variables. # Plus, many users want to see how to compute the components from the # selected variables. So we use simple linear regression to find the # coefficients. # Rather than using a sophisticated method, which would be overkill, we # just use the simple matrix inversion method. # In keeping with the notation in the paper, we define: # Z - n_cases by nkept matrix of variables selected above # M - n_cases by nkept matrix of computed components # We now wish to find the weight matrix B that will let us compute # M from Z by a simple linear transformation: # M = Z B # The well-known least-squares solution to this problem is: # -1 # B = (Z'Z) Z' M # Because the Gram-Schmidt process is a linear transformation, # these predicted values will also be orthogonal (except for minor fpt # error). # Invert Z'Z (in covar). It should always be invertible (nonsingular) # because a long time ago we computed n_unique, the rank of the # full data matrix, and reduced n_components to that value if needed. # Then, when the n_components subset of variables was selected, the # algorithm by design favored selecting variables most independent # of those already selected. work_inv = np . linalg . inv ( covar ) # We now have the inverse of Z'Z in 'work_inv' # Compute Z'M Z_prime_M = \\ np . dot ( np . transpose ( X [ self . kept_column_names ] . values ), output ) # Last step: Multiply those two matrices to get B, the coefficients. B = np . dot ( work_inv , Z_prime_M ) return B _calculate_refined_coefficients \u00a4 _calculate_refined_coefficients ( X ) Class method called when method='refined' The order of variable selection is changed by refinement in which case the principal components of the selected variables are calculated. This method produces additional 'refined' members of the class that correspond to the: - eigenvalues - eigenvectors - cumulative explained variance of each component - correlations of selected variables to each component In addition, the weights of variables for each component are calculated according to the recommendation on page 51 of the reference text by Masters. The class member component_correlations_refined is a pandas DataFrame whose values correspond to the correlations and the component represented in the given column Source code in narrowgate/screeners/fsca/base.py 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 def _calculate_refined_coefficients ( self , X ): \"\"\" Class method called when `method='refined'` The order of variable selection is changed by refinement in which case the principal components of the selected variables are calculated. This method produces additional 'refined' members of the class that correspond to the: - eigenvalues - eigenvectors - cumulative explained variance of each component - correlations of selected variables to each component In addition, the weights of variables for each component are calculated according to the recommendation on page 51 of the reference text by Masters. The class member `component_correlations_refined` is a pandas DataFrame whose values correspond to the correlations and the component represented in the given column \"\"\" # confirm that 'kept_column_names' are present in 'data' assert all ([ col in X . columns for col in self . kept_column_names ]) # Compute the outer product Z'Z in covar. covar = X [ self . kept_column_names ] . cov () # Compute the eigenstructure of the correlation matrix of selected columns self . eigvals_refined , self . eigvecs_refined = np . linalg . eig ( covar ) # numpy doesn't guarantee ordered eigenvalues. # order them along with their respective eigenvectors eig_sort_idx = np . argsort ( self . eigvals_refined )[:: - 1 ] sort_idx = np . argsort ( self . eigvals_refined )[:: - 1 ] self . eigvals_refined = self . eigvals_refined [ eig_sort_idx ] self . eigvecs_refined = self . eigvecs_refined [:, eig_sort_idx ] # Account for any negative eigenvalues neg_eigval_mask = self . eigvals_refined < 0 self . eigvals_refined [ neg_eigval_mask ] = 0 # Use self.n_unique_eigval which was calculated earlier in 'fit' self . eigval_cum_refined = \\ 100 * np . cumsum ( self . eigvals_refined ) / self . n_unique_eigval ############################################################ ## Eigenvector and Principal Component Factor DataFrames ## ############################################################ if isinstance ( X , pd . DataFrame ): n_comps = self . eigvecs_refined . shape [ 1 ] col_names = [ f 'FSCA_REF_PC { i } ' for i in range ( n_comps )] self . eigvecs_refined = \\ pd . DataFrame ( self . eigvecs_refined , index = self . kept_column_names , columns = col_names ) self . component_correlations_refined = \\ np . multiply ( self . eigvecs_refined , np . sqrt ( self . eigvals_refined )) # Calculate the weights for computing the component standardized to # unit variance. self . weights = \\ np . divide ( self . component_correlations_refined , self . eigvals_refined + 1.e-60 ) _ordered_transform \u00a4 _ordered_transform ( data ) Out-of-sample transformation of data when method='ordered' Based on 'B' matrix Source code in narrowgate/screeners/fsca/base.py 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 def _ordered_transform ( self , data ): \"\"\" Out-of-sample transformation of data when `method='ordered'` Based on 'B' matrix \"\"\" # confirm that 'kept_column_names' are present in 'data' assert all ([ col in data . columns for col in self . kept_column_names ]) X = data [ self . kept_column_names ] - self . mean [ self . kept_column_names ] if self . standardize : X /= self . std [ self . kept_column_names ] components = X . dot ( self . weights ) return components _refined_transform \u00a4 _refined_transform ( data ) Out-of-sample transformation of data when method='refined' Based on Principal Component Factors Source code in narrowgate/screeners/fsca/base.py 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 def _refined_transform ( self , data ): \"\"\" Out-of-sample transformation of data when `method='refined'` Based on Principal Component Factors \"\"\" # confirm that 'kept_column_names' are present in 'data' assert all ([ col in data . columns for col in self . kept_column_names ]) X = data [ self . kept_column_names ] - self . mean [ self . kept_column_names ] if self . standardize : X /= self . std [ self . kept_column_names ] components = X . dot ( self . weights ) return components _pca_transform \u00a4 _pca_transform ( data ) Out-of-sample transformation of data when method='pca' Based on standard Principal Component Analysis Source code in narrowgate/screeners/fsca/base.py 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 def _pca_transform ( self , data ): \"\"\" Out-of-sample transformation of data when `method='pca'` Based on standard Principal Component Analysis \"\"\" # Center and/or standardize according to what was done in fit X = data - self . mean if self . standardize : X /= self . std # Calculate the principal components for each observation components = X . dot ( self . eigvecs . divide ( np . sqrt ( self . eigvals ))) return components","title":"FSCA"},{"location":"screeners/fsca/#narrowgate.screeners.FSCA","text":"FSCA ( n_components = 3 , method = \"ordered\" , dropna = False , standardize = True , ) Bases: BaseEstimator Forward Selection Component Analysis class. This class attempts to solve several issues that may be encountered when traditional Principal Component Analysis is performed. These issues are: Required use of all variables and component interpretability when evaluating a high-dimensional data set Excessive collinearity among variables Potential lack of meaningful contribution to the data set's explainable variance by one or more variables. The algorithm presented in the references below (and implemented in this class) takes a step towards addressing the above challenges. It does so by intelligently selecting a subset of a user-defined number of variables present in the data set which represent the majority of the explained variance exhibited by all variables in the dataset. The class offers three variable selection options available via the method parameter: \"pca\" - no selection. All variables used. \"ordered\" - traditional forward selection method using method described in Puggini & McLoone \"refined\" - forward selction with backward refinement as described in Masters It is highly recommended to use the \"refined\" method if variable selection is desired. Refinement is implemented in a multi-threaded manner for significant performance improvements.","title":"FSCA"},{"location":"screeners/fsca/#narrowgate.screeners.FSCA--automatic-determination-of-number-of-variables","text":"It can often be challenging for the practitioner to know exactly how many components to select during component analysis. Furthermore, in the case of FSCA, since the number of components will equal the number of variables selected by the algorithm, finding an ideal value is increasingly important. This class offers a method proposed by Horn in 1965 that calculates components of random matrices which are the same shape as the dataset being evaluated. The method then compares the average (or median) eigenvalues from the iterations with random matrices to the eigenvalues obtained with the actual dataset. Since this method requires performing decomposition of many (potentially large) matrices, it can be extremely time-consuming. Other methods for automatically detecting the optimal number of components exist and will look to be added as options in future development work. Utilizing this method is as easy as setting n_components=None when initializing the class instance. For more information on Horn's method, please consult the provided references.","title":"Automatic Determination of Number of Variables"},{"location":"screeners/fsca/#narrowgate.screeners.FSCA--variable-clustering","text":"Finally, as an added bonus, this class provides a Hierarchical Clustering algorithm implementation to cluster similar variables into common subspaces. This assists the practitioner in detecting variables which are highly collinear with one another. This clustering method, combined with UnivariateScreener , is a powerful tool to assist the practitioner in removing redundancy from the data set being examined while retaining those variales with the highest informational relationship with a target variable. The optimal number of clusters is automatically determined via the silhouette score. The support of additional clustering metrics for optimal cluster number determination is a work item on the roadmap. For more information on using this method, please refer to the documentation provided in the cluster method.","title":"Variable Clustering"},{"location":"screeners/fsca/#narrowgate.screeners.FSCA--selector-and-transformer-functionality","text":"Because this class has both a variable selection and variable transformation component to it, it serves as a base class for both a Selector class as well as a Transformer class that can be used with a scikit-learn Pipeline . For more information on these classes, please refer to their documentation: FSCASelector FSCATransformer For more information on any of the specific algorithm details implemented within this class, please refer to the References below.","title":"Selector and Transformer Functionality"},{"location":"screeners/fsca/#narrowgate.screeners.FSCA--references","text":"Masters, Timothy. (2019). \"Extracting and Selecting Features for Data Mining: Algorithms in C++ and CUDA\". pp. 11-51. Puggini, L., McLoone, S. (2017). \"Forward Selection Component Analysis: Algorithms and Applications\". IEEE Transactions on Pattern Analysis and Machine Intelligence, 39(12), 2395-2408. https://doi.org/10.1109/TPAMI.2017.2648792 Masters, Timothy. (2016). \"Data Mining Algorithms in C++\". pp. 234-254. Horn, J. (1965). \"A rationale and test for the number of factors in factor analysis.\" Psychometrika, 30(2), pp. 179-185. Parameters: Name Type Description Default n_components Optional [ int ] Number of principal components to use. This number also equates to the number of variables that will be 'selected' from the dataset. If None , then Horn's method will be used to automatically determine the number of components to use and variables to select. Note: Horn's method will substantially increase the runtime of fit method as it is dependent on the number of observations present in the dataset. 3 method str Valid options: {\"pca\", \"ordered\", \"refined\"} Method to use in the variable selection process \"pca\" - no selection. All variables used. \"ordered\" - traditional forward selection method using method described in Puggini & McLoone \"refined\" - forward selction with backward refinement as described in Masters reference (2019) 'ordered' dropna bool flag for indicating whether NaN values will be removed from consideration during standardization and component execution. False standardize bool flag for indicating whether data should be mean-centered and scaled to unit variance prior to fitting the components. This should almosts always be set to True . True Source code in narrowgate/screeners/fsca/base.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def __init__ ( self , n_components : Optional [ int ] = 3 , method : str = \"ordered\" , dropna : bool = False , standardize : bool = True ): \"\"\" Parameters ---------- n_components : Number of principal components to use. This number also equates to the number of variables that will be 'selected' from the dataset. If `None`, then Horn's method will be used to automatically determine the number of components to use and variables to select. **Note:** Horn's method will substantially increase the runtime of `fit` method as it is dependent on the number of observations present in the dataset. method : Valid options: {\"pca\", \"ordered\", \"refined\"} Method to use in the variable selection process * **\"pca\"** - no selection. All variables used. * **\"ordered\"** - traditional forward selection method using method described in Puggini & McLoone * **\"refined\"** - forward selction with backward refinement as described in Masters reference (2019) dropna : flag for indicating whether NaN values will be removed from consideration during standardization and component execution. standardize : flag for indicating whether data should be mean-centered and scaled to unit variance prior to fitting the components. This should almosts always be set to `True`. \"\"\" if method not in [ 'pca' , 'ordered' , 'refined' ]: raise AttributeError ( \"'method' parameter must be one of the following: \" + \"'pca', 'ordered', or 'refined'\" ) self . method = method if isinstance ( n_components , int ): assert n_components > 1 self . n_components = n_components elif n_components is None : self . n_components = 0 else : raise ValueError ( \"'n_components' parameter must be an integer value greater \" + \"than 1 or 'None' in order to use Horn's method to \" + \"automatically determine the number of components/variables \" + \"to select!\" ) self . eigvals = None self . eigvecs = None self . kept_columns = None self . kept_column_names = None self . dropna = dropna self . standardize = standardize self . verbose = None return None","title":"References"},{"location":"screeners/fsca/#narrowgate.screeners.fsca.base.FSCA.fit","text":"fit ( X , y = None , verbose = True ) Fits an FSCA object based on a pandas DataFrame X Parameters: Name Type Description Default X pd . DataFrame pandas DataFrame of exogenous variables required y None always None Must be present due to scikit-learn's BaseEstimator which is needed for Mixin capability. However, is not needed for functionality within the class itself. None verbose bool boolean to indicate whether method progress updates should be reported to the user via the console. Formal logging may be a preferred option as a future improvement. True Source code in narrowgate/screeners/fsca/base.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 def fit ( self , X : pd . DataFrame , y : None = None , verbose : bool = True ): \"\"\" Fits an FSCA object based on a pandas DataFrame `X` Parameters ---------- X pandas DataFrame of exogenous variables y always **None** Must be present due to scikit-learn's BaseEstimator which is needed for `Mixin`capability. However, is not needed for functionality within the class itself. verbose boolean to indicate whether method progress updates should be reported to the user via the console. Formal logging may be a preferred option as a future improvement. \"\"\" self . verbose = verbose # Prior to performing any work, do a quick search for any variables # being passed in that have exactly zero variab assert isinstance ( X , pd . DataFrame ) self . feature_names_in_ = X . columns . tolist () self . n_feature_names_in_ = X . shape [ 1 ] zero_var_mask = X . nunique () == 1 if any ( zero_var_mask ): zero_var_idx = np . where ( zero_var_mask )[ 0 ] zero_var_names = X . columns [ zero_var_idx ] . tolist () data . drop ( labels = zero_var_names , axis = 1 , inplace = True ) print ( 'ALERT! The following columns have zero variance and must ' + f \"be dropped for algorithm stability: { ', ' . join ( zero_var_names ) } \" ) self . npred = X . shape [ 1 ] # Find mean and stdev of the data. # If there are a different number of NA's in each column # of the data, then the covariance matrix will not have # a diagonal of 1.0. In order to account for this, then # only the rows that are entirely non-NA need to be used # to calculate the mean and std for each variable. if self . dropna : self . mean = X . dropna () . mean () self . std = X . dropna () . std () X_work = ( X . dropna () - self . mean ) else : self . mean = X . mean () self . std = X . std () X_work = ( X - self . mean ) if self . standardize : X_work /= self . std self . n_samples = X_work . shape [ 0 ] # Original paper only centers (zero-mean) (p.16). # Masters standardizes and therefore the covariance # matrix is actually the correlation matrix with diagonal # values of 1. self . covar = X_work . cov () ######################################## ## mean squared correlation DataFrame ## ######################################## kept_columns = np . array ([], dtype = np . int64 ) crit_list = [] for i in range ( self . npred ): crit = \\ newvar_crit_nb ( self . covar . values , kept_columns , trial_col = i ) # 'crit' includes correlation with itself ... remove it crit = ( crit - 1 ) / ( self . npred - 1 ) crit_list . append ( crit ) self . corr = \\ pd . Series ( crit_list , index = X_work . columns , name = 'mean_sq_corr' ) ##################################################### ## Compute eigenstructure of the covariance matrix ## ##################################################### self . eigvals , self . eigvecs = np . linalg . eig ( self . covar ) # numpy doesn't guarantee ordered eigenvalues. # order them from greatest to least along with their respective # eigenvectors eig_sort_idx = np . argsort ( self . eigvals )[:: - 1 ] self . eigvals = self . eigvals [ eig_sort_idx ] self . eigvecs = self . eigvecs [:, eig_sort_idx ] # Account for any negative eigenvalues neg_eigval_mask = self . eigvals < 0 self . eigvals [ neg_eigval_mask ] = 0 # Set 1.e-9 as an arbitrary value to determine the number # of unique eigenvectors available during 'transform'. self . n_unique_eigval = np . sum ( self . eigvals > 1.e-9 ) self . eigval_cum = \\ 100 * np . cumsum ( self . eigvals ) / np . sum ( self . eigvals ) ######################################################## ## Compute the eigvalues using Horn's method ## ## - This helps determine the optimal number of ## ## components to retain ## ######################################################## if not self . n_components : if self . verbose : print ( \"Calculating Horn's eigenvalue matrix ... \" ) print ( f \"Number of observations: { self . n_samples } \" ) print ( f \"Number of variables: { self . npred } \" ) # Determine the number of iterations to use for Horn's method. # If there are an extreme number of variables being evaluated in the # original data set, it is worthwhile to consider dropping the number # of random iterations performed. Doing so will make the value to # determine the number of components to choose less stable, but will # speed up the 'fit' considerably. if self . npred > 500 : n_iters = 10 else : n_iters = 50 if self . verbose : print ( f \"Number of Monte Carlo reps: { n_iters } \" ) self . horns_eigenvalue_matrix = \\ horns_method ( self . n_samples , self . npred , n_iters ) self . orig_eigvals = self . eigvals . copy () horns_eigval_median = \\ np . median ( self . horns_eigenvalue_matrix , axis = 0 ) n_comp_mask = self . orig_eigvals >= horns_eigval_median n_horns_comps = np . max ( np . where ( n_comp_mask )[ 0 ]) + 1 if self . verbose : print ( f \"Setting number of components to { n_horns_comps } \" ) self . n_components = n_horns_comps ############################################################ ## Eigenvector and Principal Component Factors DataFrames ## ############################################################ if isinstance ( X_work , pd . DataFrame ): self . eigvecs = \\ pd . DataFrame ( self . eigvecs , index = X_work . columns , columns = [ f 'PC { i } ' for i in range ( self . eigvecs . shape [ 1 ])]) self . pc_factors = \\ np . multiply ( self . eigvecs . iloc [:,: self . n_unique_eigval ], np . sqrt ( self . eigvals [: self . n_unique_eigval ])) #################################################### # If method == 'pca', then calculations stop here. # #################################################### if self . method in [ 'ordered' , 'refined' ]: # first variable selected = greatest corr. to other variables. self . kept_columns = np . array ([ np . argmax ( self . corr . values )]) # Move on to the stepwise component selection # The best (max multiple-R) column is in best_column, so start with it. # If the correlation matrix is singular (one or more zero eigenvalues) # then reduce the correlations enough to make it nonsingular. # This is crucial, because some of the tests that we now use # involve inverting Z'Z, so it must be nonsingular. # Should require just one pass to eliminate singularity while ( self . eigvals [ - 1 ] <= 0.0 ): if self . verbose : print ( \"NOTE: Adjusting correlations because some variables are collinear\" ) # perturb the non-diagonal values for j in range ( 1 , self . npred ): for k in range ( j ): self . covar . iloc [ j , k ] *= 0.99999 self . covar . iloc [ k , j ] = self . covar . iloc [ j , k ] self . eigvals , self . eigvecs = np . linalg . eig ( self . covar ) # numpy doesn't guarantee ordered eigenvalues. # order them along with their respective eigenvectors eig_sort_idx = np . argsort ( self . eigvals )[:: - 1 ] self . eigvals = self . eigvals [ eig_sort_idx ] self . eigvecs = self . eigvecs [:, eig_sort_idx ] # Count the kept variables. # This value will eventually equal 'n_components' when complete # except in pathological cases nkept = 1 best_crit = - 1.e50 if self . verbose : print ( \"Commencing stepwise construction with \" + f \" { X_work . columns [ self . kept_columns [ 0 ]] } \" ) # While we still need to keep more components while nkept < self . n_components : # Will flag if we got a good new column best_column = - 1 # Try all columns (predictors) for icol in range ( self . npred ): # If the column has already been selected, skip it if not icol in self . kept_columns : crit = \\ newvar_crit_nb ( self . covar . values , self . kept_columns , trial_col = icol ) # Debug print #print(f\" Trial: {data.columns[icol]} = {crit}\") if crit > best_crit : best_crit = crit best_column = icol # Check if a best_column was found if best_column < 0 : # Then must be done adding columns. # Getting here would be pathological. # Adding a column should ALWAYS improve the criterion # Unless there is some perfect collinearity, but # that was eliminated earlier if self . verbose : print ( \"WARNING... Adding a new column failed to improve \" + \"the criterion!\" ) break if self . verbose : print ( f \" - Added { X_work . columns [ best_column ] } for \" + f \"criterion= { best_crit } \" ) self . kept_columns = np . append ( self . kept_columns , best_column ) nkept += 1 if self . method == 'refined' : best_crit , crit_matrix = \\ spbr_nb ( self . covar . values , self . kept_columns ) max_crit = np . max ( crit_matrix ) if max_crit > best_crit : refined_idxs = np . argwhere ( crit_matrix == max_crit ) old_col_idx = refined_idxs [ 0 , 0 ] new_col_idx = refined_idxs [ 0 , 1 ] old_col_name = \\ X_work . columns [ self . kept_columns [ old_col_idx ]] new_col_name = X_work . columns [ new_col_idx ] if self . verbose : print ( f \" - Replaced { old_col_name } with \" + f \" { new_col_name } to get criterion = { max_crit } \" ) self . kept_columns [ old_col_idx ] = new_col_idx else : if self . verbose : print ( f \" - no refinement needed\" ) self . kept_column_names = \\ X_work . columns [ self . kept_columns ] . to_list () if self . method == 'ordered' : # The values stored in 'B' are the coefficients of the 'kept_columns' # that can be used to produce out-of-sample components based on the # 'ordered' FSCA process. # These components are approximately orthogonal. # They are listed in decreasing order of variance capture by the variables # The order of the variables is independent of the user's choice in the # number of variables to compute although the coefficients may vary somewhat # according to the number of components. B = self . _calculate_ordered_coefficients ( X ) # Create a DataFrame linking the coefficents in B to the kept columns # as well as the components comp_col_names = \\ [ f 'FSCA_ORD_C { i } ' for i in range ( len ( self . kept_column_names ))] self . weights = \\ pd . DataFrame ( B , index = self . kept_column_names , columns = comp_col_names ) else : ############################## ## self.method == 'refined' ## ############################## self . _calculate_refined_coefficients ( X ) return self","title":"fit()"},{"location":"screeners/fsca/#narrowgate.screeners.fsca.base.FSCA.transform","text":"transform ( X ) Transforms pandas DataFrame, X , by returning the components calculated during fit method execution. Returns: Type Description pd.DataFrame pandas DataFrame of FSCA components Parameters: Name Type Description Default X pd . DataFrame pandas DataFrame to transform required Source code in narrowgate/screeners/fsca/base.py 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 def transform ( self , X : pd . DataFrame ) -> pd . DataFrame : \"\"\" Transforms pandas DataFrame, `X`, by returning the components calculated during `fit` method execution. Returns ------- pd.DataFrame : pandas DataFrame of FSCA components Parameters ---------- X : pandas DataFrame to transform \"\"\" # confirm number of columns are the same as what was 'fit' assert ( X . shape [ 1 ] == self . mean . shape [ 0 ]) if self . method == 'pca' : output = self . _pca_transform ( X ) elif self . method == 'ordered' : output = self . _ordered_transform ( X ) else : # self.method = 'refined' output = self . _refined_transform ( X ) return output","title":"transform()"},{"location":"screeners/fsca/#narrowgate.screeners.fsca.base.FSCA.cluster","text":"cluster ( cluster_type = \"centroid\" , min_clusters = 2 , max_clusters = None , metric = \"silhouette\" , verbose = False , ) Method for clustering variables into similar subspaces. Utilizes principal components, hierarchical clustering, and a clustering metric in order to determine optimal number of clusters/subspacess in the data set. Requires that fit method be called prior to execution as a dependency exists on the instance member pc_factors . Utilizes n_components when determining the clusters. Parameters: Name Type Description Default cluster_type str string indicating the clustering type to use. Options: \"centroid\" - recalculates component centroids for cluster as each new variable is added to cluster (preferred). \"other\" - uses component values of dominant variable in cluster as centroid. In other words, the component values of the first variable selected into the cluster determine the cluster centroid for the cluster even as new variables are added to the cluster. 'centroid' min_clusters int minimum number of clusters to consider when determining the optimal number of clusters 2 max_clusters Optional [ int ] maximum number of clusters to consider when determining the optimal number of clusters. This number should be less than the number of components present in pc_factors and greater than min_clusters None metric str cluster metric to use when determining the optimal number of clusters. Options include: \"silhouette\" 'silhouette' verbose bool boolean flag for indicating whether progress updates on method execution should be reported to the user via the console. False Attributes: Name Type Description clusters pd.Series pandas Series that contains the name of the variable as the index and the cluster number for that variable as the value.","title":"cluster()"},{"location":"screeners/fsca/#narrowgate.screeners.fsca.base.FSCA.cluster--references","text":"Source code in narrowgate/screeners/fsca/base.py 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 def cluster ( self , cluster_type : str = 'centroid' , min_clusters : int = 2 , max_clusters : Optional [ int ] = None , metric : str = 'silhouette' , verbose : bool = False ): \"\"\" Method for clustering variables into similar subspaces. Utilizes principal components, hierarchical clustering, and a clustering metric in order to determine optimal number of clusters/subspacess in the data set. Requires that `fit` method be called prior to execution as a dependency exists on the instance member `pc_factors`. Utilizes `n_components` when determining the clusters. Parameters ---------- cluster_type : string indicating the clustering type to use. Options: **\"centroid\"** - recalculates component centroids for cluster as each new variable is added to cluster (preferred). **\"other\"** - uses component values of dominant variable in cluster as centroid. In other words, the component values of the first variable selected into the cluster determine the cluster centroid for the cluster even as new variables are added to the cluster. min_clusters : minimum number of clusters to consider when determining the optimal number of clusters max_clusters : maximum number of clusters to consider when determining the optimal number of clusters. This number should be less than the number of components present in `pc_factors` and greater than `min_clusters` metric : cluster metric to use when determining the optimal number of clusters. Options include: **\"silhouette\"** verbose : boolean flag for indicating whether progress updates on method execution should be reported to the user via the console. Attributes ---------- clusters : pd.Series pandas Series that contains the name of the variable as the index and the cluster number for that variable as the value. References ---------- \"\"\" from ._cluster import cluster_variables from ...utils.cluster import silhouette_nb , find_optimal_cluster from statistics import mode assert isinstance ( min_clusters , int ) check_is_fitted ( self , 'pc_factors' ) # If max_clusters is None, then set to the number of components n_pc_factors = self . pc_factors . shape [ 1 ] if max_clusters is None : max_clusters = n_pc_factors else : assert isinstance ( max_clusters , int ) assert max_clusters > min_clusters assert max_clusters <= n_pc_factors print ( \"Performing hierarchical clustering ...\" ) cluster_results = self . _cluster_variables ( cluster_type , verbose ) print ( \"Calculating clustering performance ...\" ) factors = self . pc_factors . iloc [:,: self . n_components ] sil_list = dict () count = 0 for name , result_iter in reversed ( cluster_results . items ()): count += 1 if count >= min_clusters and count <= max_clusters : try : silhouette , dist , cluster_dist = \\ silhouette_nb ( factors . values , result_iter [ 'cluster_id' ], result_iter [ 'n_in_group' ], result_iter [ 'centroids' ] . values ) sil_mean = np . mean ( silhouette ) sil_list [ name ] = sil_mean except : pass elif count > max_clusters : break print ( \"Selecting optimal cluster ...\" ) sil_cluster_values = list ( sil_list . values ()) best_iter_list = [] for i in range ( 2 , 20 ): best_iter , best_score = \\ find_optimal_cluster ( sil_cluster_values , max_since_best_iter = i ) best_iter_list . append ( best_iter ) n_clusters_optimal = str ( mode ( best_iter_list )) optimal_cluster_membership = \\ cluster_results [ n_clusters_optimal ][ 'cluster_id' ] self . clusters = \\ pd . Series ( optimal_cluster_membership , index = self . pc_factors . index , name = 'cluster_id' ) if verbose : print ( \"Complete.\" )","title":"References"},{"location":"screeners/fsca/#narrowgate.screeners.fsca.base.FSCA._calculate_ordered_coefficients","text":"_calculate_ordered_coefficients ( X ) Class method called when method='ordered' Computes components of input data, X with no backward refinement. The columns used in creating the components are strictly ordered by variable. Variables ara added in order of increasing ability to reconstruct the dataset, and no variable replacement is performed. The implication is that the components are independent of the number of components requested by the user. Also, the first component will be the first variable selected (that having maximum mean squared correlation). The second component will be the second variable with the projection of the first variable removed. In general, each component will be that variable (in the order selected) with the contributions of all prior variables removed via a Gram-Schmidt orthogonalization process. Source code in narrowgate/screeners/fsca/base.py 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 def _calculate_ordered_coefficients ( self , X ): \"\"\" Class method called when `method='ordered'` Computes components of input data, `X` with no backward refinement. The columns used in creating the components are strictly ordered by variable. Variables ara added in order of increasing ability to reconstruct the dataset, and no variable replacement is performed. The implication is that the components are independent of the number of components requested by the user. Also, the first component will be the first variable selected (that having maximum mean squared correlation). The second component will be the second variable with the projection of the first variable removed. In general, each component will be that variable (in the order selected) with the contributions of all prior variables removed via a Gram-Schmidt orthogonalization process. \"\"\" # confirm that 'kept_column_names' are present in 'data' assert all ([ col in X . columns for col in self . kept_column_names ]) n_cases = X . shape [ 0 ] # At this point, the best subset of nkept = n_components predictors # have been found. # Regardless of whether method = 'ordered' or 'refined', # we will need the outer product Z'Z in covar. # Compute it now. covar = X [ self . kept_column_names ] . cov () # original code has n_cases populating the diagonal for the ordered # coefficients calculation. The 'refined' calculation uses the # covariance matrix as-is. np . fill_diagonal ( covar . values , n_cases ) # Compute and save the components for the entire dataset. output = gram_schmidt_nb ( X [ self . kept_column_names ] . values ) # GramSchmidt leaves the columns unit length # we want their sum of squares to be n_cases so that they have # unit standard deviation. output *= np . sqrt ( n_cases ) # 'output' contains the orthogonalized kept variables. # We could just use these as the created variables, but that would make # it impossible to create corresponding OOS variables. # Plus, many users want to see how to compute the components from the # selected variables. So we use simple linear regression to find the # coefficients. # Rather than using a sophisticated method, which would be overkill, we # just use the simple matrix inversion method. # In keeping with the notation in the paper, we define: # Z - n_cases by nkept matrix of variables selected above # M - n_cases by nkept matrix of computed components # We now wish to find the weight matrix B that will let us compute # M from Z by a simple linear transformation: # M = Z B # The well-known least-squares solution to this problem is: # -1 # B = (Z'Z) Z' M # Because the Gram-Schmidt process is a linear transformation, # these predicted values will also be orthogonal (except for minor fpt # error). # Invert Z'Z (in covar). It should always be invertible (nonsingular) # because a long time ago we computed n_unique, the rank of the # full data matrix, and reduced n_components to that value if needed. # Then, when the n_components subset of variables was selected, the # algorithm by design favored selecting variables most independent # of those already selected. work_inv = np . linalg . inv ( covar ) # We now have the inverse of Z'Z in 'work_inv' # Compute Z'M Z_prime_M = \\ np . dot ( np . transpose ( X [ self . kept_column_names ] . values ), output ) # Last step: Multiply those two matrices to get B, the coefficients. B = np . dot ( work_inv , Z_prime_M ) return B","title":"_calculate_ordered_coefficients()"},{"location":"screeners/fsca/#narrowgate.screeners.fsca.base.FSCA._calculate_refined_coefficients","text":"_calculate_refined_coefficients ( X ) Class method called when method='refined' The order of variable selection is changed by refinement in which case the principal components of the selected variables are calculated. This method produces additional 'refined' members of the class that correspond to the: - eigenvalues - eigenvectors - cumulative explained variance of each component - correlations of selected variables to each component In addition, the weights of variables for each component are calculated according to the recommendation on page 51 of the reference text by Masters. The class member component_correlations_refined is a pandas DataFrame whose values correspond to the correlations and the component represented in the given column Source code in narrowgate/screeners/fsca/base.py 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 def _calculate_refined_coefficients ( self , X ): \"\"\" Class method called when `method='refined'` The order of variable selection is changed by refinement in which case the principal components of the selected variables are calculated. This method produces additional 'refined' members of the class that correspond to the: - eigenvalues - eigenvectors - cumulative explained variance of each component - correlations of selected variables to each component In addition, the weights of variables for each component are calculated according to the recommendation on page 51 of the reference text by Masters. The class member `component_correlations_refined` is a pandas DataFrame whose values correspond to the correlations and the component represented in the given column \"\"\" # confirm that 'kept_column_names' are present in 'data' assert all ([ col in X . columns for col in self . kept_column_names ]) # Compute the outer product Z'Z in covar. covar = X [ self . kept_column_names ] . cov () # Compute the eigenstructure of the correlation matrix of selected columns self . eigvals_refined , self . eigvecs_refined = np . linalg . eig ( covar ) # numpy doesn't guarantee ordered eigenvalues. # order them along with their respective eigenvectors eig_sort_idx = np . argsort ( self . eigvals_refined )[:: - 1 ] sort_idx = np . argsort ( self . eigvals_refined )[:: - 1 ] self . eigvals_refined = self . eigvals_refined [ eig_sort_idx ] self . eigvecs_refined = self . eigvecs_refined [:, eig_sort_idx ] # Account for any negative eigenvalues neg_eigval_mask = self . eigvals_refined < 0 self . eigvals_refined [ neg_eigval_mask ] = 0 # Use self.n_unique_eigval which was calculated earlier in 'fit' self . eigval_cum_refined = \\ 100 * np . cumsum ( self . eigvals_refined ) / self . n_unique_eigval ############################################################ ## Eigenvector and Principal Component Factor DataFrames ## ############################################################ if isinstance ( X , pd . DataFrame ): n_comps = self . eigvecs_refined . shape [ 1 ] col_names = [ f 'FSCA_REF_PC { i } ' for i in range ( n_comps )] self . eigvecs_refined = \\ pd . DataFrame ( self . eigvecs_refined , index = self . kept_column_names , columns = col_names ) self . component_correlations_refined = \\ np . multiply ( self . eigvecs_refined , np . sqrt ( self . eigvals_refined )) # Calculate the weights for computing the component standardized to # unit variance. self . weights = \\ np . divide ( self . component_correlations_refined , self . eigvals_refined + 1.e-60 )","title":"_calculate_refined_coefficients()"},{"location":"screeners/fsca/#narrowgate.screeners.fsca.base.FSCA._ordered_transform","text":"_ordered_transform ( data ) Out-of-sample transformation of data when method='ordered' Based on 'B' matrix Source code in narrowgate/screeners/fsca/base.py 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 def _ordered_transform ( self , data ): \"\"\" Out-of-sample transformation of data when `method='ordered'` Based on 'B' matrix \"\"\" # confirm that 'kept_column_names' are present in 'data' assert all ([ col in data . columns for col in self . kept_column_names ]) X = data [ self . kept_column_names ] - self . mean [ self . kept_column_names ] if self . standardize : X /= self . std [ self . kept_column_names ] components = X . dot ( self . weights ) return components","title":"_ordered_transform()"},{"location":"screeners/fsca/#narrowgate.screeners.fsca.base.FSCA._refined_transform","text":"_refined_transform ( data ) Out-of-sample transformation of data when method='refined' Based on Principal Component Factors Source code in narrowgate/screeners/fsca/base.py 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 def _refined_transform ( self , data ): \"\"\" Out-of-sample transformation of data when `method='refined'` Based on Principal Component Factors \"\"\" # confirm that 'kept_column_names' are present in 'data' assert all ([ col in data . columns for col in self . kept_column_names ]) X = data [ self . kept_column_names ] - self . mean [ self . kept_column_names ] if self . standardize : X /= self . std [ self . kept_column_names ] components = X . dot ( self . weights ) return components","title":"_refined_transform()"},{"location":"screeners/fsca/#narrowgate.screeners.fsca.base.FSCA._pca_transform","text":"_pca_transform ( data ) Out-of-sample transformation of data when method='pca' Based on standard Principal Component Analysis Source code in narrowgate/screeners/fsca/base.py 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 def _pca_transform ( self , data ): \"\"\" Out-of-sample transformation of data when `method='pca'` Based on standard Principal Component Analysis \"\"\" # Center and/or standardize according to what was done in fit X = data - self . mean if self . standardize : X /= self . std # Calculate the principal components for each observation components = X . dot ( self . eigvecs . divide ( np . sqrt ( self . eigvals ))) return components","title":"_pca_transform()"},{"location":"screeners/fsca_selector/","text":"FSCASelector \u00a4 FSCASelector ( ** kwargs ) Bases: FSCA , SelectorMixin FSCA Feature Selector class. A class instance requires the same parameters as an FSCA instance. Implements get_feature_names_out and _get_support_mask functionality for use as SelectorMixin . Source code in narrowgate/screeners/fsca/selector.py 16 17 def __init__ ( self , ** kwargs ): super ( FSCA ) . __init__ ( ** kwargs ) get_feature_names_out \u00a4 get_feature_names_out ( input_features = None ) Get output feature names, i.e. the names of the components computed during the call to fit method Returns: Name Type Description feature_names_out ndarray of str objects Names of columns that were selected during FSCA fit Source code in narrowgate/screeners/fsca/selector.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def get_feature_names_out ( self , input_features = None ): \"\"\" Get output feature names, i.e. the names of the components computed during the call to `fit` method Returns ------- feature_names_out : ndarray of str objects Names of columns that were selected during FSCA `fit` \"\"\" check_is_fitted ( self , 'kept_column_names' ) return np . asarray ( self . kept_column_names , dtype = object )","title":"FSCASelector"},{"location":"screeners/fsca_selector/#narrowgate.screeners.FSCASelector","text":"FSCASelector ( ** kwargs ) Bases: FSCA , SelectorMixin FSCA Feature Selector class. A class instance requires the same parameters as an FSCA instance. Implements get_feature_names_out and _get_support_mask functionality for use as SelectorMixin . Source code in narrowgate/screeners/fsca/selector.py 16 17 def __init__ ( self , ** kwargs ): super ( FSCA ) . __init__ ( ** kwargs )","title":"FSCASelector"},{"location":"screeners/fsca_selector/#narrowgate.screeners.fsca.selector.FSCASelector.get_feature_names_out","text":"get_feature_names_out ( input_features = None ) Get output feature names, i.e. the names of the components computed during the call to fit method Returns: Name Type Description feature_names_out ndarray of str objects Names of columns that were selected during FSCA fit Source code in narrowgate/screeners/fsca/selector.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def get_feature_names_out ( self , input_features = None ): \"\"\" Get output feature names, i.e. the names of the components computed during the call to `fit` method Returns ------- feature_names_out : ndarray of str objects Names of columns that were selected during FSCA `fit` \"\"\" check_is_fitted ( self , 'kept_column_names' ) return np . asarray ( self . kept_column_names , dtype = object )","title":"get_feature_names_out()"},{"location":"screeners/fsca_transformer/","text":"FSCATransformer \u00a4 FSCATransformer ( ** kwargs ) Bases: FSCA , TransformerMixin FSCA Feature Transformer class. An instance of this class requires the same parameters required for an FSCA instance. Utilizes the fit method in the FSCA base class to fit a data set and then the transform method within the base class to transform the dataset to the n_components determined in the fit method. NOTE: The transform method will return the desired number of principal components as the transformation. For the variables selected which comprise these components, please see the FSCASelector class. Intended for use within scikit-learn's Pipeline functionality. Source code in narrowgate/screeners/fsca/transformer.py 27 28 def __init__ ( self , ** kwargs ): super ( FSCA ) . __init__ ( ** kwargs )","title":"FSCATransformer"},{"location":"screeners/fsca_transformer/#narrowgate.screeners.FSCATransformer","text":"FSCATransformer ( ** kwargs ) Bases: FSCA , TransformerMixin FSCA Feature Transformer class. An instance of this class requires the same parameters required for an FSCA instance. Utilizes the fit method in the FSCA base class to fit a data set and then the transform method within the base class to transform the dataset to the n_components determined in the fit method. NOTE: The transform method will return the desired number of principal components as the transformation. For the variables selected which comprise these components, please see the FSCASelector class. Intended for use within scikit-learn's Pipeline functionality. Source code in narrowgate/screeners/fsca/transformer.py 27 28 def __init__ ( self , ** kwargs ): super ( FSCA ) . __init__ ( ** kwargs )","title":"FSCATransformer"},{"location":"screeners/hmm_memory/","text":"HMMMemoryScreener \u00a4 HMMMemoryScreener ( nvars = 2 , nstates = 3 , n_init = 1000 , max_iter = 100 ) Hidden Markov Model Memory screening class Assesses whether sets of feature variables (columns) have memory that can be explained by a hidden Markov model. If a hidden Markov model is found to be meaningfully linked to a target variable (via HMMTargetLinkScreener ), but is found to NOT have meaningful (i.e. non-random) memory via the results of this class, then any target variable linkage results should almost certainly be discarded. Execution Recommendations \u00a4 The execution of this class takes an extremely long time as it involves fitting numerous hidden Markov models. The number of models to be fit can be calculated by: number of feature/column combinations * number of MCPT reps Even though the models are fit in parallel, the time to evaluate a single model can be upwards of several minutes. As a result, only a small number of variable combinations should be attempted with this class at any given time. It is recommended that HMMTargetLinkScreener be run first on a larger number of variables, and then, only the variables from the top models found during that screening process be used with this screening method to determine if the hidden Markov model has memory that can truly be considered meaningful. References \u00a4 Masters, Timothy. (2019) \"Extracting and Selecting Features for Data Mining: Algorithms in C++ and CUDA\". pp. 159-163. Hidden Markov model requires a minimum of 2 variables to be used when creating the model ( nvars ). The underlying HMM models are constructed using the HMM_nb class. For more information about the actual model construction, please refer to this class. Parameters: Name Type Description Default nvars int number of features/columns to combine when constructing a hidden Markov model. 2 nstates int The number of hidden states for the model to posit. More than 3 to 4 states can produce highly unstable results 3 n_init int Number of initial trial parameter sets to test for finding a good stating point for iteration. Larger values make it more likely that the iterations, which always converge to a local optimum, will find the global optimum. (a minimum of 1000 is recommended by Masters with a value of 10,000 not being unreasonable). 1000 max_iter int The number of iterations to perform for finding the maximum likelihood parameters of the model. If the model converges prior to this number, early stopping will occur. If the method completes and the return value of n_iter is max_iter-1 , then complete convergence was not obtained. 100 Source code in narrowgate/screeners/hmm/memory.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def __init__ ( self , nvars : int = 2 , nstates : int = 3 , n_init : int = 1000 , max_iter : int = 100 ): \"\"\" Hidden Markov model requires a minimum of 2 variables to be used when creating the model (`nvars`). The underlying HMM models are constructed using the [HMM_nb][narrowgate.model.hmm.HMM_nb] class. For more information about the actual model construction, please refer to this class. Parameters ---------- nvars : number of features/columns to combine when constructing a hidden Markov model. nstates : The number of hidden states for the model to posit. More than 3 to 4 states can produce highly unstable results n_init : Number of initial trial parameter sets to test for finding a good stating point for iteration. Larger values make it more likely that the iterations, which always converge to a local optimum, will find the global optimum. (a minimum of 1000 is recommended by Masters with a value of 10,000 not being unreasonable). max_iter : The number of iterations to perform for finding the maximum likelihood parameters of the model. If the model converges prior to this number, early stopping will occur. If the method completes and the return value of `n_iter` is `max_iter-1`, then complete convergence was not obtained. \"\"\" assert ( nvars > 1 ) assert ( nstates > 1 ) assert ( n_init > 0 ) assert ( max_iter > 0 ) self . nvars = nvars self . nstates = nstates self . n_init = n_init self . max_iter = max_iter self . results = None screen \u00a4 screen ( X , nreps = 100 ) Method that executes the MCPT evaluation of all variable combinations of size 'nvars'. NaN values must not be present in 'X'. Parameters: Name Type Description Default X pd . DataFrame required Source code in narrowgate/screeners/hmm/memory.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def screen ( self , X : pd . DataFrame , nreps : int = 100 ): \"\"\" Method that executes the MCPT evaluation of all variable combinations of size 'nvars'. NaN values must not be present in 'X'. Parameters ---------- X : \"\"\" assert ( nreps >= 0 ) if nreps == 0 : self . nreps = 1 else : self . nreps = nreps # confirm that X is a DataFrame in order to use # column names when returning results. # confirm that there are no NA values in X na_mask = X . isna () . any () . values if any ( na_mask ): raise ValueError ( \"'NaN' values present in the following \" + f \"columns: { X . columns [ na_mask ] } \" ) # obtain all the column combinations cols = X . columns col_idx_array = np . arange ( len ( cols )) col_idx_combos = \\ [ i for i in itertools . combinations ( col_idx_array , self . nvars )] col_idx_combos = np . array ( col_idx_combos ) crits = \\ evaluate_hmm_var_combos_nb ( X . values , col_idx_combos , self . nstates , self . n_init , self . max_iter , self . nreps ) # calculate the p-values for each one of the combos # the number of combos is the number of rows in crits # the number of mcpt_reps is the number of columns in crits count_matrix = crits >= crits [:, 0 ] . reshape ( - 1 , 1 ) p_value_arr = np . sum ( count_matrix , axis = 1 ) / self . nreps # replace the numbers in 'combos' with the column names # and save them with the P_value_arr results combo_cols = \\ np . split ( np . array ( [ cols [ i ] for combo in col_idx_combos for i in combo ]), len ( col_idx_combos )) combo_cols = [ combo . tolist () for combo in combo_cols ] self . results = list ( zip ( combo_cols , p_value_arr ))","title":"HMMMemoryScreener"},{"location":"screeners/hmm_memory/#narrowgate.screeners.HMMMemoryScreener","text":"HMMMemoryScreener ( nvars = 2 , nstates = 3 , n_init = 1000 , max_iter = 100 ) Hidden Markov Model Memory screening class Assesses whether sets of feature variables (columns) have memory that can be explained by a hidden Markov model. If a hidden Markov model is found to be meaningfully linked to a target variable (via HMMTargetLinkScreener ), but is found to NOT have meaningful (i.e. non-random) memory via the results of this class, then any target variable linkage results should almost certainly be discarded.","title":"HMMMemoryScreener"},{"location":"screeners/hmm_memory/#narrowgate.screeners.HMMMemoryScreener--execution-recommendations","text":"The execution of this class takes an extremely long time as it involves fitting numerous hidden Markov models. The number of models to be fit can be calculated by: number of feature/column combinations * number of MCPT reps Even though the models are fit in parallel, the time to evaluate a single model can be upwards of several minutes. As a result, only a small number of variable combinations should be attempted with this class at any given time. It is recommended that HMMTargetLinkScreener be run first on a larger number of variables, and then, only the variables from the top models found during that screening process be used with this screening method to determine if the hidden Markov model has memory that can truly be considered meaningful.","title":"Execution Recommendations"},{"location":"screeners/hmm_memory/#narrowgate.screeners.HMMMemoryScreener--references","text":"Masters, Timothy. (2019) \"Extracting and Selecting Features for Data Mining: Algorithms in C++ and CUDA\". pp. 159-163. Hidden Markov model requires a minimum of 2 variables to be used when creating the model ( nvars ). The underlying HMM models are constructed using the HMM_nb class. For more information about the actual model construction, please refer to this class. Parameters: Name Type Description Default nvars int number of features/columns to combine when constructing a hidden Markov model. 2 nstates int The number of hidden states for the model to posit. More than 3 to 4 states can produce highly unstable results 3 n_init int Number of initial trial parameter sets to test for finding a good stating point for iteration. Larger values make it more likely that the iterations, which always converge to a local optimum, will find the global optimum. (a minimum of 1000 is recommended by Masters with a value of 10,000 not being unreasonable). 1000 max_iter int The number of iterations to perform for finding the maximum likelihood parameters of the model. If the model converges prior to this number, early stopping will occur. If the method completes and the return value of n_iter is max_iter-1 , then complete convergence was not obtained. 100 Source code in narrowgate/screeners/hmm/memory.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def __init__ ( self , nvars : int = 2 , nstates : int = 3 , n_init : int = 1000 , max_iter : int = 100 ): \"\"\" Hidden Markov model requires a minimum of 2 variables to be used when creating the model (`nvars`). The underlying HMM models are constructed using the [HMM_nb][narrowgate.model.hmm.HMM_nb] class. For more information about the actual model construction, please refer to this class. Parameters ---------- nvars : number of features/columns to combine when constructing a hidden Markov model. nstates : The number of hidden states for the model to posit. More than 3 to 4 states can produce highly unstable results n_init : Number of initial trial parameter sets to test for finding a good stating point for iteration. Larger values make it more likely that the iterations, which always converge to a local optimum, will find the global optimum. (a minimum of 1000 is recommended by Masters with a value of 10,000 not being unreasonable). max_iter : The number of iterations to perform for finding the maximum likelihood parameters of the model. If the model converges prior to this number, early stopping will occur. If the method completes and the return value of `n_iter` is `max_iter-1`, then complete convergence was not obtained. \"\"\" assert ( nvars > 1 ) assert ( nstates > 1 ) assert ( n_init > 0 ) assert ( max_iter > 0 ) self . nvars = nvars self . nstates = nstates self . n_init = n_init self . max_iter = max_iter self . results = None","title":"References"},{"location":"screeners/hmm_memory/#narrowgate.screeners.hmm.memory.HMMMemoryScreener.screen","text":"screen ( X , nreps = 100 ) Method that executes the MCPT evaluation of all variable combinations of size 'nvars'. NaN values must not be present in 'X'. Parameters: Name Type Description Default X pd . DataFrame required Source code in narrowgate/screeners/hmm/memory.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def screen ( self , X : pd . DataFrame , nreps : int = 100 ): \"\"\" Method that executes the MCPT evaluation of all variable combinations of size 'nvars'. NaN values must not be present in 'X'. Parameters ---------- X : \"\"\" assert ( nreps >= 0 ) if nreps == 0 : self . nreps = 1 else : self . nreps = nreps # confirm that X is a DataFrame in order to use # column names when returning results. # confirm that there are no NA values in X na_mask = X . isna () . any () . values if any ( na_mask ): raise ValueError ( \"'NaN' values present in the following \" + f \"columns: { X . columns [ na_mask ] } \" ) # obtain all the column combinations cols = X . columns col_idx_array = np . arange ( len ( cols )) col_idx_combos = \\ [ i for i in itertools . combinations ( col_idx_array , self . nvars )] col_idx_combos = np . array ( col_idx_combos ) crits = \\ evaluate_hmm_var_combos_nb ( X . values , col_idx_combos , self . nstates , self . n_init , self . max_iter , self . nreps ) # calculate the p-values for each one of the combos # the number of combos is the number of rows in crits # the number of mcpt_reps is the number of columns in crits count_matrix = crits >= crits [:, 0 ] . reshape ( - 1 , 1 ) p_value_arr = np . sum ( count_matrix , axis = 1 ) / self . nreps # replace the numbers in 'combos' with the column names # and save them with the P_value_arr results combo_cols = \\ np . split ( np . array ( [ cols [ i ] for combo in col_idx_combos for i in combo ]), len ( col_idx_combos )) combo_cols = [ combo . tolist () for combo in combo_cols ] self . results = list ( zip ( combo_cols , p_value_arr ))","title":"screen()"},{"location":"screeners/hmm_target/","text":"HMMTargetLinkScreener \u00a4 HMMTargetLinkScreener ( nvars = 2 , nstates = 3 , n_init = 1000 , max_iter = 100 ) Hidden Markov Model Target-Linked screening class. Rather than using raw feature values as inputs to a predictive model like UnivariateScreener and BivariateScreener , this screener attempts to use the underlying state of the feature-generating process as input to a model attempting to predict a target variable. The 'state' mentioned above is produced by a hidden Markov model which presents a set of multiple state probabilities at each observation. These state probabilities attempt to properly identify the likelihood of the features (and resulting model) being in one state versus another. The number of potential states is posited by the user as an input parameter to the screener ( nstates ). These states can ultimately be thought of as impacting the distribution of the associated raw features used as input data into the hidden Markov model. The execution steps for this screener are as follows: Hidden Markov model is fit to one or more sets of features independent of the target variable The matrix of state probabilities from above are fit to a target variable with a Linear Regression model Monte Carlo Permutation testing is performed with a Linear regression model using the original state probabilities and a permuted target variable. A null hypothesis test is performed against a random relationship existing between the states and the target variable. References \u00a4 Masters, Timothy. (2019) \"Extracting and Selecting Features for Data Mining: Algorithms in C++ and CUDA\". pp. 164-188. Hidden Markov Model requires a minimum of 2 variables and 2 states to be used when creating the model. Parameters: Name Type Description Default nvars int number of features/columns to combine when constructing a hidden Markov model. Must be 2 or greater. Recommend value : 2 to 5 2 nstates int The number of hidden states for the model to posit. Must be greater than or equal to 2. More than 4 states can produce unstable results. 3 n_init int Number of initial trial parameter sets to test for finding a good stating point to begin model convergence. Larger values make it more likely that the iterations, which always converge to a local optimum, will find the global optimum. Recommended: minimum of 1000 with a value of 10,000 not being unreasonable. 1000 max_iter int The number of iterations to perform for finding the maximum likelihood parameters of the model. If the model converges prior to this number, early stopping will occur. If the method completes and the return value of n_iter is max_iter-1 , then complete convergence was not obtained. 100 Source code in narrowgate/screeners/hmm/target_link.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 def __init__ ( self , nvars : int = 2 , nstates : int = 3 , n_init : int = 1000 , max_iter : int = 100 ): \"\"\" Hidden Markov Model requires a minimum of 2 variables and 2 states to be used when creating the model. Parameters ---------- nvars : number of features/columns to combine when constructing a hidden Markov model. Must be 2 or greater. Recommend value : 2 to 5 nstates : The number of hidden states for the model to posit. Must be greater than or equal to 2. More than 4 states can produce unstable results. n_init : Number of initial trial parameter sets to test for finding a good stating point to begin model convergence. Larger values make it more likely that the iterations, which always converge to a local optimum, will find the global optimum. Recommended: minimum of 1000 with a value of 10,000 not being unreasonable. max_iter : The number of iterations to perform for finding the maximum likelihood parameters of the model. If the model converges prior to this number, early stopping will occur. If the method completes and the return value of `n_iter` is `max_iter-1`, then complete convergence was not obtained. \"\"\" assert nvars > 1 , \"'nvars' parameter must be > 1\" assert nstates > 1 , \"'n_states' parameter must be > 1\" assert n_init > 0 , \"'n_init' parameter must be > 0\" assert max_iter > 0 , \"'max_iter' parameter must be > 0\" self . nstates = nstates self . n_init = n_init self . max_iter = max_iter self . nvars = nvars self . model_cols = None self . state_probs_mat = None self . transition_mat = None self . crits = None self . solo_pval = None self . unbiased_pval = None screen \u00a4 screen ( X , y , nreps , mcpt_type = 'complete' ) Method that performs the target-linked screening of the hidden Markov model states produced by the feature combinations. Executes the Monte Carlo Permutation testing as part of the evaluation Warning \u00a4 NaN values must not be present in 'X'. Parameters: Name Type Description Default X pd . DataFrame pandas DataFrame of time series features to combine when estimating hidden Markov models. Must NOT contain NaN values required y pd . Series pandas Series containing the target values to predict. required nreps int number of Monte Carlo permutation testing repititions to peform required mcpt_type str Valid options: \"complete\" \"cyclic\" Type of permutation to perform on the target variable when evaluating the confidence that a predictor variable's relationship with the target variable is non-random in nature. \"complete\" : shuffles the target variable values \"cyclic\" : used when target variable possesses serial correlation. Chooses a random row and copies the original target variable values in sequence beginning at this row. Excess target values are then 'wrapped' to first row in the dataset such that the last original target variable value will be located in the position just prior to the chosen random row. \"complete\" Attributes: Name Type Description state_probs_mat np.ndarray numpy matrix containing the state probabilities of all possible feature/variable combinations transition_mat np.ndarray numpy matrix containing the state transition matrics of each HMM produced by a feature/variable combination. crits np.ndarray Multiple-R value of state probabiliites regressed on target variable for each HMM model. solo_pval np.ndarray a biased p-value from MCPT testing only considering criteria produced by target randomization of a single feature set unbiased_pval np.ndarray an unbiased p-value from MCPT testing using criteria produced by target randomization of all feature sets. Source code in narrowgate/screeners/hmm/target_link.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 def screen ( self , X : pd . DataFrame , y : pd . Series , nreps : int , mcpt_type : str = 'complete' ): \"\"\" Method that performs the target-linked screening of the hidden Markov model states produced by the feature combinations. Executes the Monte Carlo Permutation testing as part of the evaluation ### Warning NaN values must not be present in 'X'. Parameters ---------- X : pandas DataFrame of time series features to combine when estimating hidden Markov models. **Must NOT contain NaN values** y : pandas Series containing the target values to predict. nreps : number of Monte Carlo permutation testing repititions to peform mcpt_type : {\"complete\", \"cyclic\"} Valid options: - **\"complete\"** - **\"cyclic\"** Type of permutation to perform on the target variable when evaluating the confidence that a predictor variable's relationship with the target variable is non-random in nature. **\"complete\"**: shuffles the target variable values **\"cyclic\"**: used when target variable possesses serial correlation. Chooses a random row and copies the original target variable values in sequence beginning at this row. Excess target values are then 'wrapped' to first row in the dataset such that the last original target variable value will be located in the position just prior to the chosen random row. Attributes ---------- state_probs_mat : np.ndarray numpy matrix containing the state probabilities of all possible feature/variable combinations transition_mat : np.ndarray numpy matrix containing the state transition matrics of each HMM produced by a feature/variable combination. crits : np.ndarray Multiple-R value of state probabiliites regressed on target variable for each HMM model. solo_pval : np.ndarray a biased p-value from MCPT testing only considering criteria produced by target randomization of a single feature set unbiased_pval : np.ndarray an unbiased p-value from MCPT testing using criteria produced by target randomization of all feature sets. \"\"\" # Validate the MCPT parameters assert nreps >= 0 if nreps == 0 : self . nreps = 1 else : self . nreps = nreps assert mcpt_type in [ 'complete' , 'cyclic' ] self . mcpt_type = mcpt_type # confirm that X is a DataFrame in order to use # column names when returning results. # confirm that there are no NA values in X assert ( isinstance ( X , pd . DataFrame )) na_mask = X . isna () . any () . values if any ( na_mask ): raise ValueError ( \"'NaN' values present in the following \" + f \"columns: { X . columns [ na_mask ] } \" ) # confirm that 'y' is a pandas Series and there are no NA values assert ( isinstance ( y , pd . Series )) na_flag = y . isna () . any () if na_flag : raise ValueError ( \"'NaN' values present in 'y' (target series)\" ) # confirm that X and y have the same number of cases if not X . shape [ 0 ] == y . shape [ 0 ]: raise RuntimeError ( \"'X' and 'y' must have the same number of observations. \" + f \"( { X . shape [ 0 ] } vs. { y . shape [ 0 ] } )\" ) # obtain all the column combinations cols = X . columns col_idx_array = np . arange ( len ( cols )) col_idx_combos = \\ [ i for i in itertools . combinations ( col_idx_array , self . nvars )] col_idx_combos = np . array ( col_idx_combos ) combo_cols = \\ np . split ( np . array ( [ cols [ i ] for combo in col_idx_combos for i in combo ]), len ( col_idx_combos )) self . model_cols = [ combo . tolist () for combo in combo_cols ] # construct the hidden Markov model in parallel for each # combination. The 'state_probs' will be reused during MCPT # reps as independent variables. The 'transition' will be # used for reporting purposes. self . state_probs_mat , self . transition_mat = \\ build_hmm_models_nb ( X . values , col_idx_combos , self . nstates , self . n_init , self . max_iter ) # Once the state_probs_mat is created, it's time to run the # MCPT reps. This will require a call to another parallelized # numba function that will fit many linear regression models. self . crits , self . solo_pval , self . unbiased_pval = \\ mcpt_linreg_nb ( self . state_probs_mat , y . values , self . nreps , self . mcpt_type ) # Generate the mcpt report along with the ranking mapper self . _mcpt_report , self . _ranked_model_mapper = \\ self . _generate_mcpt_report () # Calculate the means and standard deviations of each # of the variable for each of the states for each of the models self . _means_std_report = \\ self . _generate_means_std_report ( X . values , col_idx_combos ) # prepare the transition probability matrices as DataFrames for # each of the models created. self . _transition_report = \\ self . _generate_transition_report () # prepare the correlation report for each of the models self . _target_stats_report = \\ self . _generate_target_stats_report ( y . values ) mcpt_report \u00a4 mcpt_report () Returns the MCPT report as a pandas DataFrame for all evaluated feature combinations. DataFrame includes the following information: independent variables used in the model Multiple-R of the state probabilities in relation to the target variable solo p-values unbiased p-values Source code in narrowgate/screeners/hmm/target_link.py 467 468 469 470 471 472 473 474 475 476 477 478 479 def mcpt_report ( self ): \"\"\" Returns the MCPT report as a pandas DataFrame for all evaluated feature combinations. DataFrame includes the following information: - independent variables used in the model - Multiple-R of the state probabilities in relation to the target variable - solo p-values - unbiased p-values \"\"\" return self . _mcpt_report print_model_report \u00a4 print_model_report ( result , model_rank = 'top' ) Returns the DataFrame 'report' containing the desired metrics. Parameters: Name Type Description Default result str Valid options : 'means','transitions','target' Attribute from the desired hidden Markov model to retrieve. required model_rank str Valid options : 'top','first','second','third' rank of model whose results to retrieve 'top' Source code in narrowgate/screeners/hmm/target_link.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 def print_model_report ( self , result : str , model_rank : str = 'top' ): \"\"\" Returns the DataFrame 'report' containing the desired metrics. Parameters ---------- result : Valid options : 'means','transitions','target' Attribute from the desired hidden Markov model to retrieve. model_rank : Valid options : 'top','first','second','third' rank of model whose results to retrieve \"\"\" assert ( result in [ 'means' , 'transitions' , 'target' ]) if model_rank in [ 'top' , 'first' ]: model_rank = 0 elif model_rank == 'second' : model_rank = 1 elif model_rank == 'third' : model_rank = 2 assert ( model_rank >= 1 ) if model_rank > len ( self . _ranked_model_mapper ): raise ValueError ( f \"'model_rank' parameter ( { model_rank } ) exceeds number \" + f \"of available models ( { self . _ranked_model_mapper } \" ) else : # subtract one from the 'rank' (python zero-index) model_rank -= 1 model_idx = self . _ranked_model_mapper [ model_rank ] if result == 'means' : return_df = self . _means_std_report [ model_idx ] elif result == 'transitions' : return_df = self . _transition_report [ model_idx ] elif result == 'target' : return_df = self . _target_report [ model_idx ] return return_df _generate_mcpt_report \u00a4 _generate_mcpt_report () Generate the MCPT results of the HMM Target Link evaluation. Includes the following information: independent variables used in the model Multiple-R of the state probabilities in relation to the target variable solo p-values unbiased p-values Also generates a 'mapping' object that can allow the user to easily access further details about the model given the models 'Multiple-R' rank Attributes: Name Type Description _mcpt_report: pd.DataFrame pandas DataFrame of HMM _ranked_model_mapper: list of tuples list of integers representing the indices of the variable combinations in ranked order according to Multiple-R criterion. Source code in narrowgate/screeners/hmm/target_link.py 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 def _generate_mcpt_report ( self ): \"\"\" Generate the MCPT results of the HMM Target Link evaluation. Includes the following information: - independent variables used in the model - Multiple-R of the state probabilities in relation to the target variable - solo p-values - unbiased p-values Also generates a 'mapping' object that can allow the user to easily access further details about the model given the models 'Multiple-R' rank Attributes ---------- _mcpt_report: pd.DataFrame pandas DataFrame of HMM _ranked_model_mapper: list of tuples list of integers representing the indices of the variable combinations in ranked order according to Multiple-R criterion. \"\"\" # create a list contaiing the column names for the report # the number of variables pred_col_names = \\ [ f 'Predictor_ { i + 1 } ' for i in range ( self . nvars )] pred_cols_df = \\ pd . DataFrame ( self . model_cols , columns = pred_col_names ) stats_col_names = [ 'Multiple-R' , 'Solo pval' , 'Unbiased pval' ] stats_mat = \\ np . hstack (( self . crits . reshape ( - 1 , 1 ), self . solo_pval . reshape ( - 1 , 1 ), self . unbiased_pval . reshape ( - 1 , 1 ))) stats_df = pd . DataFrame ( stats_mat , columns = stats_col_names ) # join DataFrames and sort by Multiple-R descending mcpt_report = \\ ( pd . concat ([ pred_cols_df , stats_df ], axis = 1 ) . sort_values ( by = 'Multiple-R' , ascending = False )) # The index from the above DataFrame will be the index # corresponding to the first dimension of the artifacts # returned from 'build_hmm_models_nb'. # Convert the index to the list. The index position of # this list will correspond to the rank of the model # in terms of 'Multiple-R'. ranked_model_mapper = list ( mcpt_report . index ) return mcpt_report , ranked_model_mapper _generate_means_std_report \u00a4 _generate_means_std_report ( data , col_idx_combos ) Generate the reports which provides the basic statistical information regarding each of the variables for each of the models created. This method to called from the 'evaluate' method and organizes the information from each model in DataFrame. These DataFrames can then be retrieved via the 'print_model_results' method. Source code in narrowgate/screeners/hmm/target_link.py 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 def _generate_means_std_report ( self , data : pd . DataFrame , col_idx_combos : list ): \"\"\" Generate the reports which provides the basic statistical information regarding each of the variables for each of the models created. This method to called from the 'evaluate' method and organizes the information from each model in DataFrame. These DataFrames can then be retrieved via the 'print_model_results' method. \"\"\" nmodels = len ( self . model_cols ) means , stds = \\ calculate_model_var_means ( data , col_idx_combos , self . state_probs_mat ) assert ( means . shape [ 0 ] == nmodels ) mean_std = [] for imodel in range ( nmodels ): mean_mat = means [ imodel ] index_names = \\ [ f 'state_ { i + 1 } ' for i in range ( mean_mat . shape [ 0 ])] col_names = self . model_cols [ imodel ] mean_df = \\ pd . DataFrame ( mean_mat , columns = col_names , index = index_names ) std_mat = stds [ imodel ] std_df = \\ pd . DataFrame ( std_mat , columns = col_names , index = index_names ) df = \\ pd . merge ( mean_df , std_df , left_index = True , right_index = True , suffixes = [ \"_mean\" , \"_std\" ]) mean_std . append ( df [ sorted ( df . columns )]) return mean_std _generate_transition_report \u00a4 _generate_transition_report () The raw transition matrices are transformed into DataFrames for better readability. The value in each cell represents the probability the model transitions from the row state to the column state: Row State -> Column State As a result, the sum of the values in each ROW should equal 1 . Source code in narrowgate/screeners/hmm/target_link.py 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 def _generate_transition_report ( self ): \"\"\" The raw transition matrices are transformed into DataFrames for better readability. The value in each cell represents the probability the model transitions from the row state to the column state: **Row State -> Column State** As a result, the sum of the values in each ROW should equal **1**. \"\"\" nmodels = self . transition_mat . shape [ 0 ] names = [ f 'state_ { i + 1 } ' for i in range ( self . nstates )] transition_report_list = [] for imodel in range ( nmodels ): df = pd . DataFrame ( self . transition_mat [ imodel ], columns = names , index = names ) transition_report_list . append ( df ) return transition_report_list _generate_target_stats_report \u00a4 _generate_target_stats_report ( target ) This method prepares a report (DataFrame) for each state of each model which contains the following information: Percent the percentage of cases in which the designated state has the highest probability. Correlation the correlation coefficient between the target and the membership probability for the designated state Target Mean the mean of the target when the designated state has the highest membership probability Target Standard Deviation the standard deviation of the target when the designated state has the highest membership probability Source code in narrowgate/screeners/hmm/target_link.py 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 def _generate_target_stats_report ( self , target ): \"\"\" This method prepares a report (DataFrame) for each state of each model which contains the following information: * Percent the percentage of cases in which the designated state has the highest probability. * Correlation the correlation coefficient between the target and the membership probability for the designated state * Target Mean the mean of the target when the designated state has the highest membership probability * Target Standard Deviation the standard deviation of the target when the designated state has the highest membership probability \"\"\" nmodels = self . state_probs_mat . shape [ 0 ] nstates = self . state_probs_mat . shape [ 2 ] target_stats_mat = \\ calculate_model_target_stats ( target , self . state_probs_mat ) column_names = \\ [ 'Percent' , 'Correlation' , 'Target mean' , 'Target StdDev' ] index_names = [ f 'State { i + 1 } ' for i in range ( nstates )] target_stats_list = [] for imodel in range ( nmodels ): df = pd . DataFrame ( target_stats_mat [ imodel ], columns = column_names , index = index_names ) target_stats_list . append ( df . round ( 5 )) return target_stats_list","title":"HMMTargetLinkScreener"},{"location":"screeners/hmm_target/#narrowgate.screeners.HMMTargetLinkScreener","text":"HMMTargetLinkScreener ( nvars = 2 , nstates = 3 , n_init = 1000 , max_iter = 100 ) Hidden Markov Model Target-Linked screening class. Rather than using raw feature values as inputs to a predictive model like UnivariateScreener and BivariateScreener , this screener attempts to use the underlying state of the feature-generating process as input to a model attempting to predict a target variable. The 'state' mentioned above is produced by a hidden Markov model which presents a set of multiple state probabilities at each observation. These state probabilities attempt to properly identify the likelihood of the features (and resulting model) being in one state versus another. The number of potential states is posited by the user as an input parameter to the screener ( nstates ). These states can ultimately be thought of as impacting the distribution of the associated raw features used as input data into the hidden Markov model. The execution steps for this screener are as follows: Hidden Markov model is fit to one or more sets of features independent of the target variable The matrix of state probabilities from above are fit to a target variable with a Linear Regression model Monte Carlo Permutation testing is performed with a Linear regression model using the original state probabilities and a permuted target variable. A null hypothesis test is performed against a random relationship existing between the states and the target variable.","title":"HMMTargetLinkScreener"},{"location":"screeners/hmm_target/#narrowgate.screeners.HMMTargetLinkScreener--references","text":"Masters, Timothy. (2019) \"Extracting and Selecting Features for Data Mining: Algorithms in C++ and CUDA\". pp. 164-188. Hidden Markov Model requires a minimum of 2 variables and 2 states to be used when creating the model. Parameters: Name Type Description Default nvars int number of features/columns to combine when constructing a hidden Markov model. Must be 2 or greater. Recommend value : 2 to 5 2 nstates int The number of hidden states for the model to posit. Must be greater than or equal to 2. More than 4 states can produce unstable results. 3 n_init int Number of initial trial parameter sets to test for finding a good stating point to begin model convergence. Larger values make it more likely that the iterations, which always converge to a local optimum, will find the global optimum. Recommended: minimum of 1000 with a value of 10,000 not being unreasonable. 1000 max_iter int The number of iterations to perform for finding the maximum likelihood parameters of the model. If the model converges prior to this number, early stopping will occur. If the method completes and the return value of n_iter is max_iter-1 , then complete convergence was not obtained. 100 Source code in narrowgate/screeners/hmm/target_link.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 def __init__ ( self , nvars : int = 2 , nstates : int = 3 , n_init : int = 1000 , max_iter : int = 100 ): \"\"\" Hidden Markov Model requires a minimum of 2 variables and 2 states to be used when creating the model. Parameters ---------- nvars : number of features/columns to combine when constructing a hidden Markov model. Must be 2 or greater. Recommend value : 2 to 5 nstates : The number of hidden states for the model to posit. Must be greater than or equal to 2. More than 4 states can produce unstable results. n_init : Number of initial trial parameter sets to test for finding a good stating point to begin model convergence. Larger values make it more likely that the iterations, which always converge to a local optimum, will find the global optimum. Recommended: minimum of 1000 with a value of 10,000 not being unreasonable. max_iter : The number of iterations to perform for finding the maximum likelihood parameters of the model. If the model converges prior to this number, early stopping will occur. If the method completes and the return value of `n_iter` is `max_iter-1`, then complete convergence was not obtained. \"\"\" assert nvars > 1 , \"'nvars' parameter must be > 1\" assert nstates > 1 , \"'n_states' parameter must be > 1\" assert n_init > 0 , \"'n_init' parameter must be > 0\" assert max_iter > 0 , \"'max_iter' parameter must be > 0\" self . nstates = nstates self . n_init = n_init self . max_iter = max_iter self . nvars = nvars self . model_cols = None self . state_probs_mat = None self . transition_mat = None self . crits = None self . solo_pval = None self . unbiased_pval = None","title":"References"},{"location":"screeners/hmm_target/#narrowgate.screeners.hmm.target_link.HMMTargetLinkScreener.screen","text":"screen ( X , y , nreps , mcpt_type = 'complete' ) Method that performs the target-linked screening of the hidden Markov model states produced by the feature combinations. Executes the Monte Carlo Permutation testing as part of the evaluation","title":"screen()"},{"location":"screeners/hmm_target/#narrowgate.screeners.hmm.target_link.HMMTargetLinkScreener.screen--warning","text":"NaN values must not be present in 'X'. Parameters: Name Type Description Default X pd . DataFrame pandas DataFrame of time series features to combine when estimating hidden Markov models. Must NOT contain NaN values required y pd . Series pandas Series containing the target values to predict. required nreps int number of Monte Carlo permutation testing repititions to peform required mcpt_type str Valid options: \"complete\" \"cyclic\" Type of permutation to perform on the target variable when evaluating the confidence that a predictor variable's relationship with the target variable is non-random in nature. \"complete\" : shuffles the target variable values \"cyclic\" : used when target variable possesses serial correlation. Chooses a random row and copies the original target variable values in sequence beginning at this row. Excess target values are then 'wrapped' to first row in the dataset such that the last original target variable value will be located in the position just prior to the chosen random row. \"complete\" Attributes: Name Type Description state_probs_mat np.ndarray numpy matrix containing the state probabilities of all possible feature/variable combinations transition_mat np.ndarray numpy matrix containing the state transition matrics of each HMM produced by a feature/variable combination. crits np.ndarray Multiple-R value of state probabiliites regressed on target variable for each HMM model. solo_pval np.ndarray a biased p-value from MCPT testing only considering criteria produced by target randomization of a single feature set unbiased_pval np.ndarray an unbiased p-value from MCPT testing using criteria produced by target randomization of all feature sets. Source code in narrowgate/screeners/hmm/target_link.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 def screen ( self , X : pd . DataFrame , y : pd . Series , nreps : int , mcpt_type : str = 'complete' ): \"\"\" Method that performs the target-linked screening of the hidden Markov model states produced by the feature combinations. Executes the Monte Carlo Permutation testing as part of the evaluation ### Warning NaN values must not be present in 'X'. Parameters ---------- X : pandas DataFrame of time series features to combine when estimating hidden Markov models. **Must NOT contain NaN values** y : pandas Series containing the target values to predict. nreps : number of Monte Carlo permutation testing repititions to peform mcpt_type : {\"complete\", \"cyclic\"} Valid options: - **\"complete\"** - **\"cyclic\"** Type of permutation to perform on the target variable when evaluating the confidence that a predictor variable's relationship with the target variable is non-random in nature. **\"complete\"**: shuffles the target variable values **\"cyclic\"**: used when target variable possesses serial correlation. Chooses a random row and copies the original target variable values in sequence beginning at this row. Excess target values are then 'wrapped' to first row in the dataset such that the last original target variable value will be located in the position just prior to the chosen random row. Attributes ---------- state_probs_mat : np.ndarray numpy matrix containing the state probabilities of all possible feature/variable combinations transition_mat : np.ndarray numpy matrix containing the state transition matrics of each HMM produced by a feature/variable combination. crits : np.ndarray Multiple-R value of state probabiliites regressed on target variable for each HMM model. solo_pval : np.ndarray a biased p-value from MCPT testing only considering criteria produced by target randomization of a single feature set unbiased_pval : np.ndarray an unbiased p-value from MCPT testing using criteria produced by target randomization of all feature sets. \"\"\" # Validate the MCPT parameters assert nreps >= 0 if nreps == 0 : self . nreps = 1 else : self . nreps = nreps assert mcpt_type in [ 'complete' , 'cyclic' ] self . mcpt_type = mcpt_type # confirm that X is a DataFrame in order to use # column names when returning results. # confirm that there are no NA values in X assert ( isinstance ( X , pd . DataFrame )) na_mask = X . isna () . any () . values if any ( na_mask ): raise ValueError ( \"'NaN' values present in the following \" + f \"columns: { X . columns [ na_mask ] } \" ) # confirm that 'y' is a pandas Series and there are no NA values assert ( isinstance ( y , pd . Series )) na_flag = y . isna () . any () if na_flag : raise ValueError ( \"'NaN' values present in 'y' (target series)\" ) # confirm that X and y have the same number of cases if not X . shape [ 0 ] == y . shape [ 0 ]: raise RuntimeError ( \"'X' and 'y' must have the same number of observations. \" + f \"( { X . shape [ 0 ] } vs. { y . shape [ 0 ] } )\" ) # obtain all the column combinations cols = X . columns col_idx_array = np . arange ( len ( cols )) col_idx_combos = \\ [ i for i in itertools . combinations ( col_idx_array , self . nvars )] col_idx_combos = np . array ( col_idx_combos ) combo_cols = \\ np . split ( np . array ( [ cols [ i ] for combo in col_idx_combos for i in combo ]), len ( col_idx_combos )) self . model_cols = [ combo . tolist () for combo in combo_cols ] # construct the hidden Markov model in parallel for each # combination. The 'state_probs' will be reused during MCPT # reps as independent variables. The 'transition' will be # used for reporting purposes. self . state_probs_mat , self . transition_mat = \\ build_hmm_models_nb ( X . values , col_idx_combos , self . nstates , self . n_init , self . max_iter ) # Once the state_probs_mat is created, it's time to run the # MCPT reps. This will require a call to another parallelized # numba function that will fit many linear regression models. self . crits , self . solo_pval , self . unbiased_pval = \\ mcpt_linreg_nb ( self . state_probs_mat , y . values , self . nreps , self . mcpt_type ) # Generate the mcpt report along with the ranking mapper self . _mcpt_report , self . _ranked_model_mapper = \\ self . _generate_mcpt_report () # Calculate the means and standard deviations of each # of the variable for each of the states for each of the models self . _means_std_report = \\ self . _generate_means_std_report ( X . values , col_idx_combos ) # prepare the transition probability matrices as DataFrames for # each of the models created. self . _transition_report = \\ self . _generate_transition_report () # prepare the correlation report for each of the models self . _target_stats_report = \\ self . _generate_target_stats_report ( y . values )","title":"Warning"},{"location":"screeners/hmm_target/#narrowgate.screeners.hmm.target_link.HMMTargetLinkScreener.mcpt_report","text":"mcpt_report () Returns the MCPT report as a pandas DataFrame for all evaluated feature combinations. DataFrame includes the following information: independent variables used in the model Multiple-R of the state probabilities in relation to the target variable solo p-values unbiased p-values Source code in narrowgate/screeners/hmm/target_link.py 467 468 469 470 471 472 473 474 475 476 477 478 479 def mcpt_report ( self ): \"\"\" Returns the MCPT report as a pandas DataFrame for all evaluated feature combinations. DataFrame includes the following information: - independent variables used in the model - Multiple-R of the state probabilities in relation to the target variable - solo p-values - unbiased p-values \"\"\" return self . _mcpt_report","title":"mcpt_report()"},{"location":"screeners/hmm_target/#narrowgate.screeners.hmm.target_link.HMMTargetLinkScreener.print_model_report","text":"print_model_report ( result , model_rank = 'top' ) Returns the DataFrame 'report' containing the desired metrics. Parameters: Name Type Description Default result str Valid options : 'means','transitions','target' Attribute from the desired hidden Markov model to retrieve. required model_rank str Valid options : 'top','first','second','third' rank of model whose results to retrieve 'top' Source code in narrowgate/screeners/hmm/target_link.py 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 def print_model_report ( self , result : str , model_rank : str = 'top' ): \"\"\" Returns the DataFrame 'report' containing the desired metrics. Parameters ---------- result : Valid options : 'means','transitions','target' Attribute from the desired hidden Markov model to retrieve. model_rank : Valid options : 'top','first','second','third' rank of model whose results to retrieve \"\"\" assert ( result in [ 'means' , 'transitions' , 'target' ]) if model_rank in [ 'top' , 'first' ]: model_rank = 0 elif model_rank == 'second' : model_rank = 1 elif model_rank == 'third' : model_rank = 2 assert ( model_rank >= 1 ) if model_rank > len ( self . _ranked_model_mapper ): raise ValueError ( f \"'model_rank' parameter ( { model_rank } ) exceeds number \" + f \"of available models ( { self . _ranked_model_mapper } \" ) else : # subtract one from the 'rank' (python zero-index) model_rank -= 1 model_idx = self . _ranked_model_mapper [ model_rank ] if result == 'means' : return_df = self . _means_std_report [ model_idx ] elif result == 'transitions' : return_df = self . _transition_report [ model_idx ] elif result == 'target' : return_df = self . _target_report [ model_idx ] return return_df","title":"print_model_report()"},{"location":"screeners/hmm_target/#narrowgate.screeners.hmm.target_link.HMMTargetLinkScreener._generate_mcpt_report","text":"_generate_mcpt_report () Generate the MCPT results of the HMM Target Link evaluation. Includes the following information: independent variables used in the model Multiple-R of the state probabilities in relation to the target variable solo p-values unbiased p-values Also generates a 'mapping' object that can allow the user to easily access further details about the model given the models 'Multiple-R' rank Attributes: Name Type Description _mcpt_report: pd.DataFrame pandas DataFrame of HMM _ranked_model_mapper: list of tuples list of integers representing the indices of the variable combinations in ranked order according to Multiple-R criterion. Source code in narrowgate/screeners/hmm/target_link.py 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 def _generate_mcpt_report ( self ): \"\"\" Generate the MCPT results of the HMM Target Link evaluation. Includes the following information: - independent variables used in the model - Multiple-R of the state probabilities in relation to the target variable - solo p-values - unbiased p-values Also generates a 'mapping' object that can allow the user to easily access further details about the model given the models 'Multiple-R' rank Attributes ---------- _mcpt_report: pd.DataFrame pandas DataFrame of HMM _ranked_model_mapper: list of tuples list of integers representing the indices of the variable combinations in ranked order according to Multiple-R criterion. \"\"\" # create a list contaiing the column names for the report # the number of variables pred_col_names = \\ [ f 'Predictor_ { i + 1 } ' for i in range ( self . nvars )] pred_cols_df = \\ pd . DataFrame ( self . model_cols , columns = pred_col_names ) stats_col_names = [ 'Multiple-R' , 'Solo pval' , 'Unbiased pval' ] stats_mat = \\ np . hstack (( self . crits . reshape ( - 1 , 1 ), self . solo_pval . reshape ( - 1 , 1 ), self . unbiased_pval . reshape ( - 1 , 1 ))) stats_df = pd . DataFrame ( stats_mat , columns = stats_col_names ) # join DataFrames and sort by Multiple-R descending mcpt_report = \\ ( pd . concat ([ pred_cols_df , stats_df ], axis = 1 ) . sort_values ( by = 'Multiple-R' , ascending = False )) # The index from the above DataFrame will be the index # corresponding to the first dimension of the artifacts # returned from 'build_hmm_models_nb'. # Convert the index to the list. The index position of # this list will correspond to the rank of the model # in terms of 'Multiple-R'. ranked_model_mapper = list ( mcpt_report . index ) return mcpt_report , ranked_model_mapper","title":"_generate_mcpt_report()"},{"location":"screeners/hmm_target/#narrowgate.screeners.hmm.target_link.HMMTargetLinkScreener._generate_means_std_report","text":"_generate_means_std_report ( data , col_idx_combos ) Generate the reports which provides the basic statistical information regarding each of the variables for each of the models created. This method to called from the 'evaluate' method and organizes the information from each model in DataFrame. These DataFrames can then be retrieved via the 'print_model_results' method. Source code in narrowgate/screeners/hmm/target_link.py 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 def _generate_means_std_report ( self , data : pd . DataFrame , col_idx_combos : list ): \"\"\" Generate the reports which provides the basic statistical information regarding each of the variables for each of the models created. This method to called from the 'evaluate' method and organizes the information from each model in DataFrame. These DataFrames can then be retrieved via the 'print_model_results' method. \"\"\" nmodels = len ( self . model_cols ) means , stds = \\ calculate_model_var_means ( data , col_idx_combos , self . state_probs_mat ) assert ( means . shape [ 0 ] == nmodels ) mean_std = [] for imodel in range ( nmodels ): mean_mat = means [ imodel ] index_names = \\ [ f 'state_ { i + 1 } ' for i in range ( mean_mat . shape [ 0 ])] col_names = self . model_cols [ imodel ] mean_df = \\ pd . DataFrame ( mean_mat , columns = col_names , index = index_names ) std_mat = stds [ imodel ] std_df = \\ pd . DataFrame ( std_mat , columns = col_names , index = index_names ) df = \\ pd . merge ( mean_df , std_df , left_index = True , right_index = True , suffixes = [ \"_mean\" , \"_std\" ]) mean_std . append ( df [ sorted ( df . columns )]) return mean_std","title":"_generate_means_std_report()"},{"location":"screeners/hmm_target/#narrowgate.screeners.hmm.target_link.HMMTargetLinkScreener._generate_transition_report","text":"_generate_transition_report () The raw transition matrices are transformed into DataFrames for better readability. The value in each cell represents the probability the model transitions from the row state to the column state: Row State -> Column State As a result, the sum of the values in each ROW should equal 1 . Source code in narrowgate/screeners/hmm/target_link.py 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 def _generate_transition_report ( self ): \"\"\" The raw transition matrices are transformed into DataFrames for better readability. The value in each cell represents the probability the model transitions from the row state to the column state: **Row State -> Column State** As a result, the sum of the values in each ROW should equal **1**. \"\"\" nmodels = self . transition_mat . shape [ 0 ] names = [ f 'state_ { i + 1 } ' for i in range ( self . nstates )] transition_report_list = [] for imodel in range ( nmodels ): df = pd . DataFrame ( self . transition_mat [ imodel ], columns = names , index = names ) transition_report_list . append ( df ) return transition_report_list","title":"_generate_transition_report()"},{"location":"screeners/hmm_target/#narrowgate.screeners.hmm.target_link.HMMTargetLinkScreener._generate_target_stats_report","text":"_generate_target_stats_report ( target ) This method prepares a report (DataFrame) for each state of each model which contains the following information: Percent the percentage of cases in which the designated state has the highest probability. Correlation the correlation coefficient between the target and the membership probability for the designated state Target Mean the mean of the target when the designated state has the highest membership probability Target Standard Deviation the standard deviation of the target when the designated state has the highest membership probability Source code in narrowgate/screeners/hmm/target_link.py 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 def _generate_target_stats_report ( self , target ): \"\"\" This method prepares a report (DataFrame) for each state of each model which contains the following information: * Percent the percentage of cases in which the designated state has the highest probability. * Correlation the correlation coefficient between the target and the membership probability for the designated state * Target Mean the mean of the target when the designated state has the highest membership probability * Target Standard Deviation the standard deviation of the target when the designated state has the highest membership probability \"\"\" nmodels = self . state_probs_mat . shape [ 0 ] nstates = self . state_probs_mat . shape [ 2 ] target_stats_mat = \\ calculate_model_target_stats ( target , self . state_probs_mat ) column_names = \\ [ 'Percent' , 'Correlation' , 'Target mean' , 'Target StdDev' ] index_names = [ f 'State { i + 1 } ' for i in range ( nstates )] target_stats_list = [] for imodel in range ( nmodels ): df = pd . DataFrame ( target_stats_mat [ imodel ], columns = column_names , index = index_names ) target_stats_list . append ( df . round ( 5 )) return target_stats_list","title":"_generate_target_stats_report()"},{"location":"screeners/stepwise/","text":"EnhancedStepwiseScreener \u00a4 EnhancedStepwiseScreener ( n_retained = 5 , n_folds_total = 4 , n_folds_oos = 1 , minpred = 1 , maxpred = None , mcpt_type = \"complete\" , mcpt_reps = 100 , ) Enhanced Stepwise feature screening class. This class performs forward, stepwise feature selection utilizing a linear-quadratic model, retaining the best n_retained models (feature subsets) at each step. In traditional forward, stepwise feature selection only the top variable or variable combination is retained at each new feature-addition step. This potentially eliminates any advantage that may be achieved through superior interaction effects of additional variables in future steps which do not occur with the top performing set of variables. In order to account for this limitation, as stated above, multiple sets of top performing variables are retained at each step. In addition, the performance of each of these retained models is tested for robustness using Monte Carlo Permutation Testing (MCPT) and any degradation in model robustness prevents a model from being retained. If a superior model is not found by adding an additional variable, then the stepwise process stops early and the best performing model at the previous step is returned. This entire process is implemented in a parallelized manner utilizing Numba for increased efficiency and CombinatorialPurgedCrossValidation for an improved assesment of model robustness. For more information on the algorithm and it's implementation, please see the reference below. References \u00a4 Masters, Timothy. (2019) \"Extracting and Selecting Features for Data Mining: Algorithms in C++ and CUDA\". pp. 189-216. Parameters: Name Type Description Default n_retained int number of models (sets of features) to retain at each step to be used for testing in future steps. 5 n_folds_total int number of folds to create in the data set for use in cross validation testing. Utilizes Combinatorially Purged Cross Validation which is slightly different than traditional cross validation. For more information, please see CombinatorialPurgedCrossValidation 4 n_folds_oos int number of folds out of n_folds_total that will be used for out-of-sample testing. 1 minpred int minimum number of predictors the screening process is allowed to retain. 1 maxpred Union [ int , None] maximum number of predictors the screening processs is allowed to retain. If None , then all variables are eligible for inclusion in the final model. However, if, by adding a new variable, the model performance does not improve and/or is not as robust, the screening will stop early and return the best performing model. None mcpt_type str Valid options: \"complete\" \"cyclic\" Type of permutation to perform on the target variable when evaluating the confidence that a predictor variable's relationship with the target variable is non-random in nature. \"complete\" : shuffles the target variable values \"cyclic\" : used when target variable possesses serial correlation. Chooses a random row and copies the original target variable values in sequence beginning at this row. Excess target values are then 'wrapped' to first row in the dataset such that the last original target variable value will be located in the position just prior to the chosen random row. \"complete\" mcpt_reps Union [ int , None] Number of target variable permutations to perform. For best results, this number should exceed the number of predictor variables in the data set. 100 Source code in narrowgate/screeners/stepwise/enhanced.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def __init__ ( self , n_retained : int = 5 , n_folds_total : int = 4 , n_folds_oos : int = 1 , minpred : int = 1 , maxpred : Union [ int , None ] = None , mcpt_type : str = 'complete' , mcpt_reps : Union [ int , None ] = 100 ): \"\"\" Parameters ---------- n_retained : number of models (sets of features) to retain at each step to be used for testing in future steps. n_folds_total : number of folds to create in the data set for use in cross validation testing. Utilizes Combinatorially Purged Cross Validation which is slightly different than traditional cross validation. For more information, please see [CombinatorialPurgedCrossValidation] [narrowgate.model_selection.CombinatorialPurgedCrossValidation] n_folds_oos : number of folds out of `n_folds_total` that will be used for out-of-sample testing. minpred : minimum number of predictors the screening process is allowed to retain. maxpred : maximum number of predictors the screening processs is allowed to retain. If `None`, then all variables are eligible for inclusion in the final model. However, if, by adding a new variable, the model performance does not improve and/or is not as robust, the screening will stop early and return the best performing model. mcpt_type : {\"complete\", \"cyclic\"} Valid options: - **\"complete\"** - **\"cyclic\"** Type of permutation to perform on the target variable when evaluating the confidence that a predictor variable's relationship with the target variable is non-random in nature. **\"complete\"**: shuffles the target variable values **\"cyclic\"**: used when target variable possesses serial correlation. Chooses a random row and copies the original target variable values in sequence beginning at this row. Excess target values are then 'wrapped' to first row in the dataset such that the last original target variable value will be located in the position just prior to the chosen random row. mcpt_reps : Number of target variable permutations to perform. For best results, this number should exceed the number of predictor variables in the data set. \"\"\" assert ( n_retained > 0 ) self . nkept = n_retained assert ( n_folds_total > 2 ) self . n_folds_total = n_folds_total assert ( 0 < n_folds_oos < int ( n_folds_total / 2 )) self . n_folds_oos = n_folds_oos assert ( minpred > 0 ) self . minpred = minpred # will need to adjust maxpred potentially when data is input self . maxpred = maxpred if mcpt_type in [ 'complete' , 'cyclic' ]: self . mcpt_type = mcpt_type else : raise ValueError ( \"'mcpt_type' parameter must be either 'complete' or \" + f \"'cyclic' ( { mcpt_type } )\" ) if mcpt_reps is None : self . mcpt_reps = 0 else : assert ( mcpt_reps > 0 ) self . mcpt_reps = mcpt_reps fit \u00a4 fit ( X , y ) Fit the enhanced stepwise selection procedure to predictor variables present in 'X' and target variable 'y' There are several conditions which the 'fit' process needs to protect against to insure smooth execution. - no NA values (drop/impute) - properly align X and y to index if present Unfortunately, these conditions are not being addressed within the method, so the above conditions need to be handled prior to the 'fit' method being called. Parameters: Name Type Description Default X array-like of shape (n_samples, n_features) Training vectors, where n_samples is the number of samples and n_features is the number of predictors. required y array-like of shape (n_samples,) Target values required Source code in narrowgate/screeners/stepwise/enhanced.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def fit ( self , X , y ): \"\"\" Fit the enhanced stepwise selection procedure to predictor variables present in 'X' and target variable 'y' There are several conditions which the 'fit' process needs to protect against to insure smooth execution. - no NA values (drop/impute) - properly align X and y to index if present Unfortunately, these conditions are not being addressed within the method, so the above conditions need to be handled prior to the 'fit' method being called. Parameters ---------- X : array-like of shape (n_samples, n_features) Training vectors, where `n_samples` is the number of samples and `n_features` is the number of predictors. y : array-like of shape (n_samples,) Target values \"\"\" assert ( X . ndim == 2 ) assert ( X . shape [ 0 ] == y . shape [ 0 ]) # Adjust maxpred according to X dimensions if self . maxpred is None : self . maxpred = X . shape [ 1 ] else : self . maxpred = min ( self . maxpred , X . shape [ 1 ]) self . step_main ( predvars = X . values , target = y . values , nkept = self . nkept , n_folds_total = self . n_folds_total , n_folds_oos = self . n_folds_oos , minpred = self . minpred , maxpred = self . maxpred , mcpt_type = self . mcpt_type , mcpt_reps = self . mcpt_reps ) self . selected_columns = X . columns [ self . model_vars ]","title":"EnhancedStepwiseScreener"},{"location":"screeners/stepwise/#narrowgate.screeners.EnhancedStepwiseScreener","text":"EnhancedStepwiseScreener ( n_retained = 5 , n_folds_total = 4 , n_folds_oos = 1 , minpred = 1 , maxpred = None , mcpt_type = \"complete\" , mcpt_reps = 100 , ) Enhanced Stepwise feature screening class. This class performs forward, stepwise feature selection utilizing a linear-quadratic model, retaining the best n_retained models (feature subsets) at each step. In traditional forward, stepwise feature selection only the top variable or variable combination is retained at each new feature-addition step. This potentially eliminates any advantage that may be achieved through superior interaction effects of additional variables in future steps which do not occur with the top performing set of variables. In order to account for this limitation, as stated above, multiple sets of top performing variables are retained at each step. In addition, the performance of each of these retained models is tested for robustness using Monte Carlo Permutation Testing (MCPT) and any degradation in model robustness prevents a model from being retained. If a superior model is not found by adding an additional variable, then the stepwise process stops early and the best performing model at the previous step is returned. This entire process is implemented in a parallelized manner utilizing Numba for increased efficiency and CombinatorialPurgedCrossValidation for an improved assesment of model robustness. For more information on the algorithm and it's implementation, please see the reference below.","title":"EnhancedStepwiseScreener"},{"location":"screeners/stepwise/#narrowgate.screeners.EnhancedStepwiseScreener--references","text":"Masters, Timothy. (2019) \"Extracting and Selecting Features for Data Mining: Algorithms in C++ and CUDA\". pp. 189-216. Parameters: Name Type Description Default n_retained int number of models (sets of features) to retain at each step to be used for testing in future steps. 5 n_folds_total int number of folds to create in the data set for use in cross validation testing. Utilizes Combinatorially Purged Cross Validation which is slightly different than traditional cross validation. For more information, please see CombinatorialPurgedCrossValidation 4 n_folds_oos int number of folds out of n_folds_total that will be used for out-of-sample testing. 1 minpred int minimum number of predictors the screening process is allowed to retain. 1 maxpred Union [ int , None] maximum number of predictors the screening processs is allowed to retain. If None , then all variables are eligible for inclusion in the final model. However, if, by adding a new variable, the model performance does not improve and/or is not as robust, the screening will stop early and return the best performing model. None mcpt_type str Valid options: \"complete\" \"cyclic\" Type of permutation to perform on the target variable when evaluating the confidence that a predictor variable's relationship with the target variable is non-random in nature. \"complete\" : shuffles the target variable values \"cyclic\" : used when target variable possesses serial correlation. Chooses a random row and copies the original target variable values in sequence beginning at this row. Excess target values are then 'wrapped' to first row in the dataset such that the last original target variable value will be located in the position just prior to the chosen random row. \"complete\" mcpt_reps Union [ int , None] Number of target variable permutations to perform. For best results, this number should exceed the number of predictor variables in the data set. 100 Source code in narrowgate/screeners/stepwise/enhanced.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def __init__ ( self , n_retained : int = 5 , n_folds_total : int = 4 , n_folds_oos : int = 1 , minpred : int = 1 , maxpred : Union [ int , None ] = None , mcpt_type : str = 'complete' , mcpt_reps : Union [ int , None ] = 100 ): \"\"\" Parameters ---------- n_retained : number of models (sets of features) to retain at each step to be used for testing in future steps. n_folds_total : number of folds to create in the data set for use in cross validation testing. Utilizes Combinatorially Purged Cross Validation which is slightly different than traditional cross validation. For more information, please see [CombinatorialPurgedCrossValidation] [narrowgate.model_selection.CombinatorialPurgedCrossValidation] n_folds_oos : number of folds out of `n_folds_total` that will be used for out-of-sample testing. minpred : minimum number of predictors the screening process is allowed to retain. maxpred : maximum number of predictors the screening processs is allowed to retain. If `None`, then all variables are eligible for inclusion in the final model. However, if, by adding a new variable, the model performance does not improve and/or is not as robust, the screening will stop early and return the best performing model. mcpt_type : {\"complete\", \"cyclic\"} Valid options: - **\"complete\"** - **\"cyclic\"** Type of permutation to perform on the target variable when evaluating the confidence that a predictor variable's relationship with the target variable is non-random in nature. **\"complete\"**: shuffles the target variable values **\"cyclic\"**: used when target variable possesses serial correlation. Chooses a random row and copies the original target variable values in sequence beginning at this row. Excess target values are then 'wrapped' to first row in the dataset such that the last original target variable value will be located in the position just prior to the chosen random row. mcpt_reps : Number of target variable permutations to perform. For best results, this number should exceed the number of predictor variables in the data set. \"\"\" assert ( n_retained > 0 ) self . nkept = n_retained assert ( n_folds_total > 2 ) self . n_folds_total = n_folds_total assert ( 0 < n_folds_oos < int ( n_folds_total / 2 )) self . n_folds_oos = n_folds_oos assert ( minpred > 0 ) self . minpred = minpred # will need to adjust maxpred potentially when data is input self . maxpred = maxpred if mcpt_type in [ 'complete' , 'cyclic' ]: self . mcpt_type = mcpt_type else : raise ValueError ( \"'mcpt_type' parameter must be either 'complete' or \" + f \"'cyclic' ( { mcpt_type } )\" ) if mcpt_reps is None : self . mcpt_reps = 0 else : assert ( mcpt_reps > 0 ) self . mcpt_reps = mcpt_reps","title":"References"},{"location":"screeners/stepwise/#narrowgate.screeners.stepwise.enhanced.EnhancedStepwiseScreener.fit","text":"fit ( X , y ) Fit the enhanced stepwise selection procedure to predictor variables present in 'X' and target variable 'y' There are several conditions which the 'fit' process needs to protect against to insure smooth execution. - no NA values (drop/impute) - properly align X and y to index if present Unfortunately, these conditions are not being addressed within the method, so the above conditions need to be handled prior to the 'fit' method being called. Parameters: Name Type Description Default X array-like of shape (n_samples, n_features) Training vectors, where n_samples is the number of samples and n_features is the number of predictors. required y array-like of shape (n_samples,) Target values required Source code in narrowgate/screeners/stepwise/enhanced.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def fit ( self , X , y ): \"\"\" Fit the enhanced stepwise selection procedure to predictor variables present in 'X' and target variable 'y' There are several conditions which the 'fit' process needs to protect against to insure smooth execution. - no NA values (drop/impute) - properly align X and y to index if present Unfortunately, these conditions are not being addressed within the method, so the above conditions need to be handled prior to the 'fit' method being called. Parameters ---------- X : array-like of shape (n_samples, n_features) Training vectors, where `n_samples` is the number of samples and `n_features` is the number of predictors. y : array-like of shape (n_samples,) Target values \"\"\" assert ( X . ndim == 2 ) assert ( X . shape [ 0 ] == y . shape [ 0 ]) # Adjust maxpred according to X dimensions if self . maxpred is None : self . maxpred = X . shape [ 1 ] else : self . maxpred = min ( self . maxpred , X . shape [ 1 ]) self . step_main ( predvars = X . values , target = y . values , nkept = self . nkept , n_folds_total = self . n_folds_total , n_folds_oos = self . n_folds_oos , minpred = self . minpred , maxpred = self . maxpred , mcpt_type = self . mcpt_type , mcpt_reps = self . mcpt_reps ) self . selected_columns = X . columns [ self . model_vars ]","title":"fit()"},{"location":"screeners/stepwise_selector/","text":"EnhancedStepwiseSelector \u00a4 EnhancedStepwiseSelector ( ** kwargs ) Bases: BaseEstimator , SelectorMixin Enhanced Stepwise Feature selector class. Selects a set of variables/features based on EnhancedStepwiseScreener . Note \u00a4 The parameters for this class are identical to those used in EnhancedStepwiseScreener . Source code in narrowgate/screeners/stepwise/selector.py 24 25 26 27 28 29 30 31 32 def __init__ ( self , ** kwargs ): \"\"\" ### Note The parameters for this class are identical to those used in [EnhancedStepwiseScreener] [narrowgate.screeners.EnhancedStepwiseScreener]. \"\"\" self . kwargs = kwargs self . stepwise_screener = EnhancedStepwiseFeatureScreener ( ** kwargs ) fit \u00a4 fit ( X , y , verbose = False ) Fit the Enhanced Stepwise Feature Screener model to the X . Parameters: Name Type Description Default X pd . DataFrame pandas Dataframe of predictor variables required y pd . Series pandas Series of target values required verbose bool flag for indicating whether intermediate progress and results should be printed to the console for user diagnostic purposes. False Source code in narrowgate/screeners/stepwise/selector.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def fit ( self , X : pd . DataFrame , y : pd . Series , verbose : bool = False ): \"\"\" Fit the Enhanced Stepwise Feature Screener model to the `X`. Parameters ---------- X : pandas Dataframe of predictor variables y : pandas Series of target values verbose: flag for indicating whether intermediate progress and results should be printed to the console for user diagnostic purposes. \"\"\" # Perform some initial validation on X and y assert isinstance ( X , pd . DataFrame ) assert isinstance ( y , pd . Series ) self . feature_names_in_ = np . array ( X . columns ) self . n_feature_names_in_ = len ( self . feature_names_in_ ) self . stepwise_screener . fit ( X , y ) selected_columns = self . stepwise_screener . selected_columns if len ( selected_columns ): self . selected_features = selected_columns else : self . selected_features = None return self transform \u00a4 transform ( X ) Transforms the pandas DataFrame of predictor variables being passed in to just those selected_features as determined during fit() Does not check for NaN or infinite values in X . Will return an empty DataFrame if no features are selected. Returns: Type Description X X data filtered to the columns corresponding to selected_features Source code in narrowgate/screeners/stepwise/selector.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def transform ( self , X : pd . DataFrame ): \"\"\" Transforms the pandas DataFrame of predictor variables being passed in to just those `selected_features` as determined during `fit()` Does not check for NaN or infinite values in `X`. Will return an empty DataFrame if no features are selected. Returns ------- X : `X` data filtered to the columns corresponding to `selected_features` \"\"\" assert isinstance ( X , pd . DataFrame ) selected_cols = self . get_feature_names_out () mask = self . get_support () if not mask . any (): warn ( \"No features were selected: either the data is\" \" too noisy or the selection test too strict.\" , UserWarning , ) #return np.empty(0).reshape((X.shape[0], 0)) return pd . DataFrame () for col in selected_cols : if col not in X . columns : raise ValueError ( f \" { col } is not a column in X!\" ) return X [ selected_cols ]","title":"EnhancedStepwiseSelector"},{"location":"screeners/stepwise_selector/#narrowgate.screeners.EnhancedStepwiseSelector","text":"EnhancedStepwiseSelector ( ** kwargs ) Bases: BaseEstimator , SelectorMixin Enhanced Stepwise Feature selector class. Selects a set of variables/features based on EnhancedStepwiseScreener .","title":"EnhancedStepwiseSelector"},{"location":"screeners/stepwise_selector/#narrowgate.screeners.EnhancedStepwiseSelector--note","text":"The parameters for this class are identical to those used in EnhancedStepwiseScreener . Source code in narrowgate/screeners/stepwise/selector.py 24 25 26 27 28 29 30 31 32 def __init__ ( self , ** kwargs ): \"\"\" ### Note The parameters for this class are identical to those used in [EnhancedStepwiseScreener] [narrowgate.screeners.EnhancedStepwiseScreener]. \"\"\" self . kwargs = kwargs self . stepwise_screener = EnhancedStepwiseFeatureScreener ( ** kwargs )","title":"Note"},{"location":"screeners/stepwise_selector/#narrowgate.screeners.stepwise.selector.EnhancedStepwiseSelector.fit","text":"fit ( X , y , verbose = False ) Fit the Enhanced Stepwise Feature Screener model to the X . Parameters: Name Type Description Default X pd . DataFrame pandas Dataframe of predictor variables required y pd . Series pandas Series of target values required verbose bool flag for indicating whether intermediate progress and results should be printed to the console for user diagnostic purposes. False Source code in narrowgate/screeners/stepwise/selector.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def fit ( self , X : pd . DataFrame , y : pd . Series , verbose : bool = False ): \"\"\" Fit the Enhanced Stepwise Feature Screener model to the `X`. Parameters ---------- X : pandas Dataframe of predictor variables y : pandas Series of target values verbose: flag for indicating whether intermediate progress and results should be printed to the console for user diagnostic purposes. \"\"\" # Perform some initial validation on X and y assert isinstance ( X , pd . DataFrame ) assert isinstance ( y , pd . Series ) self . feature_names_in_ = np . array ( X . columns ) self . n_feature_names_in_ = len ( self . feature_names_in_ ) self . stepwise_screener . fit ( X , y ) selected_columns = self . stepwise_screener . selected_columns if len ( selected_columns ): self . selected_features = selected_columns else : self . selected_features = None return self","title":"fit()"},{"location":"screeners/stepwise_selector/#narrowgate.screeners.stepwise.selector.EnhancedStepwiseSelector.transform","text":"transform ( X ) Transforms the pandas DataFrame of predictor variables being passed in to just those selected_features as determined during fit() Does not check for NaN or infinite values in X . Will return an empty DataFrame if no features are selected. Returns: Type Description X X data filtered to the columns corresponding to selected_features Source code in narrowgate/screeners/stepwise/selector.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def transform ( self , X : pd . DataFrame ): \"\"\" Transforms the pandas DataFrame of predictor variables being passed in to just those `selected_features` as determined during `fit()` Does not check for NaN or infinite values in `X`. Will return an empty DataFrame if no features are selected. Returns ------- X : `X` data filtered to the columns corresponding to `selected_features` \"\"\" assert isinstance ( X , pd . DataFrame ) selected_cols = self . get_feature_names_out () mask = self . get_support () if not mask . any (): warn ( \"No features were selected: either the data is\" \" too noisy or the selection test too strict.\" , UserWarning , ) #return np.empty(0).reshape((X.shape[0], 0)) return pd . DataFrame () for col in selected_cols : if col not in X . columns : raise ValueError ( f \" { col } is not a column in X!\" ) return X [ selected_cols ]","title":"transform()"},{"location":"screeners/univariate/","text":"UnivariateScreener \u00a4 UnivariateScreener ( bin_definition = \"all\" , nbins_predictors = 3 , nbins_target = 3 , tail_fraction = None , mcpt_type = \"complete\" , mcpt_reps = 100 , cscv_subsets = 0 , information_criterion = \"mutual_information\" , ) Feature screening class for evaluating relationships between individual predictor variables and a target variable. The relationships being evaluated are univariate in nature. Therefore, no interaction effects between the predictor variables are taken into account when the evaluation is performed. For evaluating interaction effects, please see the BivariateScreener class. Information-based and statistical measures are available for use as evaluation criteria. When the predictor and target variables are discretized (binned) the following information-based measures are available: Mutual Information Uncertainty Reduction Cramer's V When both the predictor and target variables are continuous, then the following statistical measures are available: Pearson-R correlation Spearman Rank correlation Quadratic transformation and correlation Target Variable Types \u00a4 UnivariateScreener functionality works best with binary and continuous target variables. While it can be used in a multi-class classification experiment, special care will have to be taken by the practitioner by setting the nbins_target parameter to the number of classes present in the target variable at the time of class instantiation. Categorical Predictor Variables \u00a4 It is highly recommended that any categorical predictor variables be transformed into continuous variables via TargetEncoding or Nominal2Ordinal encoding prior to performing screening. This is especially true for those predictor variables with high cardinality as setting the nbins_predictors parameter to a large number will partition all continous variables into the given large number of bins. Doing so will require an increase use of memory and computing resources and is discouraged. References \u00a4 Masters, Timothy. (2016) \"Data Mining Algorithms in C++\". pp. 91-139. Parameters: Name Type Description Default bin_definition Optional [ str ] Declares the binning method to be used when calculating an information measure of a predictor variable to a target variable. Valid options: { \"all\" , \"tails\" , None } \"all\" \"tails\" None None : no binning. Continuous information measure must be declared \"all\" : the entirety of the target series will be used to determine the bin slices \"tails\" : only the highest and lowest tail_fraction percent of values will be used to separate the target values into exactly two bins. \"all\" nbins_target Optional [ int ] number of bins into which the target variable will be partitioned. Must be an integer value greater than 1. If the target variable is unable to be partitioned into the desired number of bins due to fewer unique values being present within the target variable, then the number of bins will automatically be adjusted downwards to support the maximum number of possible bins. Must be set to None if bin_definition=\"None\" 3 nbins_predictors Optional [ int ] number of bins into which the predictor variables will be partitioned. Must be an integer value greater than 1. If any of the predictor variables are unable to be partitioned into the desired number of bins due to fewer unique values being present, then the number of bins will automatically be adjusted downwards to support the maximum number of possible bins for that variable only. All other predictor variables will be partitioned into the requested number of bins. Must be set to None if `bin_definition=\"None\" 3 tail_fraction Optional [ float ] Only used if bin_definition is \"tails\" . Value must be: 0 < tail_fraction < 0.5. Represents the fraction in each of the upper and lower tails of the target variable that will be used for binning. The values in the upper tail will constitute one bin while the values in the lower tail will constitue the other. None mcpt_type str Valid options: \"complete\" \"cyclic\" Type of permutation to perform on the target variable when evaluating the confidence that a predictor variable's relationship with the target variable is non-random in nature. \"complete\" : shuffles the target variable values \"cyclic\" : used when target variable possesses serial correlation. Chooses a random row and copies the original target variable values in sequence beginning at this row. Excess target values are then 'wrapped' to first row in the dataset such that the last original target variable value will be located in the position just prior to the chosen random row. \"complete\" mcpt_reps int Number of target variable permutations to perform. For best results, this number should exceed the number of predictor variables in the data set. 100 cscv_subsets Optional [ int ] Valid values: integer >= 0 (must be divisible by 2) None Number of Combinatorically Symmetric Cross Validation iterations to evaluate. For more information on this cross-validation method, please refer to reference [2]. 0 information_criterion str Valid options: \"mutual_information\" \"uncertainty_reduction\" \"cramers_v\" \"pearson_r\" \"spearman_rho\" \"quadratic\" The information-based or statistical measure used in evaluating a non-random relationship between a predictor variable and the target variable. 'mutual_information' Source code in narrowgate/screeners/univariate/base.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def __init__ ( self , bin_definition : Optional [ str ] = \"all\" , nbins_predictors : Optional [ int ] = 3 , nbins_target : Optional [ int ] = 3 , tail_fraction : Optional [ float ] = None , mcpt_type : str = \"complete\" , mcpt_reps : int = 100 , cscv_subsets : Optional [ int ] = 0 , information_criterion : str = \"mutual_information\" ): \"\"\" Parameters ---------- bin_definition : {\"all\", \"tails\", None} Declares the binning method to be used when calculating an information measure of a predictor variable to a target variable. Valid options: {**\"all\"**, **\"tails\"**, **None**} - **\"all\"** - **\"tails\"** - **None** **None**: no binning. Continuous information measure must be declared **\"all\"**: the entirety of the target series will be used to determine the bin slices **\"tails\"**: only the highest and lowest `tail_fraction` percent of values will be used to separate the target values into exactly two bins. nbins_target : number of bins into which the target variable will be partitioned. Must be an integer value greater than 1. If the target variable is unable to be partitioned into the desired number of bins due to fewer unique values being present within the target variable, then the number of bins will automatically be adjusted downwards to support the maximum number of possible bins. Must be set to `None` if `bin_definition=\"None\"` nbins_predictors : number of bins into which the predictor variables will be partitioned. Must be an integer value greater than 1. If any of the predictor variables are unable to be partitioned into the desired number of bins due to fewer unique values being present, then the number of bins will automatically be adjusted downwards to support the maximum number of possible bins for that variable only. All other predictor variables will be partitioned into the requested number of bins. Must be set to `None` if `bin_definition=\"None\" tail_fraction : Only used if `bin_definition` is `\"tails\"`. Value must be: 0 < tail_fraction < 0.5. Represents the fraction in each of the upper and lower tails of the target variable that will be used for binning. The values in the upper tail will constitute one bin while the values in the lower tail will constitue the other. mcpt_type : {\"complete\", \"cyclic\"} Valid options: - **\"complete\"** - **\"cyclic\"** Type of permutation to perform on the target variable when evaluating the confidence that a predictor variable's relationship with the target variable is non-random in nature. **\"complete\"**: shuffles the target variable values **\"cyclic\"**: used when target variable possesses serial correlation. Chooses a random row and copies the original target variable values in sequence beginning at this row. Excess target values are then 'wrapped' to first row in the dataset such that the last original target variable value will be located in the position just prior to the chosen random row. mcpt_reps : Number of target variable permutations to perform. For best results, this number should exceed the number of predictor variables in the data set. cscv_subsets : Valid values: - integer >= 0 (must be divisible by 2) - None Number of Combinatorically Symmetric Cross Validation iterations to evaluate. For more information on this cross-validation method, please refer to reference [2]. information_criterion : Valid options: - **\"mutual_information\"** - **\"uncertainty_reduction\"** - **\"cramers_v\"** - **\"pearson_r\"** - **\"spearman_rho\"** - **\"quadratic\"** The information-based or statistical measure used in evaluating a non-random relationship between a predictor variable and the target variable. \"\"\" # validate all parameter inputs assert bin_definition in [ 'all' , 'tails' ] # Determine first if 'discrete' or 'continuous' # by examining nbins_predictors if nbins_predictors is None : assert nbins_target is None is_discrete = False continuous_info_crits = \\ [ 'pearson_r' , 'spearman_rho' , 'quadratic' ] assert information_criterion in continuous_info_crits else : assert isinstance ( nbins_predictors , int ) assert nbins_predictors > 1 assert isinstance ( nbins_target , int ) assert nbins_target > 1 is_discrete = True discrete_info_crits = \\ [ 'mutual_information' , 'uncertainty_reduction' , 'cramers_v' ] assert information_criterion in discrete_info_crits if bin_definition == \"all\" : tail_fraction = 0.5 else : nbins_predictors = 2 assert tail_fraction > 0 and tail_fraction < 0.5 if cscv_subsets > 0 : print ( \"CSCV evaluation incompatible with 'tails-only' evaluation!\" ) print ( \"Setting 'cscv_subsets = 0' ... \" ) if isinstance ( mcpt_reps , int ): assert mcpt_type in [ \"complete\" , \"cyclic\" ] if mcpt_reps < 1 : mcpt_reps = 0 else : raise TypeError ( \"'mcpt_reps' parameter must be a non-negative integer!\" ) if cscv_subsets is None : cscv_subsets = 0 else : if isinstance ( cscv_subsets , int ): assert ( cscv_subsets >= 0 ) and ( cscv_subsets % 2 == 0 ) else : raise ValueError ( \"'cscv_subsets' must be a non-negative, EVEN integer!\" ) self . bin_definition = bin_definition self . nbins_target = nbins_target self . nbins_predictors = nbins_predictors self . tail_fraction = tail_fraction self . mcpt_type = mcpt_type self . mcpt_reps = mcpt_reps self . cscv_subsets = cscv_subsets self . information_criterion = information_criterion self . is_discrete = is_discrete self . crits_ = None self . solo_pval_ = None self . unbiased_pval_ = None self . p_median_pval_ = None return None screen \u00a4 screen ( X , y , target = None ) Executes univariate screening. Prior to execution validates and transforms X and y inputs. Parameters: Name Type Description Default X Union [ pd . DataFrame , np . ndarray ] predictor variable dataset pandas DataFrame or numpy multi-dimensional array representing the values of the predictor variables to be screened in relation to the target variable, y . required y Union [ pd . Series , np . array ] target variable series pandas Series or numpy 1-D array representing the values of the target variable. Values must be numerical ( int or float ) and cannot be of type object . required target Optional [ str ] Valid options: None \"cpu\" \"gpu\" Indicates the device where the screening calculations should take place. Although faster, \"gpu\" functionality is brittle and should be considered experimental at this time. None Source code in narrowgate/screeners/univariate/base.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def screen ( self , X : Union [ pd . DataFrame , np . ndarray ], y : Union [ pd . Series , np . array ], target : Optional [ str ] = None ): \"\"\" Executes univariate screening. Prior to execution validates and transforms `X` and `y` inputs. Parameters ---------- X : predictor variable dataset pandas DataFrame or numpy multi-dimensional array representing the values of the predictor variables to be screened in relation to the target variable, `y`. y : target variable series pandas Series or numpy 1-D array representing the values of the target variable. Values must be numerical (`int` or `float`) and cannot be of type `object`. target : Valid options: * **None** * **\"cpu\"** * **\"gpu\"** Indicates the device where the screening calculations should take place. Although faster, \"gpu\" functionality is brittle and should be considered experimental at this time. \"\"\" if target is None : target = 'cpu' else : assert target in [ 'cpu' , 'gpu' ] # Validate objects being passed in if isinstance ( X , pd . DataFrame ): X_raw , y_raw , X_cols , self . target_name = \\ validate_pandas_inputs ( X , y ) self . predictor_columns = X . columns . tolist () self . n_obs = X_raw . shape [ 0 ] elif isinstance ( X , np . ndarray ): import math X_raw , y_raw , X_cols , self . target_name = validate_numpy_inputs ( X , y ) nvars = X_raw . shape [ 1 ] npad = int ( math . floor ( math . log10 ( abs ( nvars )))) + 1 self . predictor_columns = \\ [ 'var' + f ' { i } ' . zfill ( npad ) for i in range ( nvars )] self . n_obs = X_raw . shape [ 0 ] else : raise TypeError ( f \"Unsupported type for 'X': { type ( X ) } \" ) ############################################################ ## Convert information_measure to shorthand for functions ## ############################################################ if self . information_criterion == 'mutual_information' : info_name = 'mi' elif self . information_criterion == 'uncertainty_reduction' : info_name = 'ur' elif self . information_criterion == 'pearson_r' : info_name = 'r' elif self . information_criterion == 'spearman_rho' : info_name = 'rho' else : info_name = self . information_criterion ####################################################### # TO-DO: Validate data # Convert any NaN values or categorical variables ##################################################### if target == 'cpu' : from ._cpu import prepare_univariate_data from ._cpu import mcpt_univariate_screen from ._cpu import cscv_univariate_screen X_dict = \\ prepare_univariate_data ( X_raw , nbins = self . nbins_predictors , tail_frac = self . tail_fraction , verbose = True ) self . crits_ , self . solo_pval_ , self . unbiased_pval_ = \\ mcpt_univariate_screen ( X_dict , y_raw , y_nbins = self . nbins_target , information_measure = info_name , mcpt_nreps = self . mcpt_reps , mcpt_type = self . mcpt_type ) if self . cscv_subsets > 0 : self . p_median_pval_ = \\ cscv_univariate_screen ( X = X_raw , y = y_raw , x_nbins = self . nbins_predictors , y_nbins = self . nbins_target , information_measure = info_name , n_cscv = self . cscv_subsets ) return self results \u00a4 results () A pandas DataFrame representing the calculated results produced from running screen . Consolidates the following instance attributes into a more digestable and comparable format: crits solo_pval unbiased_pval p_median_pval (if cscv_subsets > 0) Source code in narrowgate/screeners/univariate/base.py 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 @property def results ( self ) -> pd . DataFrame : \"\"\" A pandas DataFrame representing the calculated results produced from running `screen`. Consolidates the following instance attributes into a more digestable and comparable format: * `crits` * `solo_pval` * `unbiased_pval` * `p_median_pval` (if `cscv_subsets` > 0) \"\"\" if self . crits_ is not None : print ( \"UNIVARIATE SCREENER RESULTS\" ) print ( \"---------------------------\" ) print ( f \"Number of observations: { self . n_obs } \" ) print ( f \"Number of predictors: { len ( self . predictor_columns ) } \" ) print ( f \"Target variable name: { self . target_name } \" ) print ( f \"Number of MCPT reps: { self . mcpt_reps } \" ) print ( f \"Number of CSCV subsets: { self . cscv_subsets } \" ) if self . is_discrete : print ( f \"Number of bins (predictors): { self . nbins_predictors } \" ) print ( f \"Number of bins (target): { self . nbins_target } \" ) print ( f \"MCPT permutation method: { self . mcpt_type } \" ) if self . information_criterion == 'mutual_information' : info_crit_str = 'Mutual Information' elif self . information_criterion == 'uncertainty_reduction' : info_crit_str = 'Uncertainty Reduction' elif self . information_criterion == 'cramers_v' : info_crit_str = 'Cramers V' elif self . information_criterion == 'pearson_r' : info_crit_str = 'Pearson R' elif self . information_criterion == 'spearman_rho' : info_crit_str = 'Spearman Rho' elif self . information_criterion == 'Quadratic' : info_crit_str = 'Quadratic' print ( f \"Information Criterion: { info_crit_str } \" ) var_series = \\ pd . Series ( self . predictor_columns , name = 'Variables' ) measure_name = self . information_criterion col_names = [ measure_name , 'Solo p-value' , 'Unbiased p-value' ] results_mat = \\ np . hstack (( self . crits_ . reshape ( - 1 , 1 ), self . solo_pval_ . reshape ( - 1 , 1 ), self . unbiased_pval_ . reshape ( - 1 , 1 ))) if self . cscv_subsets > 0 : col_names += [ 'P(<=median)' ] results_mat = \\ np . hstack (( results_mat , self . p_median_pval_ . reshape ( - 1 , 1 ))) results_df = \\ pd . DataFrame ( results_mat , columns = col_names ) results_df . insert ( 0 , 'Variable' , var_series ) results_df = \\ results_df . sort_values ( by = measure_name , ascending = False ) results_df [ measure_name ] = results_df [ measure_name ] . round ( 4 ) results_df . reset_index ( drop = True , inplace = True ) else : print ( \"No screening results available!\" ) results_df = None return results_df crits \u00a4 crits () pandas Series of information measures representing the relationship of one or more predictor variables to the target variable. Source code in narrowgate/screeners/univariate/base.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 @property def crits ( self ): \"\"\" pandas Series of information measures representing the relationship of one or more predictor variables to the target variable. \"\"\" if self . crits_ is not None : crits_series = \\ pd . Series ( self . crits_ , index = self . predictor_columns , name = self . information_criterion ) else : print ( \"No screening results available!\" ) crits_series = None return crits_series","title":"UnivariateScreener"},{"location":"screeners/univariate/#narrowgate.screeners.univariate.base.UnivariateScreener","text":"UnivariateScreener ( bin_definition = \"all\" , nbins_predictors = 3 , nbins_target = 3 , tail_fraction = None , mcpt_type = \"complete\" , mcpt_reps = 100 , cscv_subsets = 0 , information_criterion = \"mutual_information\" , ) Feature screening class for evaluating relationships between individual predictor variables and a target variable. The relationships being evaluated are univariate in nature. Therefore, no interaction effects between the predictor variables are taken into account when the evaluation is performed. For evaluating interaction effects, please see the BivariateScreener class. Information-based and statistical measures are available for use as evaluation criteria. When the predictor and target variables are discretized (binned) the following information-based measures are available: Mutual Information Uncertainty Reduction Cramer's V When both the predictor and target variables are continuous, then the following statistical measures are available: Pearson-R correlation Spearman Rank correlation Quadratic transformation and correlation","title":"UnivariateScreener"},{"location":"screeners/univariate/#narrowgate.screeners.univariate.base.UnivariateScreener--target-variable-types","text":"UnivariateScreener functionality works best with binary and continuous target variables. While it can be used in a multi-class classification experiment, special care will have to be taken by the practitioner by setting the nbins_target parameter to the number of classes present in the target variable at the time of class instantiation.","title":"Target Variable Types"},{"location":"screeners/univariate/#narrowgate.screeners.univariate.base.UnivariateScreener--categorical-predictor-variables","text":"It is highly recommended that any categorical predictor variables be transformed into continuous variables via TargetEncoding or Nominal2Ordinal encoding prior to performing screening. This is especially true for those predictor variables with high cardinality as setting the nbins_predictors parameter to a large number will partition all continous variables into the given large number of bins. Doing so will require an increase use of memory and computing resources and is discouraged.","title":"Categorical Predictor Variables"},{"location":"screeners/univariate/#narrowgate.screeners.univariate.base.UnivariateScreener--references","text":"Masters, Timothy. (2016) \"Data Mining Algorithms in C++\". pp. 91-139. Parameters: Name Type Description Default bin_definition Optional [ str ] Declares the binning method to be used when calculating an information measure of a predictor variable to a target variable. Valid options: { \"all\" , \"tails\" , None } \"all\" \"tails\" None None : no binning. Continuous information measure must be declared \"all\" : the entirety of the target series will be used to determine the bin slices \"tails\" : only the highest and lowest tail_fraction percent of values will be used to separate the target values into exactly two bins. \"all\" nbins_target Optional [ int ] number of bins into which the target variable will be partitioned. Must be an integer value greater than 1. If the target variable is unable to be partitioned into the desired number of bins due to fewer unique values being present within the target variable, then the number of bins will automatically be adjusted downwards to support the maximum number of possible bins. Must be set to None if bin_definition=\"None\" 3 nbins_predictors Optional [ int ] number of bins into which the predictor variables will be partitioned. Must be an integer value greater than 1. If any of the predictor variables are unable to be partitioned into the desired number of bins due to fewer unique values being present, then the number of bins will automatically be adjusted downwards to support the maximum number of possible bins for that variable only. All other predictor variables will be partitioned into the requested number of bins. Must be set to None if `bin_definition=\"None\" 3 tail_fraction Optional [ float ] Only used if bin_definition is \"tails\" . Value must be: 0 < tail_fraction < 0.5. Represents the fraction in each of the upper and lower tails of the target variable that will be used for binning. The values in the upper tail will constitute one bin while the values in the lower tail will constitue the other. None mcpt_type str Valid options: \"complete\" \"cyclic\" Type of permutation to perform on the target variable when evaluating the confidence that a predictor variable's relationship with the target variable is non-random in nature. \"complete\" : shuffles the target variable values \"cyclic\" : used when target variable possesses serial correlation. Chooses a random row and copies the original target variable values in sequence beginning at this row. Excess target values are then 'wrapped' to first row in the dataset such that the last original target variable value will be located in the position just prior to the chosen random row. \"complete\" mcpt_reps int Number of target variable permutations to perform. For best results, this number should exceed the number of predictor variables in the data set. 100 cscv_subsets Optional [ int ] Valid values: integer >= 0 (must be divisible by 2) None Number of Combinatorically Symmetric Cross Validation iterations to evaluate. For more information on this cross-validation method, please refer to reference [2]. 0 information_criterion str Valid options: \"mutual_information\" \"uncertainty_reduction\" \"cramers_v\" \"pearson_r\" \"spearman_rho\" \"quadratic\" The information-based or statistical measure used in evaluating a non-random relationship between a predictor variable and the target variable. 'mutual_information' Source code in narrowgate/screeners/univariate/base.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def __init__ ( self , bin_definition : Optional [ str ] = \"all\" , nbins_predictors : Optional [ int ] = 3 , nbins_target : Optional [ int ] = 3 , tail_fraction : Optional [ float ] = None , mcpt_type : str = \"complete\" , mcpt_reps : int = 100 , cscv_subsets : Optional [ int ] = 0 , information_criterion : str = \"mutual_information\" ): \"\"\" Parameters ---------- bin_definition : {\"all\", \"tails\", None} Declares the binning method to be used when calculating an information measure of a predictor variable to a target variable. Valid options: {**\"all\"**, **\"tails\"**, **None**} - **\"all\"** - **\"tails\"** - **None** **None**: no binning. Continuous information measure must be declared **\"all\"**: the entirety of the target series will be used to determine the bin slices **\"tails\"**: only the highest and lowest `tail_fraction` percent of values will be used to separate the target values into exactly two bins. nbins_target : number of bins into which the target variable will be partitioned. Must be an integer value greater than 1. If the target variable is unable to be partitioned into the desired number of bins due to fewer unique values being present within the target variable, then the number of bins will automatically be adjusted downwards to support the maximum number of possible bins. Must be set to `None` if `bin_definition=\"None\"` nbins_predictors : number of bins into which the predictor variables will be partitioned. Must be an integer value greater than 1. If any of the predictor variables are unable to be partitioned into the desired number of bins due to fewer unique values being present, then the number of bins will automatically be adjusted downwards to support the maximum number of possible bins for that variable only. All other predictor variables will be partitioned into the requested number of bins. Must be set to `None` if `bin_definition=\"None\" tail_fraction : Only used if `bin_definition` is `\"tails\"`. Value must be: 0 < tail_fraction < 0.5. Represents the fraction in each of the upper and lower tails of the target variable that will be used for binning. The values in the upper tail will constitute one bin while the values in the lower tail will constitue the other. mcpt_type : {\"complete\", \"cyclic\"} Valid options: - **\"complete\"** - **\"cyclic\"** Type of permutation to perform on the target variable when evaluating the confidence that a predictor variable's relationship with the target variable is non-random in nature. **\"complete\"**: shuffles the target variable values **\"cyclic\"**: used when target variable possesses serial correlation. Chooses a random row and copies the original target variable values in sequence beginning at this row. Excess target values are then 'wrapped' to first row in the dataset such that the last original target variable value will be located in the position just prior to the chosen random row. mcpt_reps : Number of target variable permutations to perform. For best results, this number should exceed the number of predictor variables in the data set. cscv_subsets : Valid values: - integer >= 0 (must be divisible by 2) - None Number of Combinatorically Symmetric Cross Validation iterations to evaluate. For more information on this cross-validation method, please refer to reference [2]. information_criterion : Valid options: - **\"mutual_information\"** - **\"uncertainty_reduction\"** - **\"cramers_v\"** - **\"pearson_r\"** - **\"spearman_rho\"** - **\"quadratic\"** The information-based or statistical measure used in evaluating a non-random relationship between a predictor variable and the target variable. \"\"\" # validate all parameter inputs assert bin_definition in [ 'all' , 'tails' ] # Determine first if 'discrete' or 'continuous' # by examining nbins_predictors if nbins_predictors is None : assert nbins_target is None is_discrete = False continuous_info_crits = \\ [ 'pearson_r' , 'spearman_rho' , 'quadratic' ] assert information_criterion in continuous_info_crits else : assert isinstance ( nbins_predictors , int ) assert nbins_predictors > 1 assert isinstance ( nbins_target , int ) assert nbins_target > 1 is_discrete = True discrete_info_crits = \\ [ 'mutual_information' , 'uncertainty_reduction' , 'cramers_v' ] assert information_criterion in discrete_info_crits if bin_definition == \"all\" : tail_fraction = 0.5 else : nbins_predictors = 2 assert tail_fraction > 0 and tail_fraction < 0.5 if cscv_subsets > 0 : print ( \"CSCV evaluation incompatible with 'tails-only' evaluation!\" ) print ( \"Setting 'cscv_subsets = 0' ... \" ) if isinstance ( mcpt_reps , int ): assert mcpt_type in [ \"complete\" , \"cyclic\" ] if mcpt_reps < 1 : mcpt_reps = 0 else : raise TypeError ( \"'mcpt_reps' parameter must be a non-negative integer!\" ) if cscv_subsets is None : cscv_subsets = 0 else : if isinstance ( cscv_subsets , int ): assert ( cscv_subsets >= 0 ) and ( cscv_subsets % 2 == 0 ) else : raise ValueError ( \"'cscv_subsets' must be a non-negative, EVEN integer!\" ) self . bin_definition = bin_definition self . nbins_target = nbins_target self . nbins_predictors = nbins_predictors self . tail_fraction = tail_fraction self . mcpt_type = mcpt_type self . mcpt_reps = mcpt_reps self . cscv_subsets = cscv_subsets self . information_criterion = information_criterion self . is_discrete = is_discrete self . crits_ = None self . solo_pval_ = None self . unbiased_pval_ = None self . p_median_pval_ = None return None","title":"References"},{"location":"screeners/univariate/#narrowgate.screeners.univariate.base.UnivariateScreener.screen","text":"screen ( X , y , target = None ) Executes univariate screening. Prior to execution validates and transforms X and y inputs. Parameters: Name Type Description Default X Union [ pd . DataFrame , np . ndarray ] predictor variable dataset pandas DataFrame or numpy multi-dimensional array representing the values of the predictor variables to be screened in relation to the target variable, y . required y Union [ pd . Series , np . array ] target variable series pandas Series or numpy 1-D array representing the values of the target variable. Values must be numerical ( int or float ) and cannot be of type object . required target Optional [ str ] Valid options: None \"cpu\" \"gpu\" Indicates the device where the screening calculations should take place. Although faster, \"gpu\" functionality is brittle and should be considered experimental at this time. None Source code in narrowgate/screeners/univariate/base.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def screen ( self , X : Union [ pd . DataFrame , np . ndarray ], y : Union [ pd . Series , np . array ], target : Optional [ str ] = None ): \"\"\" Executes univariate screening. Prior to execution validates and transforms `X` and `y` inputs. Parameters ---------- X : predictor variable dataset pandas DataFrame or numpy multi-dimensional array representing the values of the predictor variables to be screened in relation to the target variable, `y`. y : target variable series pandas Series or numpy 1-D array representing the values of the target variable. Values must be numerical (`int` or `float`) and cannot be of type `object`. target : Valid options: * **None** * **\"cpu\"** * **\"gpu\"** Indicates the device where the screening calculations should take place. Although faster, \"gpu\" functionality is brittle and should be considered experimental at this time. \"\"\" if target is None : target = 'cpu' else : assert target in [ 'cpu' , 'gpu' ] # Validate objects being passed in if isinstance ( X , pd . DataFrame ): X_raw , y_raw , X_cols , self . target_name = \\ validate_pandas_inputs ( X , y ) self . predictor_columns = X . columns . tolist () self . n_obs = X_raw . shape [ 0 ] elif isinstance ( X , np . ndarray ): import math X_raw , y_raw , X_cols , self . target_name = validate_numpy_inputs ( X , y ) nvars = X_raw . shape [ 1 ] npad = int ( math . floor ( math . log10 ( abs ( nvars )))) + 1 self . predictor_columns = \\ [ 'var' + f ' { i } ' . zfill ( npad ) for i in range ( nvars )] self . n_obs = X_raw . shape [ 0 ] else : raise TypeError ( f \"Unsupported type for 'X': { type ( X ) } \" ) ############################################################ ## Convert information_measure to shorthand for functions ## ############################################################ if self . information_criterion == 'mutual_information' : info_name = 'mi' elif self . information_criterion == 'uncertainty_reduction' : info_name = 'ur' elif self . information_criterion == 'pearson_r' : info_name = 'r' elif self . information_criterion == 'spearman_rho' : info_name = 'rho' else : info_name = self . information_criterion ####################################################### # TO-DO: Validate data # Convert any NaN values or categorical variables ##################################################### if target == 'cpu' : from ._cpu import prepare_univariate_data from ._cpu import mcpt_univariate_screen from ._cpu import cscv_univariate_screen X_dict = \\ prepare_univariate_data ( X_raw , nbins = self . nbins_predictors , tail_frac = self . tail_fraction , verbose = True ) self . crits_ , self . solo_pval_ , self . unbiased_pval_ = \\ mcpt_univariate_screen ( X_dict , y_raw , y_nbins = self . nbins_target , information_measure = info_name , mcpt_nreps = self . mcpt_reps , mcpt_type = self . mcpt_type ) if self . cscv_subsets > 0 : self . p_median_pval_ = \\ cscv_univariate_screen ( X = X_raw , y = y_raw , x_nbins = self . nbins_predictors , y_nbins = self . nbins_target , information_measure = info_name , n_cscv = self . cscv_subsets ) return self","title":"screen()"},{"location":"screeners/univariate/#narrowgate.screeners.univariate.base.UnivariateScreener.results","text":"results () A pandas DataFrame representing the calculated results produced from running screen . Consolidates the following instance attributes into a more digestable and comparable format: crits solo_pval unbiased_pval p_median_pval (if cscv_subsets > 0) Source code in narrowgate/screeners/univariate/base.py 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 @property def results ( self ) -> pd . DataFrame : \"\"\" A pandas DataFrame representing the calculated results produced from running `screen`. Consolidates the following instance attributes into a more digestable and comparable format: * `crits` * `solo_pval` * `unbiased_pval` * `p_median_pval` (if `cscv_subsets` > 0) \"\"\" if self . crits_ is not None : print ( \"UNIVARIATE SCREENER RESULTS\" ) print ( \"---------------------------\" ) print ( f \"Number of observations: { self . n_obs } \" ) print ( f \"Number of predictors: { len ( self . predictor_columns ) } \" ) print ( f \"Target variable name: { self . target_name } \" ) print ( f \"Number of MCPT reps: { self . mcpt_reps } \" ) print ( f \"Number of CSCV subsets: { self . cscv_subsets } \" ) if self . is_discrete : print ( f \"Number of bins (predictors): { self . nbins_predictors } \" ) print ( f \"Number of bins (target): { self . nbins_target } \" ) print ( f \"MCPT permutation method: { self . mcpt_type } \" ) if self . information_criterion == 'mutual_information' : info_crit_str = 'Mutual Information' elif self . information_criterion == 'uncertainty_reduction' : info_crit_str = 'Uncertainty Reduction' elif self . information_criterion == 'cramers_v' : info_crit_str = 'Cramers V' elif self . information_criterion == 'pearson_r' : info_crit_str = 'Pearson R' elif self . information_criterion == 'spearman_rho' : info_crit_str = 'Spearman Rho' elif self . information_criterion == 'Quadratic' : info_crit_str = 'Quadratic' print ( f \"Information Criterion: { info_crit_str } \" ) var_series = \\ pd . Series ( self . predictor_columns , name = 'Variables' ) measure_name = self . information_criterion col_names = [ measure_name , 'Solo p-value' , 'Unbiased p-value' ] results_mat = \\ np . hstack (( self . crits_ . reshape ( - 1 , 1 ), self . solo_pval_ . reshape ( - 1 , 1 ), self . unbiased_pval_ . reshape ( - 1 , 1 ))) if self . cscv_subsets > 0 : col_names += [ 'P(<=median)' ] results_mat = \\ np . hstack (( results_mat , self . p_median_pval_ . reshape ( - 1 , 1 ))) results_df = \\ pd . DataFrame ( results_mat , columns = col_names ) results_df . insert ( 0 , 'Variable' , var_series ) results_df = \\ results_df . sort_values ( by = measure_name , ascending = False ) results_df [ measure_name ] = results_df [ measure_name ] . round ( 4 ) results_df . reset_index ( drop = True , inplace = True ) else : print ( \"No screening results available!\" ) results_df = None return results_df","title":"results()"},{"location":"screeners/univariate/#narrowgate.screeners.univariate.base.UnivariateScreener.crits","text":"crits () pandas Series of information measures representing the relationship of one or more predictor variables to the target variable. Source code in narrowgate/screeners/univariate/base.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 @property def crits ( self ): \"\"\" pandas Series of information measures representing the relationship of one or more predictor variables to the target variable. \"\"\" if self . crits_ is not None : crits_series = \\ pd . Series ( self . crits_ , index = self . predictor_columns , name = self . information_criterion ) else : print ( \"No screening results available!\" ) crits_series = None return crits_series","title":"crits()"},{"location":"utils/cluster/","text":"Utility functions and metrics for determining the optimal number of clusters. Utilized by FSCA and it's cluster() method. While these functions are more general purpose and not specifically unique to the above-mentioned class, their target use is to cluster collinear variables with one another in an effort to reduce dimensionality and redundancy in a given data set. find_optimal_cluster \u00a4 find_optimal_cluster ( scores , max_since_best_iter = 5 ) Replicates 'early-stopping' functionality given an array of scores The scores array corresponds to a clustering metric which exhibits non-monotically increasing behavior. The position in the array corresponds to the number of clusters being scored. A higher score achieved by fewer clusters is the desired outcome. In such a desired scenario, a high score will occur early-ish in the array following by lower scores. The max_since_best_iter variable determines how many lower scores should pass before the most recent high score and, therefore, corresponding number of clusters are deemed optimal. Parameters: Name Type Description Default scores List [ float ] list of scoring metrics corresponding to the number of clusters being evaluated. required max_since_best_iter int number of lower scores to allow since recent high score before stopping the score evaluation early and declaring the most number of clusters corresponding to the most recent high score as the optimal number of clusters. 5 Returns: Name Type Description best_iter int optimal number of clusters best_score float clustering metric/score for best_iter Source code in narrowgate/utils/cluster.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def find_optimal_cluster ( scores : List [ float ], max_since_best_iter : int = 5 ): \"\"\" Replicates 'early-stopping' functionality given an array of `scores` The `scores` array corresponds to a clustering metric which exhibits non-monotically increasing behavior. The position in the array corresponds to the number of clusters being scored. A higher score achieved by fewer clusters is the desired outcome. In such a desired scenario, a high score will occur early-ish in the array following by lower scores. The `max_since_best_iter` variable determines how many lower scores should pass before the most recent high score and, therefore, corresponding number of clusters are deemed optimal. Parameters ---------- scores : list of scoring metrics corresponding to the number of clusters being evaluated. max_since_best_iter : number of lower scores to allow since recent high score before stopping the score evaluation early and declaring the most number of clusters corresponding to the most recent high score as the optimal number of clusters. Returns ------- best_iter : int optimal number of clusters best_score : float clustering metric/score for best_iter \"\"\" assert int > 0 best_iter = 0 best_score = 0 n_since_best = 0 for i in range ( len ( scores )): if scores [ i ] > best_score : best_iter = i best_score = scores [ i ] n_since_best = 0 else : if n_since_best > max_since_best_iter : break else : n_since_best += 1 return best_iter , best_score silhouette_nb \u00a4 silhouette_nb ( factors , cluster_ids , n_in_cluster ) Numba JIT function for calculating the Silhouette score for each observation in relation to the designated group of clusters ( cluster_ids ). Hard-coded to utilize Euclidean distance for distance measurement between observations. Reference for implementation: https://towardsdatascience.com/cheat-sheet-to-implementing-7-methods-for-selecting-optimal-number-of-clusters-in-python-898241e1d6ad Parameters: Name Type Description Default factors np . ndarray Matrix of factor values corresponding to each observations shape: (ncases, n_factors) required cluster_ids np . array array of integer values corresponding to the cluster ID of each observation shape: (ncases,) required n_in_cluster int array of values corresponding to the number of observations present in each cluster shape: (n_clusters,) required Returns: Name Type Description silhouette np.array array of silhouette scores position in array refers to number of clusters evaluated shape: (ncases, ) dist_matrix np.ndarray matrix containing the Euclidean distance between each observation shape: (ncases, ncases) cluster_dist np.ndarray matrix containing the average distance from each point to all points in a given cluster shape: (ncases, n_clusters) Source code in narrowgate/utils/cluster.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 @numba . jit ( nopython = True , parallel = True ) def silhouette_nb ( factors : np . ndarray , cluster_ids : np . array , n_in_cluster : int ): \"\"\" Numba JIT function for calculating the Silhouette score for each observation in relation to the designated group of clusters (`cluster_ids`). Hard-coded to utilize Euclidean distance for distance measurement between observations. Reference for implementation: https://towardsdatascience.com/cheat-sheet-to-implementing-7-methods-for-selecting-optimal-number-of-clusters-in-python-898241e1d6ad Parameters ---------- factors : Matrix of factor values corresponding to each observations shape: (ncases, n_factors) cluster_ids : array of integer values corresponding to the cluster ID of each observation shape: (ncases,) n_in_cluster : array of values corresponding to the number of observations present in each cluster shape: (n_clusters,) Returns ------- silhouette : np.array array of silhouette scores position in array refers to number of clusters evaluated shape: (ncases, ) dist_matrix : np.ndarray matrix containing the Euclidean distance between each observation shape: (ncases, ncases) cluster_dist : np.ndarray matrix containing the average distance from each point to all points in a given cluster shape: (ncases, n_clusters) \"\"\" n_clusters = n_in_cluster . shape [ 0 ] n_obs = factors . shape [ 0 ] dist_matrix = np . zeros (( n_obs , n_obs )) cluster_dist = np . zeros (( n_obs , n_clusters )) silhouette = np . zeros ( n_obs ) # compute all distances for all points for i in numba . prange ( n_obs - 1 ): for j in range ( i + 1 , n_obs ): dist_matrix [ i , j ] = \\ np . real ( np . sqrt ( np . sum ( np . square ( factors [ i ] - factors [ j ])))) dist_matrix [ j , i ] = dist_matrix [ i , j ] # compute the average distance to other points in ones own cluster for i in numba . prange ( n_obs ): for iclust in numba . prange ( n_clusters ): cluster_mask = cluster_ids == iclust # Need to set the flag point to itself to 'False' if # processing cluster in which observation resides. #cluster_mask[i] = False # Calculate average dist of observation to points in # cluster dist_arr = dist_matrix [ i ] cluster_dist [ i , iclust ] = np . nanmean ( dist_arr [ cluster_mask ]) cluster = cluster_ids [ i ] a = cluster_dist [ i , cluster ] b = np . min ( np . delete ( cluster_dist [ i ], cluster )) max_a_b = max ( a , b ) silhouette [ i ] = ( b - a ) / max_a_b return silhouette , dist_matrix , cluster_dist","title":"Cluster"},{"location":"utils/cluster/#narrowgate.utils.cluster.find_optimal_cluster","text":"find_optimal_cluster ( scores , max_since_best_iter = 5 ) Replicates 'early-stopping' functionality given an array of scores The scores array corresponds to a clustering metric which exhibits non-monotically increasing behavior. The position in the array corresponds to the number of clusters being scored. A higher score achieved by fewer clusters is the desired outcome. In such a desired scenario, a high score will occur early-ish in the array following by lower scores. The max_since_best_iter variable determines how many lower scores should pass before the most recent high score and, therefore, corresponding number of clusters are deemed optimal. Parameters: Name Type Description Default scores List [ float ] list of scoring metrics corresponding to the number of clusters being evaluated. required max_since_best_iter int number of lower scores to allow since recent high score before stopping the score evaluation early and declaring the most number of clusters corresponding to the most recent high score as the optimal number of clusters. 5 Returns: Name Type Description best_iter int optimal number of clusters best_score float clustering metric/score for best_iter Source code in narrowgate/utils/cluster.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def find_optimal_cluster ( scores : List [ float ], max_since_best_iter : int = 5 ): \"\"\" Replicates 'early-stopping' functionality given an array of `scores` The `scores` array corresponds to a clustering metric which exhibits non-monotically increasing behavior. The position in the array corresponds to the number of clusters being scored. A higher score achieved by fewer clusters is the desired outcome. In such a desired scenario, a high score will occur early-ish in the array following by lower scores. The `max_since_best_iter` variable determines how many lower scores should pass before the most recent high score and, therefore, corresponding number of clusters are deemed optimal. Parameters ---------- scores : list of scoring metrics corresponding to the number of clusters being evaluated. max_since_best_iter : number of lower scores to allow since recent high score before stopping the score evaluation early and declaring the most number of clusters corresponding to the most recent high score as the optimal number of clusters. Returns ------- best_iter : int optimal number of clusters best_score : float clustering metric/score for best_iter \"\"\" assert int > 0 best_iter = 0 best_score = 0 n_since_best = 0 for i in range ( len ( scores )): if scores [ i ] > best_score : best_iter = i best_score = scores [ i ] n_since_best = 0 else : if n_since_best > max_since_best_iter : break else : n_since_best += 1 return best_iter , best_score","title":"find_optimal_cluster()"},{"location":"utils/cluster/#narrowgate.utils.cluster.silhouette_nb","text":"silhouette_nb ( factors , cluster_ids , n_in_cluster ) Numba JIT function for calculating the Silhouette score for each observation in relation to the designated group of clusters ( cluster_ids ). Hard-coded to utilize Euclidean distance for distance measurement between observations. Reference for implementation: https://towardsdatascience.com/cheat-sheet-to-implementing-7-methods-for-selecting-optimal-number-of-clusters-in-python-898241e1d6ad Parameters: Name Type Description Default factors np . ndarray Matrix of factor values corresponding to each observations shape: (ncases, n_factors) required cluster_ids np . array array of integer values corresponding to the cluster ID of each observation shape: (ncases,) required n_in_cluster int array of values corresponding to the number of observations present in each cluster shape: (n_clusters,) required Returns: Name Type Description silhouette np.array array of silhouette scores position in array refers to number of clusters evaluated shape: (ncases, ) dist_matrix np.ndarray matrix containing the Euclidean distance between each observation shape: (ncases, ncases) cluster_dist np.ndarray matrix containing the average distance from each point to all points in a given cluster shape: (ncases, n_clusters) Source code in narrowgate/utils/cluster.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 @numba . jit ( nopython = True , parallel = True ) def silhouette_nb ( factors : np . ndarray , cluster_ids : np . array , n_in_cluster : int ): \"\"\" Numba JIT function for calculating the Silhouette score for each observation in relation to the designated group of clusters (`cluster_ids`). Hard-coded to utilize Euclidean distance for distance measurement between observations. Reference for implementation: https://towardsdatascience.com/cheat-sheet-to-implementing-7-methods-for-selecting-optimal-number-of-clusters-in-python-898241e1d6ad Parameters ---------- factors : Matrix of factor values corresponding to each observations shape: (ncases, n_factors) cluster_ids : array of integer values corresponding to the cluster ID of each observation shape: (ncases,) n_in_cluster : array of values corresponding to the number of observations present in each cluster shape: (n_clusters,) Returns ------- silhouette : np.array array of silhouette scores position in array refers to number of clusters evaluated shape: (ncases, ) dist_matrix : np.ndarray matrix containing the Euclidean distance between each observation shape: (ncases, ncases) cluster_dist : np.ndarray matrix containing the average distance from each point to all points in a given cluster shape: (ncases, n_clusters) \"\"\" n_clusters = n_in_cluster . shape [ 0 ] n_obs = factors . shape [ 0 ] dist_matrix = np . zeros (( n_obs , n_obs )) cluster_dist = np . zeros (( n_obs , n_clusters )) silhouette = np . zeros ( n_obs ) # compute all distances for all points for i in numba . prange ( n_obs - 1 ): for j in range ( i + 1 , n_obs ): dist_matrix [ i , j ] = \\ np . real ( np . sqrt ( np . sum ( np . square ( factors [ i ] - factors [ j ])))) dist_matrix [ j , i ] = dist_matrix [ i , j ] # compute the average distance to other points in ones own cluster for i in numba . prange ( n_obs ): for iclust in numba . prange ( n_clusters ): cluster_mask = cluster_ids == iclust # Need to set the flag point to itself to 'False' if # processing cluster in which observation resides. #cluster_mask[i] = False # Calculate average dist of observation to points in # cluster dist_arr = dist_matrix [ i ] cluster_dist [ i , iclust ] = np . nanmean ( dist_arr [ cluster_mask ]) cluster = cluster_ids [ i ] a = cluster_dist [ i , cluster ] b = np . min ( np . delete ( cluster_dist [ i ], cluster )) max_a_b = max ( a , b ) silhouette [ i ] = ( b - a ) / max_a_b return silhouette , dist_matrix , cluster_dist","title":"silhouette_nb()"},{"location":"utils/metrics_cpu/","text":"Metrics (CPU) \u00a4 Continuous \u00a4 pearson_r_cpu_nb \u00a4 pearson_r_cpu_nb ( crit_array , x , y ) Parallelized version of Pearson's R correlation. Supports calculation across multiple predictor variables and one or more target variables simultaneously. Source code in narrowgate/utils/metrics/cpu/pearson_r.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @numba . jit ( nopython = True , parallel = True ) def pearson_r_cpu_nb ( crit_array , x , y ): \"\"\" Parallelized version of Pearson's R correlation. Supports calculation across multiple predictor variables and one or more target variables simultaneously. \"\"\" assert x . ndim == y . ndim # If this is a 'tails' evaluation then then x and y inputs # will have the same number of rows (predictor variables) is_tails = x . shape [ 0 ] == y . shape [ 0 ] ncases = x . shape [ 1 ] nvars = x . shape [ 0 ] for i in numba . prange ( nvars ): if is_tails : r = \\ pearson_nb ( x [ i ], y [ i ]) else : r = \\ pearson_nb ( x [ i ], y [ 0 ]) crit_array [ i ] = r spearman_rho_cpu_nb \u00a4 spearman_rho_cpu_nb ( crit_array , x , y ) Parallelized version of Spearman Rho rank correlation. Supports calculation across multiple predictor variables and one or more target variables simultaneously. Source code in narrowgate/utils/metrics/cpu/spearman_rho.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @numba . jit ( nopython = True , parallel = True ) def spearman_rho_cpu_nb ( crit_array , x , y ): \"\"\" Parallelized version of Spearman Rho rank correlation. Supports calculation across multiple predictor variables and one or more target variables simultaneously. \"\"\" assert x . ndim == y . ndim # If this is a 'tails' evaluation then then x and y inputs # will have the same number of rows (predictor variables) is_tails = x . shape [ 0 ] == y . shape [ 0 ] ncases = x . shape [ 1 ] nvars = x . shape [ 0 ] for i in numba . prange ( nvars ): if is_tails : rho = \\ spearman_nb ( x [ i ], y [ i ]) else : rho = \\ spearman_nb ( x [ i ], y [ 0 ]) crit_array [ i ] = rho quadratic_cpu_nb \u00a4 quadratic_cpu_nb ( crit_array , x , y ) R-squared value of a linear-quadratic regression model being fit to y given a single predictor variable x . The regression model is NOT fit with an intercept. Parameters: Name Type Description Default crit_array np.array modified in-place within function. array where calculated R-squared values will be stored required x np.ndarray matrix of predictor variable values shape: (ncases, nvars) required y np.array array of target values shape: (ncases,) required Source code in narrowgate/utils/metrics/cpu/quadratic.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @numba . jit ( nopython = True , parallel = True , fastmath = True ) def quadratic_cpu_nb ( crit_array , x , y ): \"\"\" R-squared value of a linear-quadratic regression model being fit to `y` given a single predictor variable `x`. The regression model is NOT fit with an intercept. Parameters ---------- crit_array : np.array modified in-place within function. array where calculated R-squared values will be stored x : np.ndarray matrix of predictor variable values shape: (ncases, nvars) y : np.array array of target values shape: (ncases,) \"\"\" assert x . ndim == 2 assert y . ndim == 2 # If this is a 'tails' evaluation then then x and y inputs # will have the same number of rows (predictor variables) is_tails = x . shape [ 0 ] == y . shape [ 0 ] ncases = x . shape [ 1 ] nvars = x . shape [ 0 ] for x_i in numba . prange ( nvars ): # If this is a tails-only iteration, then align x_i with y_i otherwise # just use the single instance of y_i y_i = int ( 0 ) if is_tails : y_i = x_i # standardize the data for stability and simplified calculation # making the target variable have unit variance means that the # mean-squared-error is the unpredictable fraction # Making the predictors have smallish mean and similar variance helps # stability. xmean = 0.0 ymean = 0.0 for j in numba . prange ( ncases ): xmean += x [ x_i , j ] ymean += y [ int32 ( y_i ), j ] xmean /= ncases ymean /= ncases xstd = 1.e-30 ystd = 1.e-30 for j in numba . prange ( ncases ): xdiff = x [ x_i , j ] - xmean ydiff = y [ int32 ( y_i ), j ] - ymean xstd += xdiff * xdiff ystd += ydiff * ydiff xstd = math . sqrt ( xstd / ncases ) ystd = math . sqrt ( ystd / ncases ) # Perform Linear regression with x and x squared x_work = np . zeros (( ncases , 2 )) y_scale = np . zeros ( ncases ) for j in numba . prange ( ncases ): y_scale [ j ] = ( y [ int32 ( y_i ), j ] - ymean ) / ystd x_scale = ( x [ x_i , j ] - xmean ) / xstd x_work [ j , 0 ] = x_scale x_work [ j , 1 ] = x_scale * x_scale coef , _ , _ , _ = \\ np . linalg . lstsq ( x_work , y_scale , rcond = 1.e-7 ) y_pred = np . dot ( x_work , coef ) mse = np . sum ( np . square ( y_scale - y_pred )) / ncases r_squared = 1 - mse crit_array [ x_i ] = r_squared Discrete \u00a4 mutinf_discrete_cpu \u00a4 mutinf_discrete_cpu ( mi_array , x_bins_matrix , y_bins_matrix , x_marginal_matrix , y_marginal_matrix , contingency_matrix , ) Parallelized version of discretized Mutual Information measure. Supports calculation across multiple predictor variables and one or more target variables simultaneously. Source code in narrowgate/utils/metrics/cpu/mutual_information.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @numba . jit ( nopython = True , parallel = True ) def mutinf_discrete_cpu ( mi_array , x_bins_matrix , y_bins_matrix , x_marginal_matrix , y_marginal_matrix , contingency_matrix ): \"\"\" Parallelized version of discretized Mutual Information measure. Supports calculation across multiple predictor variables and one or more target variables simultaneously. \"\"\" assert ( x_marginal_matrix . ndim == 2 ) assert ( y_marginal_matrix . ndim == 2 ) # If this is a 'tails' evaluation then then the two 'bin' matrices # will have the same number of rows (predictor variables) is_tails = x_bins_matrix . shape [ 0 ] == y_bins_matrix . shape [ 0 ] ncases = x_bins_matrix . shape [ 1 ] nvars = x_bins_matrix . shape [ 0 ] nbins_x = x_marginal_matrix . shape [ 1 ] nbins_y = y_marginal_matrix . shape [ 1 ] for i in numba . prange ( nvars ): if is_tails : populate_contingency_matrix_jit ( x_bins_matrix [ i ], y_bins_matrix [ i ], x_marginal_matrix [ i ], y_marginal_matrix [ i ], contingency_matrix [ i ], ncases ) else : populate_contingency_matrix_jit ( x_bins_matrix [ i ], y_bins_matrix [ 0 ], x_marginal_matrix [ i ], y_marginal_matrix [ i ], contingency_matrix [ i ], ncases ) mi = 0.0 for m in range ( nbins_x ): px = x_marginal_matrix [ i , m ] / ncases for n in range ( nbins_y ): py = y_marginal_matrix [ i , n ] / ncases pxy = contingency_matrix [ i , m * nbins_y + n ] / ncases if pxy > 0 : mi += pxy * math . log ( pxy / ( px * py )) mi_array [ i ] = mi mutinf_bivariate_cpu \u00a4 mutinf_bivariate_cpu ( mi_array , col_pairs , x_bins_matrix , x_nbins_matrix , y_bins_matrix , y_nbins , x1x2_marginal_matrix , y_marginal_matrix , contingency_matrix , ) Bivariate Mutual Information measure. Supports calculation across multiple predictor variables and one or more target variables simultaneously. Source code in narrowgate/utils/metrics/cpu/mutual_information.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 @numba . jit ( nopython = True , parallel = True ) def mutinf_bivariate_cpu ( mi_array , col_pairs , x_bins_matrix , x_nbins_matrix , y_bins_matrix , y_nbins , x1x2_marginal_matrix , y_marginal_matrix , contingency_matrix ): \"\"\" Bivariate Mutual Information measure. Supports calculation across multiple predictor variables and one or more target variables simultaneously. \"\"\" ncombos = col_pairs . shape [ 0 ] ncases = y_bins_matrix . shape [ 1 ] # For each combination of variables for c in numba . prange ( ncombos ): x1_idx = col_pairs [ c , 0 ] x2_idx = col_pairs [ c , 1 ] x1_nbins = x_nbins_matrix [ x1_idx , 0 ] x2_nbins = x_nbins_matrix [ x2_idx , 0 ] x1x2_nbins = x1_nbins * x2_nbins populate_bivariate_contingency_matrix_jit ( x_bins_matrix [ x1_idx ], x_bins_matrix [ x2_idx ], y_bins_matrix [ 0 ], x1_nbins , x2_nbins , x1x2_marginal_matrix [ c ], y_marginal_matrix [ c ], contingency_matrix [ c ], ncases ) mi = 0.0 for j in range ( x1x2_nbins ): p_x1x2 = x1x2_marginal_matrix [ c , j ] / ncases for k in range ( y_nbins ): p_y = y_marginal_matrix [ c , k ] / ncases p_x1x2_y = contingency_matrix [ c , j * y_nbins + k ] / ncases if p_x1x2_y > 0 : mi += p_x1x2_y * math . log ( p_x1x2_y / ( p_x1x2 * p_y )) # Normalize 0-1 if x1x2_nbins <= y_nbins : mi /= math . log ( x1x2_nbins ) else : mi /= math . log ( y_nbins ) mi_array [ c ] = mi uncertainty_reduction_cpu \u00a4 uncertainty_reduction_cpu ( ur_array , x_bins_matrix , y_bins_matrix , x_marginal_matrix , y_marginal_matrix , contingency_matrix , ) Parallelized version of Uncertainty Reduction metric. Supports calculation across multiple predictor variables and one or more target variables simultaneously. Source code in narrowgate/utils/metrics/cpu/uncertainty_reduction.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @numba . jit ( nopython = True , parallel = True ) def uncertainty_reduction_cpu ( ur_array , x_bins_matrix , y_bins_matrix , x_marginal_matrix , y_marginal_matrix , contingency_matrix ): \"\"\" Parallelized version of Uncertainty Reduction metric. Supports calculation across multiple predictor variables and one or more target variables simultaneously. \"\"\" assert ( x_marginal_matrix . ndim == 2 ) assert ( y_marginal_matrix . ndim == 2 ) # If this is a 'tails' evaluation then then the two 'bin' matrices # will have the same number of rows (predictor variables) is_tails = x_bins_matrix . shape [ 0 ] == y_bins_matrix . shape [ 0 ] ncases = x_bins_matrix . shape [ 1 ] nvars = x_bins_matrix . shape [ 0 ] nbins_x = x_marginal_matrix . shape [ 1 ] nbins_y = y_marginal_matrix . shape [ 1 ] for i in numba . prange ( nvars ): if is_tails : populate_contingency_matrix_jit ( x_bins_matrix [ i ], y_bins_matrix [ i ], x_marginal_matrix [ i ], y_marginal_matrix [ i ], contingency_matrix [ i ], ncases ) else : populate_contingency_matrix_jit ( x_bins_matrix [ i ], y_bins_matrix [ 0 ], x_marginal_matrix [ i ], y_marginal_matrix [ i ], contingency_matrix [ i ], ncases ) # Test for single bin row or column if nbins_x < 2 or nbins_y < 2 : # Assign value of 0 UR = 0.0 else : UR = ur_array [ i ] entropy_x = 0.0 entropy_y = 0.0 entropy_joint = 0.0 for m in range ( nbins_x ): px = x_marginal_matrix [ i , m ] / ncases if px > 0 : entropy_x -= px * math . log ( px ) else : entropy_x -= 0.0 for n in range ( nbins_y ): py = y_marginal_matrix [ i , n ] / ncases if py > 0 : entropy_y -= py * math . log ( py ) else : entropy_y -= 0.0 for m in range ( nbins_x ): for n in range ( nbins_y ): pxy = contingency_matrix [ i , m * nbins_y + n ] / ncases if pxy > 0 : entropy_joint -= pxy * math . log ( pxy ) else : entropy_joint -= 0.0 if entropy_y > 0 : UR = ( entropy_x + entropy_y - entropy_joint ) / entropy_y else : UR = 0.0 ur_array [ i ] = UR cramers_v_cpu \u00a4 cramers_v_cpu ( v_array , x_bins_matrix , y_bins_matrix , x_marginal_matrix , y_marginal_matrix , contingency_matrix , ) Parallelized version of Cramer's V measure. Supports calculation across multiple predictor variables and one or more target variables simultaneously. Source code in narrowgate/utils/metrics/cpu/cramers_v.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @numba . jit ( nopython = True , parallel = True ) def cramers_v_cpu ( v_array , x_bins_matrix , y_bins_matrix , x_marginal_matrix , y_marginal_matrix , contingency_matrix ): \"\"\" Parallelized version of Cramer's V measure. Supports calculation across multiple predictor variables and one or more target variables simultaneously. \"\"\" assert ( x_marginal_matrix . ndim == 2 ) assert ( y_marginal_matrix . ndim == 2 ) # If this is a 'tails' evaluation then then the two 'bin' matrices # will have the same number of rows (predictor variables) is_tails = x_bins_matrix . shape [ 0 ] == y_bins_matrix . shape [ 0 ] ncases = x_bins_matrix . shape [ 1 ] nvars = x_bins_matrix . shape [ 0 ] nbins_x = x_marginal_matrix . shape [ 1 ] nbins_y = y_marginal_matrix . shape [ 1 ] for i in numba . prange ( nvars ): if is_tails : populate_contingency_matrix_jit ( x_bins_matrix [ i ], y_bins_matrix [ i ], x_marginal_matrix [ i ], y_marginal_matrix [ i ], contingency_matrix [ i ], ncases ) else : populate_contingency_matrix_jit ( x_bins_matrix [ i ], y_bins_matrix [ 0 ], x_marginal_matrix [ i ], y_marginal_matrix [ i ], contingency_matrix [ i ], ncases ) chisq = 0.0 for m in range ( nbins_x ): for n in range ( nbins_y ): expected = ( x_marginal_matrix [ i , m ] / ncases * y_marginal_matrix [ i , n ] / ncases * ncases ) diff = contingency_matrix [ i , m * nbins_y + n ] - expected chisq += ( diff * diff ) / ( expected + 1.e-20 ) V = chisq / ncases if ( nbins_x < nbins_y ): V /= nbins_x - 1 else : V /= nbins_y - 1 v_array [ i ] = math . sqrt ( V )","title":"CPU"},{"location":"utils/metrics_cpu/#metrics-cpu","text":"","title":"Metrics (CPU)"},{"location":"utils/metrics_cpu/#continuous","text":"","title":"Continuous"},{"location":"utils/metrics_cpu/#narrowgate.utils.metrics.utils.pearson_r.pearson_r_cpu_nb","text":"pearson_r_cpu_nb ( crit_array , x , y ) Parallelized version of Pearson's R correlation. Supports calculation across multiple predictor variables and one or more target variables simultaneously. Source code in narrowgate/utils/metrics/cpu/pearson_r.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @numba . jit ( nopython = True , parallel = True ) def pearson_r_cpu_nb ( crit_array , x , y ): \"\"\" Parallelized version of Pearson's R correlation. Supports calculation across multiple predictor variables and one or more target variables simultaneously. \"\"\" assert x . ndim == y . ndim # If this is a 'tails' evaluation then then x and y inputs # will have the same number of rows (predictor variables) is_tails = x . shape [ 0 ] == y . shape [ 0 ] ncases = x . shape [ 1 ] nvars = x . shape [ 0 ] for i in numba . prange ( nvars ): if is_tails : r = \\ pearson_nb ( x [ i ], y [ i ]) else : r = \\ pearson_nb ( x [ i ], y [ 0 ]) crit_array [ i ] = r","title":"pearson_r_cpu_nb()"},{"location":"utils/metrics_cpu/#narrowgate.utils.metrics.utils.spearman_rho.spearman_rho_cpu_nb","text":"spearman_rho_cpu_nb ( crit_array , x , y ) Parallelized version of Spearman Rho rank correlation. Supports calculation across multiple predictor variables and one or more target variables simultaneously. Source code in narrowgate/utils/metrics/cpu/spearman_rho.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @numba . jit ( nopython = True , parallel = True ) def spearman_rho_cpu_nb ( crit_array , x , y ): \"\"\" Parallelized version of Spearman Rho rank correlation. Supports calculation across multiple predictor variables and one or more target variables simultaneously. \"\"\" assert x . ndim == y . ndim # If this is a 'tails' evaluation then then x and y inputs # will have the same number of rows (predictor variables) is_tails = x . shape [ 0 ] == y . shape [ 0 ] ncases = x . shape [ 1 ] nvars = x . shape [ 0 ] for i in numba . prange ( nvars ): if is_tails : rho = \\ spearman_nb ( x [ i ], y [ i ]) else : rho = \\ spearman_nb ( x [ i ], y [ 0 ]) crit_array [ i ] = rho","title":"spearman_rho_cpu_nb()"},{"location":"utils/metrics_cpu/#narrowgate.utils.metrics.utils.quadratic.quadratic_cpu_nb","text":"quadratic_cpu_nb ( crit_array , x , y ) R-squared value of a linear-quadratic regression model being fit to y given a single predictor variable x . The regression model is NOT fit with an intercept. Parameters: Name Type Description Default crit_array np.array modified in-place within function. array where calculated R-squared values will be stored required x np.ndarray matrix of predictor variable values shape: (ncases, nvars) required y np.array array of target values shape: (ncases,) required Source code in narrowgate/utils/metrics/cpu/quadratic.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @numba . jit ( nopython = True , parallel = True , fastmath = True ) def quadratic_cpu_nb ( crit_array , x , y ): \"\"\" R-squared value of a linear-quadratic regression model being fit to `y` given a single predictor variable `x`. The regression model is NOT fit with an intercept. Parameters ---------- crit_array : np.array modified in-place within function. array where calculated R-squared values will be stored x : np.ndarray matrix of predictor variable values shape: (ncases, nvars) y : np.array array of target values shape: (ncases,) \"\"\" assert x . ndim == 2 assert y . ndim == 2 # If this is a 'tails' evaluation then then x and y inputs # will have the same number of rows (predictor variables) is_tails = x . shape [ 0 ] == y . shape [ 0 ] ncases = x . shape [ 1 ] nvars = x . shape [ 0 ] for x_i in numba . prange ( nvars ): # If this is a tails-only iteration, then align x_i with y_i otherwise # just use the single instance of y_i y_i = int ( 0 ) if is_tails : y_i = x_i # standardize the data for stability and simplified calculation # making the target variable have unit variance means that the # mean-squared-error is the unpredictable fraction # Making the predictors have smallish mean and similar variance helps # stability. xmean = 0.0 ymean = 0.0 for j in numba . prange ( ncases ): xmean += x [ x_i , j ] ymean += y [ int32 ( y_i ), j ] xmean /= ncases ymean /= ncases xstd = 1.e-30 ystd = 1.e-30 for j in numba . prange ( ncases ): xdiff = x [ x_i , j ] - xmean ydiff = y [ int32 ( y_i ), j ] - ymean xstd += xdiff * xdiff ystd += ydiff * ydiff xstd = math . sqrt ( xstd / ncases ) ystd = math . sqrt ( ystd / ncases ) # Perform Linear regression with x and x squared x_work = np . zeros (( ncases , 2 )) y_scale = np . zeros ( ncases ) for j in numba . prange ( ncases ): y_scale [ j ] = ( y [ int32 ( y_i ), j ] - ymean ) / ystd x_scale = ( x [ x_i , j ] - xmean ) / xstd x_work [ j , 0 ] = x_scale x_work [ j , 1 ] = x_scale * x_scale coef , _ , _ , _ = \\ np . linalg . lstsq ( x_work , y_scale , rcond = 1.e-7 ) y_pred = np . dot ( x_work , coef ) mse = np . sum ( np . square ( y_scale - y_pred )) / ncases r_squared = 1 - mse crit_array [ x_i ] = r_squared","title":"quadratic_cpu_nb()"},{"location":"utils/metrics_cpu/#discrete","text":"","title":"Discrete"},{"location":"utils/metrics_cpu/#narrowgate.utils.metrics.utils.mutual_information.mutinf_discrete_cpu","text":"mutinf_discrete_cpu ( mi_array , x_bins_matrix , y_bins_matrix , x_marginal_matrix , y_marginal_matrix , contingency_matrix , ) Parallelized version of discretized Mutual Information measure. Supports calculation across multiple predictor variables and one or more target variables simultaneously. Source code in narrowgate/utils/metrics/cpu/mutual_information.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @numba . jit ( nopython = True , parallel = True ) def mutinf_discrete_cpu ( mi_array , x_bins_matrix , y_bins_matrix , x_marginal_matrix , y_marginal_matrix , contingency_matrix ): \"\"\" Parallelized version of discretized Mutual Information measure. Supports calculation across multiple predictor variables and one or more target variables simultaneously. \"\"\" assert ( x_marginal_matrix . ndim == 2 ) assert ( y_marginal_matrix . ndim == 2 ) # If this is a 'tails' evaluation then then the two 'bin' matrices # will have the same number of rows (predictor variables) is_tails = x_bins_matrix . shape [ 0 ] == y_bins_matrix . shape [ 0 ] ncases = x_bins_matrix . shape [ 1 ] nvars = x_bins_matrix . shape [ 0 ] nbins_x = x_marginal_matrix . shape [ 1 ] nbins_y = y_marginal_matrix . shape [ 1 ] for i in numba . prange ( nvars ): if is_tails : populate_contingency_matrix_jit ( x_bins_matrix [ i ], y_bins_matrix [ i ], x_marginal_matrix [ i ], y_marginal_matrix [ i ], contingency_matrix [ i ], ncases ) else : populate_contingency_matrix_jit ( x_bins_matrix [ i ], y_bins_matrix [ 0 ], x_marginal_matrix [ i ], y_marginal_matrix [ i ], contingency_matrix [ i ], ncases ) mi = 0.0 for m in range ( nbins_x ): px = x_marginal_matrix [ i , m ] / ncases for n in range ( nbins_y ): py = y_marginal_matrix [ i , n ] / ncases pxy = contingency_matrix [ i , m * nbins_y + n ] / ncases if pxy > 0 : mi += pxy * math . log ( pxy / ( px * py )) mi_array [ i ] = mi","title":"mutinf_discrete_cpu()"},{"location":"utils/metrics_cpu/#narrowgate.utils.metrics.utils.mutual_information.mutinf_bivariate_cpu","text":"mutinf_bivariate_cpu ( mi_array , col_pairs , x_bins_matrix , x_nbins_matrix , y_bins_matrix , y_nbins , x1x2_marginal_matrix , y_marginal_matrix , contingency_matrix , ) Bivariate Mutual Information measure. Supports calculation across multiple predictor variables and one or more target variables simultaneously. Source code in narrowgate/utils/metrics/cpu/mutual_information.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 @numba . jit ( nopython = True , parallel = True ) def mutinf_bivariate_cpu ( mi_array , col_pairs , x_bins_matrix , x_nbins_matrix , y_bins_matrix , y_nbins , x1x2_marginal_matrix , y_marginal_matrix , contingency_matrix ): \"\"\" Bivariate Mutual Information measure. Supports calculation across multiple predictor variables and one or more target variables simultaneously. \"\"\" ncombos = col_pairs . shape [ 0 ] ncases = y_bins_matrix . shape [ 1 ] # For each combination of variables for c in numba . prange ( ncombos ): x1_idx = col_pairs [ c , 0 ] x2_idx = col_pairs [ c , 1 ] x1_nbins = x_nbins_matrix [ x1_idx , 0 ] x2_nbins = x_nbins_matrix [ x2_idx , 0 ] x1x2_nbins = x1_nbins * x2_nbins populate_bivariate_contingency_matrix_jit ( x_bins_matrix [ x1_idx ], x_bins_matrix [ x2_idx ], y_bins_matrix [ 0 ], x1_nbins , x2_nbins , x1x2_marginal_matrix [ c ], y_marginal_matrix [ c ], contingency_matrix [ c ], ncases ) mi = 0.0 for j in range ( x1x2_nbins ): p_x1x2 = x1x2_marginal_matrix [ c , j ] / ncases for k in range ( y_nbins ): p_y = y_marginal_matrix [ c , k ] / ncases p_x1x2_y = contingency_matrix [ c , j * y_nbins + k ] / ncases if p_x1x2_y > 0 : mi += p_x1x2_y * math . log ( p_x1x2_y / ( p_x1x2 * p_y )) # Normalize 0-1 if x1x2_nbins <= y_nbins : mi /= math . log ( x1x2_nbins ) else : mi /= math . log ( y_nbins ) mi_array [ c ] = mi","title":"mutinf_bivariate_cpu()"},{"location":"utils/metrics_cpu/#narrowgate.utils.metrics.utils.uncertainty_reduction.uncertainty_reduction_cpu","text":"uncertainty_reduction_cpu ( ur_array , x_bins_matrix , y_bins_matrix , x_marginal_matrix , y_marginal_matrix , contingency_matrix , ) Parallelized version of Uncertainty Reduction metric. Supports calculation across multiple predictor variables and one or more target variables simultaneously. Source code in narrowgate/utils/metrics/cpu/uncertainty_reduction.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @numba . jit ( nopython = True , parallel = True ) def uncertainty_reduction_cpu ( ur_array , x_bins_matrix , y_bins_matrix , x_marginal_matrix , y_marginal_matrix , contingency_matrix ): \"\"\" Parallelized version of Uncertainty Reduction metric. Supports calculation across multiple predictor variables and one or more target variables simultaneously. \"\"\" assert ( x_marginal_matrix . ndim == 2 ) assert ( y_marginal_matrix . ndim == 2 ) # If this is a 'tails' evaluation then then the two 'bin' matrices # will have the same number of rows (predictor variables) is_tails = x_bins_matrix . shape [ 0 ] == y_bins_matrix . shape [ 0 ] ncases = x_bins_matrix . shape [ 1 ] nvars = x_bins_matrix . shape [ 0 ] nbins_x = x_marginal_matrix . shape [ 1 ] nbins_y = y_marginal_matrix . shape [ 1 ] for i in numba . prange ( nvars ): if is_tails : populate_contingency_matrix_jit ( x_bins_matrix [ i ], y_bins_matrix [ i ], x_marginal_matrix [ i ], y_marginal_matrix [ i ], contingency_matrix [ i ], ncases ) else : populate_contingency_matrix_jit ( x_bins_matrix [ i ], y_bins_matrix [ 0 ], x_marginal_matrix [ i ], y_marginal_matrix [ i ], contingency_matrix [ i ], ncases ) # Test for single bin row or column if nbins_x < 2 or nbins_y < 2 : # Assign value of 0 UR = 0.0 else : UR = ur_array [ i ] entropy_x = 0.0 entropy_y = 0.0 entropy_joint = 0.0 for m in range ( nbins_x ): px = x_marginal_matrix [ i , m ] / ncases if px > 0 : entropy_x -= px * math . log ( px ) else : entropy_x -= 0.0 for n in range ( nbins_y ): py = y_marginal_matrix [ i , n ] / ncases if py > 0 : entropy_y -= py * math . log ( py ) else : entropy_y -= 0.0 for m in range ( nbins_x ): for n in range ( nbins_y ): pxy = contingency_matrix [ i , m * nbins_y + n ] / ncases if pxy > 0 : entropy_joint -= pxy * math . log ( pxy ) else : entropy_joint -= 0.0 if entropy_y > 0 : UR = ( entropy_x + entropy_y - entropy_joint ) / entropy_y else : UR = 0.0 ur_array [ i ] = UR","title":"uncertainty_reduction_cpu()"},{"location":"utils/metrics_cpu/#narrowgate.utils.metrics.utils.cramers_v.cramers_v_cpu","text":"cramers_v_cpu ( v_array , x_bins_matrix , y_bins_matrix , x_marginal_matrix , y_marginal_matrix , contingency_matrix , ) Parallelized version of Cramer's V measure. Supports calculation across multiple predictor variables and one or more target variables simultaneously. Source code in narrowgate/utils/metrics/cpu/cramers_v.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @numba . jit ( nopython = True , parallel = True ) def cramers_v_cpu ( v_array , x_bins_matrix , y_bins_matrix , x_marginal_matrix , y_marginal_matrix , contingency_matrix ): \"\"\" Parallelized version of Cramer's V measure. Supports calculation across multiple predictor variables and one or more target variables simultaneously. \"\"\" assert ( x_marginal_matrix . ndim == 2 ) assert ( y_marginal_matrix . ndim == 2 ) # If this is a 'tails' evaluation then then the two 'bin' matrices # will have the same number of rows (predictor variables) is_tails = x_bins_matrix . shape [ 0 ] == y_bins_matrix . shape [ 0 ] ncases = x_bins_matrix . shape [ 1 ] nvars = x_bins_matrix . shape [ 0 ] nbins_x = x_marginal_matrix . shape [ 1 ] nbins_y = y_marginal_matrix . shape [ 1 ] for i in numba . prange ( nvars ): if is_tails : populate_contingency_matrix_jit ( x_bins_matrix [ i ], y_bins_matrix [ i ], x_marginal_matrix [ i ], y_marginal_matrix [ i ], contingency_matrix [ i ], ncases ) else : populate_contingency_matrix_jit ( x_bins_matrix [ i ], y_bins_matrix [ 0 ], x_marginal_matrix [ i ], y_marginal_matrix [ i ], contingency_matrix [ i ], ncases ) chisq = 0.0 for m in range ( nbins_x ): for n in range ( nbins_y ): expected = ( x_marginal_matrix [ i , m ] / ncases * y_marginal_matrix [ i , n ] / ncases * ncases ) diff = contingency_matrix [ i , m * nbins_y + n ] - expected chisq += ( diff * diff ) / ( expected + 1.e-20 ) V = chisq / ncases if ( nbins_x < nbins_y ): V /= nbins_x - 1 else : V /= nbins_y - 1 v_array [ i ] = math . sqrt ( V )","title":"cramers_v_cpu()"},{"location":"utils/metrics_gpu/","text":"Metrics (GPU) \u00a4 Discrete \u00a4 mutinf_discrete_gpu \u00a4 mutinf_discrete_gpu ( mi , x_marginal_mat , y_marginal_mat , cont_mat , ncases ) Discretized Mutual Information calculation for the GPU. Source code in narrowgate/utils/metrics/gpu/mutual_information.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @cuda . jit def mutinf_discrete_gpu ( mi , x_marginal_mat , y_marginal_mat , cont_mat , ncases ): \"\"\" Discretized Mutual Information calculation for the GPU. \"\"\" # number of blocks (x) = number of columns # number of blocks (y) = number of bins # number of blocks (z) = number of bins # number of threads (x) = 1 # number of threads (y) = 1 # number of threads (z) = 1 x , y , z = cuda . grid ( 3 ) if x < x_marginal_mat . shape [ 0 ]: if y < x_marginal_mat . shape [ 1 ]: if z < y_marginal_mat . shape [ 0 ]: px = x_marginal_mat [ x , y ] / ncases py = y_marginal_mat [ x , z ] / ncases pxy = cont_mat [ x , y , z ] / ncases if pxy > 0 : tmp = pxy * math . log ( pxy / ( px * py )) cuda . atomic . add ( mi , x , tmp ) entropy_gpu \u00a4 entropy_gpu ( entropy , marginal_mat , ncases ) Entropy calculation for the GPU. Source code in narrowgate/utils/metrics/gpu/uncertainty_reduction.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @cuda . jit def entropy_gpu ( entropy , marginal_mat , ncases ): \"\"\" Entropy calculation for the GPU. \"\"\" x , y = cuda . grid ( 2 ) if x < marginal_mat . shape [ 0 ]: if y < marginal_mat . shape [ 1 ]: p = marginal_mat [ x , y ] / ncases if p > 0 : tmp = p * math . log ( p ) cuda . atomic . add ( entropy , x , - tmp ) uncertainty_reduction_gpu \u00a4 uncertainty_reduction_gpu ( ur , x_marginal_mat , y_marginal_mat , cont_mat , ncases ) INCOMPLETE Uncertainty Reduction calculation for the GPU. Source code in narrowgate/utils/metrics/gpu/uncertainty_reduction.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 @cuda . jit def uncertainty_reduction_gpu ( ur , x_marginal_mat , y_marginal_mat , cont_mat , ncases ): \"\"\" **INCOMPLETE** Uncertainty Reduction calculation for the GPU. \"\"\" # number of blocks (x) = number of columns # number of blocks (y) = number of bins # number of blocks (z) = number of bins # number of threads (x) = 1 # number of threads (y) = 1 # number of threads (z) = 1 x , y , z = cuda . grid ( 3 ) if x < x_marginal_mat . shape [ 0 ]: if y < x_marginal_mat . shape [ 1 ]: if z < y_marginal_mat . shape [ 0 ]: px = x_marginal_mat [ x , y ] / ncases py = y_marginal_mat [ x , z ] / ncases pxy = cont_mat [ x , y , z ] / ncases if pxy > 0 : tmp = pxy * math . log ( pxy / ( px * py )) cuda . atomic . add ( ur , x , tmp )","title":"GPU"},{"location":"utils/metrics_gpu/#metrics-gpu","text":"","title":"Metrics (GPU)"},{"location":"utils/metrics_gpu/#discrete","text":"","title":"Discrete"},{"location":"utils/metrics_gpu/#narrowgate.utils.metrics.utils.mutual_information.mutinf_discrete_gpu","text":"mutinf_discrete_gpu ( mi , x_marginal_mat , y_marginal_mat , cont_mat , ncases ) Discretized Mutual Information calculation for the GPU. Source code in narrowgate/utils/metrics/gpu/mutual_information.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @cuda . jit def mutinf_discrete_gpu ( mi , x_marginal_mat , y_marginal_mat , cont_mat , ncases ): \"\"\" Discretized Mutual Information calculation for the GPU. \"\"\" # number of blocks (x) = number of columns # number of blocks (y) = number of bins # number of blocks (z) = number of bins # number of threads (x) = 1 # number of threads (y) = 1 # number of threads (z) = 1 x , y , z = cuda . grid ( 3 ) if x < x_marginal_mat . shape [ 0 ]: if y < x_marginal_mat . shape [ 1 ]: if z < y_marginal_mat . shape [ 0 ]: px = x_marginal_mat [ x , y ] / ncases py = y_marginal_mat [ x , z ] / ncases pxy = cont_mat [ x , y , z ] / ncases if pxy > 0 : tmp = pxy * math . log ( pxy / ( px * py )) cuda . atomic . add ( mi , x , tmp )","title":"mutinf_discrete_gpu()"},{"location":"utils/metrics_gpu/#narrowgate.utils.metrics.utils.uncertainty_reduction.entropy_gpu","text":"entropy_gpu ( entropy , marginal_mat , ncases ) Entropy calculation for the GPU. Source code in narrowgate/utils/metrics/gpu/uncertainty_reduction.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @cuda . jit def entropy_gpu ( entropy , marginal_mat , ncases ): \"\"\" Entropy calculation for the GPU. \"\"\" x , y = cuda . grid ( 2 ) if x < marginal_mat . shape [ 0 ]: if y < marginal_mat . shape [ 1 ]: p = marginal_mat [ x , y ] / ncases if p > 0 : tmp = p * math . log ( p ) cuda . atomic . add ( entropy , x , - tmp )","title":"entropy_gpu()"},{"location":"utils/metrics_gpu/#narrowgate.utils.metrics.utils.uncertainty_reduction.uncertainty_reduction_gpu","text":"uncertainty_reduction_gpu ( ur , x_marginal_mat , y_marginal_mat , cont_mat , ncases ) INCOMPLETE Uncertainty Reduction calculation for the GPU. Source code in narrowgate/utils/metrics/gpu/uncertainty_reduction.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 @cuda . jit def uncertainty_reduction_gpu ( ur , x_marginal_mat , y_marginal_mat , cont_mat , ncases ): \"\"\" **INCOMPLETE** Uncertainty Reduction calculation for the GPU. \"\"\" # number of blocks (x) = number of columns # number of blocks (y) = number of bins # number of blocks (z) = number of bins # number of threads (x) = 1 # number of threads (y) = 1 # number of threads (z) = 1 x , y , z = cuda . grid ( 3 ) if x < x_marginal_mat . shape [ 0 ]: if y < x_marginal_mat . shape [ 1 ]: if z < y_marginal_mat . shape [ 0 ]: px = x_marginal_mat [ x , y ] / ncases py = y_marginal_mat [ x , z ] / ncases pxy = cont_mat [ x , y , z ] / ncases if pxy > 0 : tmp = pxy * math . log ( pxy / ( px * py )) cuda . atomic . add ( ur , x , tmp )","title":"uncertainty_reduction_gpu()"},{"location":"utils/numba/","text":"A current limitation exists with numba's @jitclass in that it is not able to be pickled, and thereby the state of the model is not able to be saved. As a workaround, the following functions assist in saving and restoring the state of the jitclass models present within narrowgate.model . Information about the class is stored in an ordinary Python dictionary This is not an overly robust solution, but will at least allow the user to persist models. save_jitclass_model \u00a4 save_jitclass_model ( cls ) Saves the state of a jitclass model, cls , as a dictionary object Parameters: Name Type Description Default cls numba.jitclass Numba jitclass required Returns: Name Type Description model_dict dict Dictionary containing the necessary information to restore a jitclass model via load_jitclass_model function. Source code in narrowgate/utils/numba.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def save_jitclass_model ( cls ): \"\"\" Saves the state of a jitclass model, `cls`, as a dictionary object Parameters ---------- cls : numba.jitclass Numba jitclass Returns ------- model_dict : dict Dictionary containing the necessary information to restore a `jitclass` model via `load_jitclass_model` function. \"\"\" typ = cls . _numba_type_ fields = typ . struct model_dict = dict () model_dict [ 'cls' ] = typ . classname model_dict [ 'kwargs' ] = { k : getattr ( cls , k ) for k in fields } return model_dict load_jitclass_model \u00a4 load_jitclass_model ( jitclass_model_dict , module_name = \"narrowgate.model\" ) Restores state of a jitclass model from jitclass_model_dict Parameters: Name Type Description Default jitclass_model_dict dict dictionary containing model state information. produced from save_jitclass_model required module_name str name of module to dynamically load in order to instantiate a new instance of cls (object within jitclass_model_dict ) 'narrowgate.model' Returns: Name Type Description instance numba.jitclass Numba jitclass instance with restored state as present in jitclass_model_dict Source code in narrowgate/utils/numba.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def load_jitclass_model ( jitclass_model_dict : dict , module_name : str = 'narrowgate.model' ): \"\"\" Restores state of a jitclass model from `jitclass_model_dict` Parameters ---------- jitclass_model_dict : dictionary containing model state information. produced from `save_jitclass_model` module_name : name of module to dynamically load in order to instantiate a new instance of `cls` (object within `jitclass_model_dict`) Returns ------- instance : numba.jitclass Numba jitclass instance with restored state as present in `jitclass_model_dict` \"\"\" import importlib module = importlib . import_module ( module_name ) class_ = getattr ( module , jitclass_model_dict [ 'cls' ]) instance = class_ () for key , value in jitclass_model_dict [ 'kwargs' ] . items (): setattr ( instance , key , value ) return instance","title":"Numba"},{"location":"utils/numba/#narrowgate.utils.numba.save_jitclass_model","text":"save_jitclass_model ( cls ) Saves the state of a jitclass model, cls , as a dictionary object Parameters: Name Type Description Default cls numba.jitclass Numba jitclass required Returns: Name Type Description model_dict dict Dictionary containing the necessary information to restore a jitclass model via load_jitclass_model function. Source code in narrowgate/utils/numba.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def save_jitclass_model ( cls ): \"\"\" Saves the state of a jitclass model, `cls`, as a dictionary object Parameters ---------- cls : numba.jitclass Numba jitclass Returns ------- model_dict : dict Dictionary containing the necessary information to restore a `jitclass` model via `load_jitclass_model` function. \"\"\" typ = cls . _numba_type_ fields = typ . struct model_dict = dict () model_dict [ 'cls' ] = typ . classname model_dict [ 'kwargs' ] = { k : getattr ( cls , k ) for k in fields } return model_dict","title":"save_jitclass_model()"},{"location":"utils/numba/#narrowgate.utils.numba.load_jitclass_model","text":"load_jitclass_model ( jitclass_model_dict , module_name = \"narrowgate.model\" ) Restores state of a jitclass model from jitclass_model_dict Parameters: Name Type Description Default jitclass_model_dict dict dictionary containing model state information. produced from save_jitclass_model required module_name str name of module to dynamically load in order to instantiate a new instance of cls (object within jitclass_model_dict ) 'narrowgate.model' Returns: Name Type Description instance numba.jitclass Numba jitclass instance with restored state as present in jitclass_model_dict Source code in narrowgate/utils/numba.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def load_jitclass_model ( jitclass_model_dict : dict , module_name : str = 'narrowgate.model' ): \"\"\" Restores state of a jitclass model from `jitclass_model_dict` Parameters ---------- jitclass_model_dict : dictionary containing model state information. produced from `save_jitclass_model` module_name : name of module to dynamically load in order to instantiate a new instance of `cls` (object within `jitclass_model_dict`) Returns ------- instance : numba.jitclass Numba jitclass instance with restored state as present in `jitclass_model_dict` \"\"\" import importlib module = importlib . import_module ( module_name ) class_ = getattr ( module , jitclass_model_dict [ 'cls' ]) instance = class_ () for key , value in jitclass_model_dict [ 'kwargs' ] . items (): setattr ( instance , key , value ) return instance","title":"load_jitclass_model()"},{"location":"utils/partition_cpu/","text":"Partition (CPU) \u00a4 CPU-specifc functions for partitioning data in parallel. masters_cut_cpu \u00a4 masters_cut_cpu ( data , nbins = 5 , tail_frac = 0.5 ) Function to discretize continuous variables into a user-defined number of bins. Utilizes partitioning algorithm described in reference. Primarily serves as a wrapper for _masters_cut_jit , a numba-JIT function that leverages numba's ParallelAccelerator functionality in order to perform the discretization simultaneously across all variable-target combinations. Parameters: Name Type Description Default data np . ndarray Data to discretize. Variables should be numerical/continuous in nature. shape : (ncases, nvars) required nbins int maximum number of bins into which variables will be partitioned. It is worth noting that this value will be automatically adjusted downwards for any single variable in data where the value for nbins is too large (i.e. small number of unique values present in the variable). 5 tail_frac float The percentage of small and large observations (those residing in the 'tail' of variable's distribution) which will be used for binning purposes. If tail_frac=0.5 , then all values will be considered and the parameter value for nbins will be used. If tail_frac<0.5 then only thoses values in the lower and upper tails will be considered and nbins will automatically be downward adjusted to 2 to represent the values in either tail. 0.5 Returns: Name Type Description results_dict dict The following objects are returned as members of results_dict: bin_matrix contains the data transformed to bin values for each variable in data. array-like (nvars, ncases) idx_matrix contains the index values in sorted order from least to greatest. results are presented in a row-wise fashion to correspond with the data being transposed, i.e. each row is a different variable array_like (nvars, ncases) bounds_matrix contains the values separating each bin for each variable in 'data' array_like (nvars, nbins) n_bins_matrix contains the number of bins calculated for each variable in 'data' as a variable could have been found to support less than 'nbins' bins. array_like (nvars, 1) References \u00a4 Masters, Timothy. (2016) \"Data Mining Algorithms in C++\". pp. 45-48. Source code in narrowgate/utils/partition/cpu.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def masters_cut_cpu ( data : np . ndarray , nbins : int = 5 , tail_frac : float = 0.5 ): \"\"\" Function to discretize continuous variables into a user-defined number of bins. Utilizes partitioning algorithm described in reference. Primarily serves as a wrapper for `_masters_cut_jit`, a numba-JIT function that leverages numba's ParallelAccelerator functionality in order to perform the discretization simultaneously across all variable-target combinations. Parameters ---------- data : Data to discretize. Variables should be numerical/continuous in nature. shape : (ncases, nvars) nbins : maximum number of bins into which variables will be partitioned. It is worth noting that this value will be automatically adjusted downwards for any single variable in `data` where the value for `nbins` is too large (i.e. small number of unique values present in the variable). tail_frac : The percentage of small and large observations (those residing in the 'tail' of variable's distribution) which will be used for binning purposes. If `tail_frac=0.5`, then all values will be considered and the parameter value for `nbins` will be used. If `tail_frac<0.5` then only thoses values in the lower and upper tails will be considered and `nbins` will automatically be downward adjusted to `2` to represent the values in either tail. Returns ------- results_dict : dict The following objects are returned as members of results_dict: `bin_matrix` contains the data transformed to bin values for each variable in data. array-like (nvars, ncases) `idx_matrix` contains the index values in sorted order from least to greatest. results are presented in a row-wise fashion to correspond with the data being transposed, i.e. each row is a different variable array_like (nvars, ncases) `bounds_matrix` contains the values separating each bin for each variable in 'data' array_like (nvars, nbins) `n_bins_matrix` contains the number of bins calculated for each variable in 'data' as a variable could have been found to support less than 'nbins' bins. array_like (nvars, 1) References ---------- Masters, Timothy. (2016) \"Data Mining Algorithms in C++\". pp. 45-48. \"\"\" assert tail_frac > 0 and tail_frac <= 0.5 data_transposed = transpose_data ( data ) ncols = data_transposed . shape [ 0 ] nobs = data_transposed . shape [ 1 ] # Calculate all the necessary tail-related variables # Remember that a 'tail_frac' value of 0.5 is equivalent to using all # observation in 'data' nobs_tail_total = round ( nobs * tail_frac * 2 ) if tail_frac < 0.5 : nbins = 2 tails_only = True else : tails_only = False nobs_tail = round ( nobs * tail_frac ) tail_lower = nobs_tail if tail_frac == 0.5 : tail_upper = nobs_tail else : tail_upper = nobs - nobs_tail # Create the static objects that will be modified in-place during the # call to '_masters_cut_jit' idx_matrix = np . arange ( nobs ) idx_matrix = np . tile ( idx_matrix , ( ncols , 1 )) n_bins_matrix = np . repeat ( nbins , ncols ) . astype ( np . int16 ) n_bins_matrix = np . reshape ( n_bins_matrix , ( ncols , 1 )) bins_matrix = np . zeros (( ncols , nobs_tail_total ), dtype = np . int32 ) bins_matrix . fill ( 5 ) bounds_matrix = np . zeros (( ncols , nbins ), dtype = np . float32 ) tmp_bin_end_matrix = np . zeros (( ncols , nbins ), dtype = np . int32 ) tmp_rank_idx_matrix = np . zeros (( ncols , nobs_tail_total ), dtype = np . int32 ) _masters_cut_jit ( data_transposed , n_bins_matrix , bounds_matrix , bins_matrix , tmp_rank_idx_matrix , tmp_bin_end_matrix , idx_matrix , tail_lower , tail_upper ) results_dict = {} results_dict [ 'bins_matrix' ] = bins_matrix results_dict [ 'n_bins_matrix' ] = n_bins_matrix # return several other objects to assist with target variable # filtering and binning if using tails was a chosen option if tail_frac < 0.5 : results_dict [ 'idx_matrix' ] = idx_matrix results_dict [ 'tail_lower' ] = tail_lower results_dict [ 'tail_upper' ] = tail_upper results_dict [ 'bounds_matrix' ] = bounds_matrix return results_dict tails_cut_cpu \u00a4 tails_cut_cpu ( data , tail_frac = 0.5 ) Filters 'data' to the observations residing in the tails of each variable. Used for continuous predictor variables (i.e. non-discrete/binned) NOTE: A tail_frac parameter value of 0.5 is equivalent to using all observations Leverages a JIT-enabled parallelized numba function ( tail_cut_jit ) for increased performance. Parameters: Name Type Description Default data np . ndarray Data to discretize. Variables should be numerical/continuous in nature. shape : (ncases, nvars) required tail_frac float The percentage of small and large observations (those residing in the 'tail' of variable's distribution) which will be used for binning purposes. If tail_frac=0.5 , then all values will be considered and the parameter value for nbins will be used. If tail_frac<0.5 then only thoses values in the lower and upper tails will be considered and nbins will automatically be downward adjusted to 2 to represent the values in either tail. 0.5 Returns: Name Type Description results_dict dict The following objects are returned as members of results_dict: X contains the data sorted in a row-wise manner (rows correspond to variables) array-like (nvars, ncases) idx_matrix contains the index values in sorted order from least to greatest. results are presented in a row-wise fashion to correspond with the data being transposed, i.e. each row is a different variable array_like (nvars, ncases) Source code in narrowgate/utils/partition/cpu.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 def tails_cut_cpu ( data : np . ndarray , tail_frac : float = 0.5 ): \"\"\" Filters 'data' to the observations residing in the tails of each variable. Used for continuous predictor variables (i.e. non-discrete/binned) NOTE: A `tail_frac` parameter value of 0.5 is equivalent to using all observations Leverages a JIT-enabled parallelized numba function (`tail_cut_jit`) for increased performance. Parameters ---------- data : Data to discretize. Variables should be numerical/continuous in nature. shape : (ncases, nvars) tail_frac : The percentage of small and large observations (those residing in the 'tail' of variable's distribution) which will be used for binning purposes. If `tail_frac=0.5`, then all values will be considered and the parameter value for `nbins` will be used. If `tail_frac<0.5` then only thoses values in the lower and upper tails will be considered and `nbins` will automatically be downward adjusted to `2` to represent the values in either tail. Returns ------- results_dict : dict The following objects are returned as members of results_dict: `X` contains the data sorted in a row-wise manner (rows correspond to variables) array-like (nvars, ncases) `idx_matrix` contains the index values in sorted order from least to greatest. results are presented in a row-wise fashion to correspond with the data being transposed, i.e. each row is a different variable array_like (nvars, ncases) \"\"\" assert tail_frac > 0 and tail_frac <= 0.5 data_t = transpose_data ( data ) nvars = data_t . shape [ 0 ] nobs = data_t . shape [ 1 ] # Calculate all the necessary tail-related variables # Remember that a 'tail_frac' value of 0.5 is equivalent to using all # observation in 'data' nobs_tail_total = round ( nobs * tail_frac * 2 ) if tail_frac < 0.5 : tails_only = True else : tails_only = False nobs_tail = round ( nobs * tail_frac ) tail_lower = nobs_tail if tail_frac == 0.5 : tail_upper = nobs_tail else : tail_upper = nobs - nobs_tail # Create the static objects that will be modified in-place during the # call to '_masters_cut_jit' idx_matrix = np . arange ( nobs ) idx_matrix = np . tile ( idx_matrix , ( nvars , 1 )) results_dict = dict () if tail_frac < 0.5 : # instantiate objects that are going to populated inline idx_matrix_trimmed = np . arange ( nobs_tail_total ) idx_matrix_trimmed = np . tile ( idx_matrix_trimmed , ( nvars , 1 )) data_t_trimmed = np . empty (( nvars , nobs_tail_total )) _tails_cut_jit ( data_t , idx_matrix , data_t_trimmed , idx_matrix_trimmed , tail_lower , tail_upper ) results_dict [ 'X' ] = data_t_trimmed results_dict [ 'idx_matrix' ] = idx_matrix_trimmed else : results_dict [ 'X' ] = data_t results_dict [ 'idx_matrix' ] = idx_matrix return results_dict","title":"CPU"},{"location":"utils/partition_cpu/#partition-cpu","text":"CPU-specifc functions for partitioning data in parallel.","title":"Partition (CPU)"},{"location":"utils/partition_cpu/#narrowgate.utils.partition.cpu.masters_cut_cpu","text":"masters_cut_cpu ( data , nbins = 5 , tail_frac = 0.5 ) Function to discretize continuous variables into a user-defined number of bins. Utilizes partitioning algorithm described in reference. Primarily serves as a wrapper for _masters_cut_jit , a numba-JIT function that leverages numba's ParallelAccelerator functionality in order to perform the discretization simultaneously across all variable-target combinations. Parameters: Name Type Description Default data np . ndarray Data to discretize. Variables should be numerical/continuous in nature. shape : (ncases, nvars) required nbins int maximum number of bins into which variables will be partitioned. It is worth noting that this value will be automatically adjusted downwards for any single variable in data where the value for nbins is too large (i.e. small number of unique values present in the variable). 5 tail_frac float The percentage of small and large observations (those residing in the 'tail' of variable's distribution) which will be used for binning purposes. If tail_frac=0.5 , then all values will be considered and the parameter value for nbins will be used. If tail_frac<0.5 then only thoses values in the lower and upper tails will be considered and nbins will automatically be downward adjusted to 2 to represent the values in either tail. 0.5 Returns: Name Type Description results_dict dict The following objects are returned as members of results_dict: bin_matrix contains the data transformed to bin values for each variable in data. array-like (nvars, ncases) idx_matrix contains the index values in sorted order from least to greatest. results are presented in a row-wise fashion to correspond with the data being transposed, i.e. each row is a different variable array_like (nvars, ncases) bounds_matrix contains the values separating each bin for each variable in 'data' array_like (nvars, nbins) n_bins_matrix contains the number of bins calculated for each variable in 'data' as a variable could have been found to support less than 'nbins' bins. array_like (nvars, 1)","title":"masters_cut_cpu()"},{"location":"utils/partition_cpu/#narrowgate.utils.partition.cpu.masters_cut_cpu--references","text":"Masters, Timothy. (2016) \"Data Mining Algorithms in C++\". pp. 45-48. Source code in narrowgate/utils/partition/cpu.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def masters_cut_cpu ( data : np . ndarray , nbins : int = 5 , tail_frac : float = 0.5 ): \"\"\" Function to discretize continuous variables into a user-defined number of bins. Utilizes partitioning algorithm described in reference. Primarily serves as a wrapper for `_masters_cut_jit`, a numba-JIT function that leverages numba's ParallelAccelerator functionality in order to perform the discretization simultaneously across all variable-target combinations. Parameters ---------- data : Data to discretize. Variables should be numerical/continuous in nature. shape : (ncases, nvars) nbins : maximum number of bins into which variables will be partitioned. It is worth noting that this value will be automatically adjusted downwards for any single variable in `data` where the value for `nbins` is too large (i.e. small number of unique values present in the variable). tail_frac : The percentage of small and large observations (those residing in the 'tail' of variable's distribution) which will be used for binning purposes. If `tail_frac=0.5`, then all values will be considered and the parameter value for `nbins` will be used. If `tail_frac<0.5` then only thoses values in the lower and upper tails will be considered and `nbins` will automatically be downward adjusted to `2` to represent the values in either tail. Returns ------- results_dict : dict The following objects are returned as members of results_dict: `bin_matrix` contains the data transformed to bin values for each variable in data. array-like (nvars, ncases) `idx_matrix` contains the index values in sorted order from least to greatest. results are presented in a row-wise fashion to correspond with the data being transposed, i.e. each row is a different variable array_like (nvars, ncases) `bounds_matrix` contains the values separating each bin for each variable in 'data' array_like (nvars, nbins) `n_bins_matrix` contains the number of bins calculated for each variable in 'data' as a variable could have been found to support less than 'nbins' bins. array_like (nvars, 1) References ---------- Masters, Timothy. (2016) \"Data Mining Algorithms in C++\". pp. 45-48. \"\"\" assert tail_frac > 0 and tail_frac <= 0.5 data_transposed = transpose_data ( data ) ncols = data_transposed . shape [ 0 ] nobs = data_transposed . shape [ 1 ] # Calculate all the necessary tail-related variables # Remember that a 'tail_frac' value of 0.5 is equivalent to using all # observation in 'data' nobs_tail_total = round ( nobs * tail_frac * 2 ) if tail_frac < 0.5 : nbins = 2 tails_only = True else : tails_only = False nobs_tail = round ( nobs * tail_frac ) tail_lower = nobs_tail if tail_frac == 0.5 : tail_upper = nobs_tail else : tail_upper = nobs - nobs_tail # Create the static objects that will be modified in-place during the # call to '_masters_cut_jit' idx_matrix = np . arange ( nobs ) idx_matrix = np . tile ( idx_matrix , ( ncols , 1 )) n_bins_matrix = np . repeat ( nbins , ncols ) . astype ( np . int16 ) n_bins_matrix = np . reshape ( n_bins_matrix , ( ncols , 1 )) bins_matrix = np . zeros (( ncols , nobs_tail_total ), dtype = np . int32 ) bins_matrix . fill ( 5 ) bounds_matrix = np . zeros (( ncols , nbins ), dtype = np . float32 ) tmp_bin_end_matrix = np . zeros (( ncols , nbins ), dtype = np . int32 ) tmp_rank_idx_matrix = np . zeros (( ncols , nobs_tail_total ), dtype = np . int32 ) _masters_cut_jit ( data_transposed , n_bins_matrix , bounds_matrix , bins_matrix , tmp_rank_idx_matrix , tmp_bin_end_matrix , idx_matrix , tail_lower , tail_upper ) results_dict = {} results_dict [ 'bins_matrix' ] = bins_matrix results_dict [ 'n_bins_matrix' ] = n_bins_matrix # return several other objects to assist with target variable # filtering and binning if using tails was a chosen option if tail_frac < 0.5 : results_dict [ 'idx_matrix' ] = idx_matrix results_dict [ 'tail_lower' ] = tail_lower results_dict [ 'tail_upper' ] = tail_upper results_dict [ 'bounds_matrix' ] = bounds_matrix return results_dict","title":"References"},{"location":"utils/partition_cpu/#narrowgate.utils.partition.cpu.tails_cut_cpu","text":"tails_cut_cpu ( data , tail_frac = 0.5 ) Filters 'data' to the observations residing in the tails of each variable. Used for continuous predictor variables (i.e. non-discrete/binned) NOTE: A tail_frac parameter value of 0.5 is equivalent to using all observations Leverages a JIT-enabled parallelized numba function ( tail_cut_jit ) for increased performance. Parameters: Name Type Description Default data np . ndarray Data to discretize. Variables should be numerical/continuous in nature. shape : (ncases, nvars) required tail_frac float The percentage of small and large observations (those residing in the 'tail' of variable's distribution) which will be used for binning purposes. If tail_frac=0.5 , then all values will be considered and the parameter value for nbins will be used. If tail_frac<0.5 then only thoses values in the lower and upper tails will be considered and nbins will automatically be downward adjusted to 2 to represent the values in either tail. 0.5 Returns: Name Type Description results_dict dict The following objects are returned as members of results_dict: X contains the data sorted in a row-wise manner (rows correspond to variables) array-like (nvars, ncases) idx_matrix contains the index values in sorted order from least to greatest. results are presented in a row-wise fashion to correspond with the data being transposed, i.e. each row is a different variable array_like (nvars, ncases) Source code in narrowgate/utils/partition/cpu.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 def tails_cut_cpu ( data : np . ndarray , tail_frac : float = 0.5 ): \"\"\" Filters 'data' to the observations residing in the tails of each variable. Used for continuous predictor variables (i.e. non-discrete/binned) NOTE: A `tail_frac` parameter value of 0.5 is equivalent to using all observations Leverages a JIT-enabled parallelized numba function (`tail_cut_jit`) for increased performance. Parameters ---------- data : Data to discretize. Variables should be numerical/continuous in nature. shape : (ncases, nvars) tail_frac : The percentage of small and large observations (those residing in the 'tail' of variable's distribution) which will be used for binning purposes. If `tail_frac=0.5`, then all values will be considered and the parameter value for `nbins` will be used. If `tail_frac<0.5` then only thoses values in the lower and upper tails will be considered and `nbins` will automatically be downward adjusted to `2` to represent the values in either tail. Returns ------- results_dict : dict The following objects are returned as members of results_dict: `X` contains the data sorted in a row-wise manner (rows correspond to variables) array-like (nvars, ncases) `idx_matrix` contains the index values in sorted order from least to greatest. results are presented in a row-wise fashion to correspond with the data being transposed, i.e. each row is a different variable array_like (nvars, ncases) \"\"\" assert tail_frac > 0 and tail_frac <= 0.5 data_t = transpose_data ( data ) nvars = data_t . shape [ 0 ] nobs = data_t . shape [ 1 ] # Calculate all the necessary tail-related variables # Remember that a 'tail_frac' value of 0.5 is equivalent to using all # observation in 'data' nobs_tail_total = round ( nobs * tail_frac * 2 ) if tail_frac < 0.5 : tails_only = True else : tails_only = False nobs_tail = round ( nobs * tail_frac ) tail_lower = nobs_tail if tail_frac == 0.5 : tail_upper = nobs_tail else : tail_upper = nobs - nobs_tail # Create the static objects that will be modified in-place during the # call to '_masters_cut_jit' idx_matrix = np . arange ( nobs ) idx_matrix = np . tile ( idx_matrix , ( nvars , 1 )) results_dict = dict () if tail_frac < 0.5 : # instantiate objects that are going to populated inline idx_matrix_trimmed = np . arange ( nobs_tail_total ) idx_matrix_trimmed = np . tile ( idx_matrix_trimmed , ( nvars , 1 )) data_t_trimmed = np . empty (( nvars , nobs_tail_total )) _tails_cut_jit ( data_t , idx_matrix , data_t_trimmed , idx_matrix_trimmed , tail_lower , tail_upper ) results_dict [ 'X' ] = data_t_trimmed results_dict [ 'idx_matrix' ] = idx_matrix_trimmed else : results_dict [ 'X' ] = data_t results_dict [ 'idx_matrix' ] = idx_matrix return results_dict","title":"tails_cut_cpu()"},{"location":"utils/partition_gpu/","text":"Partition (GPU) \u00a4 masters_cut_gpu \u00a4 masters_cut_gpu ( data , nbins , verbose = False ) Function to discretize continuous variables into a user-defined number of bins on the GPU. Attempts to be functionally equivalent to masters_cut_cpu as well as support data which may be larger than what fits in GPU memory. Executes the following internal functions: qsortdsi_gpu (qsortdsi_gpu_jit) rank_gpu (rank_jit) compute_initial_bounds_gpu adjust_bounds_gpu determine_bin_bound_values_gpu assign_bin_membership_gpu Parameters: Name Type Description Default data Data to discretize. Variables should be numerical/continuous in nature. shape : (ncases, nvars) required nbins maximum number of bins into which variables will be partitioned. It is worth noting that this value will be automatically adjusted downwards for any single variable in data where the value for nbins is too large (i.e. small number of unique values present in the variable). required Source code in narrowgate/utils/partition/gpu.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 def masters_cut_gpu ( data , nbins , verbose = False ): \"\"\" Function to discretize continuous variables into a user-defined number of bins on the GPU. Attempts to be functionally equivalent to `masters_cut_cpu` as well as support data which may be larger than what fits in GPU memory. Executes the following internal functions: - qsortdsi_gpu (qsortdsi_gpu_jit) - rank_gpu (rank_jit) - compute_initial_bounds_gpu - adjust_bounds_gpu - determine_bin_bound_values_gpu - assign_bin_membership_gpu Parameters ---------- data : Data to discretize. Variables should be numerical/continuous in nature. shape : (ncases, nvars) nbins : maximum number of bins into which variables will be partitioned. It is worth noting that this value will be automatically adjusted downwards for any single variable in `data` where the value for `nbins` is too large (i.e. small number of unique values present in the variable). \"\"\" if verbose : from pynvml import * nvmlInit () handle = nvmlDeviceGetHandleByIndex ( 0 ) info = nvmlDeviceGetMemoryInfo ( handle ) print ( \"BEGIN - function call - Free memory:\" , info . free ) # used memory info = nvmlDeviceGetMemoryInfo ( handle ) print ( \"start - Used memory:\" , info . used ) data_transposed = transpose_data ( data ) ncols = data_transposed . shape [ 0 ] nrows = data_transposed . shape [ 1 ] # Set up cuda stream for timing purposes stream = cuda . stream () # Deleted upon completion: YES tmp_data_transposed_gpu = cuda . to_device ( data_transposed , stream = stream ) # max value for int32 is 2,147,483,647 # limited to this many observations # Deleted upon completion: YES idxs = np . arange ( nrows ) idx_matrix = np . tile ( idxs , ( ncols , 1 )) . astype ( np . int32 ) tmp_idx_matrix_gpu = cuda . to_device ( idx_matrix , stream = stream ) # This tensor is used in the non-recursive sorting algorithm # since numba/cuda does not allow for recursion # Deleted upon completion: YES max_depth = np . int32 (( nrows - 1 ) / 2 ) tmp_sort_tensor_gpu = \\ cuda . device_array (( ncols , max_depth , 2 ), dtype = np . int32 ) # Perform the actual calculations for performing the binning # Set the number of threads and blocks number_of_threads = 1 number_of_blocks = ( ncols + ( number_of_threads - 1 )) // number_of_threads qsortdsi_gpu [( number_of_blocks ,), ( number_of_threads ,), stream ]( tmp_data_transposed_gpu , tmp_idx_matrix_gpu , tmp_sort_tensor_gpu ) # No longer needed del tmp_sort_tensor_gpu if verbose : info = nvmlDeviceGetMemoryInfo ( handle ) print ( \"sort - Used memory:\" , info . used ) tmp_rank_idx_matrix_gpu = \\ cuda . device_array (( ncols , nrows ), dtype = np . int32 ) rank_gpu [( number_of_blocks ,), ( number_of_threads ), stream ]( tmp_data_transposed_gpu , tmp_rank_idx_matrix_gpu ) if verbose : info = nvmlDeviceGetMemoryInfo ( handle ) print ( \"rank - Used memory:\" , info . used ) # Used after 'ranking' the variables to determine the values # that identify the end of a bin given 'n' number of bins # Deleted upon completion: YES tmp_bin_end_matrix_gpu = \\ cuda . device_array (( ncols , nbins ), dtype = np . int32 ) compute_initial_bounds_gpu [( number_of_blocks ,), ( number_of_threads ), stream ]( tmp_bin_end_matrix_gpu , nrows ) if verbose : info = nvmlDeviceGetMemoryInfo ( handle ) print ( \"compute bounds - Used memory:\" , info . used ) # n_bins will track the number of bins for each variable/predictor # It will start off at the number of bins assigned by the user # but be adjusted lower if there are not as many unique values # for the variable (i.e. gender, etc.) # Size: minimal # Deleted after use: NO n_bins_matrix = np . repeat ( nbins , ncols ) . astype ( np . int16 ) n_bins_matrix = np . reshape ( n_bins_matrix , ( ncols , 1 )) n_bins_matrix_gpu = cuda . to_device ( n_bins_matrix , stream = stream ) adjust_bounds_gpu [( number_of_blocks ,), ( number_of_threads ), stream ]( tmp_bin_end_matrix_gpu , tmp_rank_idx_matrix_gpu , n_bins_matrix_gpu ) # No longer needed del tmp_rank_idx_matrix_gpu if verbose : info = nvmlDeviceGetMemoryInfo ( handle ) print ( \"adjust - Used memory:\" , info . used ) # Matrix will store the values of the bin edges. # Deleted upon completion: YES tmp_bounds_matrix_gpu = \\ cuda . device_array (( ncols , nbins ), dtype = np . float32 ) determine_bin_bound_values_gpu [( number_of_blocks ,), ( number_of_threads ,), stream ]( tmp_bounds_matrix_gpu , tmp_data_transposed_gpu , tmp_bin_end_matrix_gpu , n_bins_matrix_gpu ) # No longer needed del tmp_data_transposed_gpu del tmp_bounds_matrix_gpu if verbose : info = nvmlDeviceGetMemoryInfo ( handle ) print ( \"determine - Used memory:\" , info . used ) # Matrix stores the bin to which each observation belongs # Size: same as predictor matrix # Deleted upon completion: NO bins_matrix_gpu = cuda . device_array (( ncols , nrows ), dtype = np . int16 ) assign_bin_membership_gpu [( number_of_blocks , nbins ), ( number_of_threads , number_of_threads ), stream ]( bins_matrix_gpu , tmp_idx_matrix_gpu , tmp_bin_end_matrix_gpu ) if verbose : info = nvmlDeviceGetMemoryInfo ( handle ) print ( \"assign - Used memory:\" , info . used ) #stream.synchronize() #del tmp_idx_matrix_gpu #del tmp_bin_end_matrix_gpu # Trying to figure out the correct place to free the objects in # GPU memory that are no longer needed. Freeing GPU memory is # time consumimg and should be delayed as long as possible. #del tmp_sort_tensor_gpu #del tmp_rank_idx_matrix_gpu #del tmp_data_transposed_gpu #del tmp_bounds_matrix_gpu #del tmp_idx_matrix_gpu #del tmp_bin_end_matrix_gpu if verbose : info = nvmlDeviceGetMemoryInfo ( handle ) print ( \"END - function call - Free memory:\" , info . free ) return bins_matrix_gpu , n_bins_matrix_gpu","title":"GPU"},{"location":"utils/partition_gpu/#partition-gpu","text":"","title":"Partition (GPU)"},{"location":"utils/partition_gpu/#narrowgate.utils.partition.gpu.masters_cut_gpu","text":"masters_cut_gpu ( data , nbins , verbose = False ) Function to discretize continuous variables into a user-defined number of bins on the GPU. Attempts to be functionally equivalent to masters_cut_cpu as well as support data which may be larger than what fits in GPU memory. Executes the following internal functions: qsortdsi_gpu (qsortdsi_gpu_jit) rank_gpu (rank_jit) compute_initial_bounds_gpu adjust_bounds_gpu determine_bin_bound_values_gpu assign_bin_membership_gpu Parameters: Name Type Description Default data Data to discretize. Variables should be numerical/continuous in nature. shape : (ncases, nvars) required nbins maximum number of bins into which variables will be partitioned. It is worth noting that this value will be automatically adjusted downwards for any single variable in data where the value for nbins is too large (i.e. small number of unique values present in the variable). required Source code in narrowgate/utils/partition/gpu.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 def masters_cut_gpu ( data , nbins , verbose = False ): \"\"\" Function to discretize continuous variables into a user-defined number of bins on the GPU. Attempts to be functionally equivalent to `masters_cut_cpu` as well as support data which may be larger than what fits in GPU memory. Executes the following internal functions: - qsortdsi_gpu (qsortdsi_gpu_jit) - rank_gpu (rank_jit) - compute_initial_bounds_gpu - adjust_bounds_gpu - determine_bin_bound_values_gpu - assign_bin_membership_gpu Parameters ---------- data : Data to discretize. Variables should be numerical/continuous in nature. shape : (ncases, nvars) nbins : maximum number of bins into which variables will be partitioned. It is worth noting that this value will be automatically adjusted downwards for any single variable in `data` where the value for `nbins` is too large (i.e. small number of unique values present in the variable). \"\"\" if verbose : from pynvml import * nvmlInit () handle = nvmlDeviceGetHandleByIndex ( 0 ) info = nvmlDeviceGetMemoryInfo ( handle ) print ( \"BEGIN - function call - Free memory:\" , info . free ) # used memory info = nvmlDeviceGetMemoryInfo ( handle ) print ( \"start - Used memory:\" , info . used ) data_transposed = transpose_data ( data ) ncols = data_transposed . shape [ 0 ] nrows = data_transposed . shape [ 1 ] # Set up cuda stream for timing purposes stream = cuda . stream () # Deleted upon completion: YES tmp_data_transposed_gpu = cuda . to_device ( data_transposed , stream = stream ) # max value for int32 is 2,147,483,647 # limited to this many observations # Deleted upon completion: YES idxs = np . arange ( nrows ) idx_matrix = np . tile ( idxs , ( ncols , 1 )) . astype ( np . int32 ) tmp_idx_matrix_gpu = cuda . to_device ( idx_matrix , stream = stream ) # This tensor is used in the non-recursive sorting algorithm # since numba/cuda does not allow for recursion # Deleted upon completion: YES max_depth = np . int32 (( nrows - 1 ) / 2 ) tmp_sort_tensor_gpu = \\ cuda . device_array (( ncols , max_depth , 2 ), dtype = np . int32 ) # Perform the actual calculations for performing the binning # Set the number of threads and blocks number_of_threads = 1 number_of_blocks = ( ncols + ( number_of_threads - 1 )) // number_of_threads qsortdsi_gpu [( number_of_blocks ,), ( number_of_threads ,), stream ]( tmp_data_transposed_gpu , tmp_idx_matrix_gpu , tmp_sort_tensor_gpu ) # No longer needed del tmp_sort_tensor_gpu if verbose : info = nvmlDeviceGetMemoryInfo ( handle ) print ( \"sort - Used memory:\" , info . used ) tmp_rank_idx_matrix_gpu = \\ cuda . device_array (( ncols , nrows ), dtype = np . int32 ) rank_gpu [( number_of_blocks ,), ( number_of_threads ), stream ]( tmp_data_transposed_gpu , tmp_rank_idx_matrix_gpu ) if verbose : info = nvmlDeviceGetMemoryInfo ( handle ) print ( \"rank - Used memory:\" , info . used ) # Used after 'ranking' the variables to determine the values # that identify the end of a bin given 'n' number of bins # Deleted upon completion: YES tmp_bin_end_matrix_gpu = \\ cuda . device_array (( ncols , nbins ), dtype = np . int32 ) compute_initial_bounds_gpu [( number_of_blocks ,), ( number_of_threads ), stream ]( tmp_bin_end_matrix_gpu , nrows ) if verbose : info = nvmlDeviceGetMemoryInfo ( handle ) print ( \"compute bounds - Used memory:\" , info . used ) # n_bins will track the number of bins for each variable/predictor # It will start off at the number of bins assigned by the user # but be adjusted lower if there are not as many unique values # for the variable (i.e. gender, etc.) # Size: minimal # Deleted after use: NO n_bins_matrix = np . repeat ( nbins , ncols ) . astype ( np . int16 ) n_bins_matrix = np . reshape ( n_bins_matrix , ( ncols , 1 )) n_bins_matrix_gpu = cuda . to_device ( n_bins_matrix , stream = stream ) adjust_bounds_gpu [( number_of_blocks ,), ( number_of_threads ), stream ]( tmp_bin_end_matrix_gpu , tmp_rank_idx_matrix_gpu , n_bins_matrix_gpu ) # No longer needed del tmp_rank_idx_matrix_gpu if verbose : info = nvmlDeviceGetMemoryInfo ( handle ) print ( \"adjust - Used memory:\" , info . used ) # Matrix will store the values of the bin edges. # Deleted upon completion: YES tmp_bounds_matrix_gpu = \\ cuda . device_array (( ncols , nbins ), dtype = np . float32 ) determine_bin_bound_values_gpu [( number_of_blocks ,), ( number_of_threads ,), stream ]( tmp_bounds_matrix_gpu , tmp_data_transposed_gpu , tmp_bin_end_matrix_gpu , n_bins_matrix_gpu ) # No longer needed del tmp_data_transposed_gpu del tmp_bounds_matrix_gpu if verbose : info = nvmlDeviceGetMemoryInfo ( handle ) print ( \"determine - Used memory:\" , info . used ) # Matrix stores the bin to which each observation belongs # Size: same as predictor matrix # Deleted upon completion: NO bins_matrix_gpu = cuda . device_array (( ncols , nrows ), dtype = np . int16 ) assign_bin_membership_gpu [( number_of_blocks , nbins ), ( number_of_threads , number_of_threads ), stream ]( bins_matrix_gpu , tmp_idx_matrix_gpu , tmp_bin_end_matrix_gpu ) if verbose : info = nvmlDeviceGetMemoryInfo ( handle ) print ( \"assign - Used memory:\" , info . used ) #stream.synchronize() #del tmp_idx_matrix_gpu #del tmp_bin_end_matrix_gpu # Trying to figure out the correct place to free the objects in # GPU memory that are no longer needed. Freeing GPU memory is # time consumimg and should be delayed as long as possible. #del tmp_sort_tensor_gpu #del tmp_rank_idx_matrix_gpu #del tmp_data_transposed_gpu #del tmp_bounds_matrix_gpu #del tmp_idx_matrix_gpu #del tmp_bin_end_matrix_gpu if verbose : info = nvmlDeviceGetMemoryInfo ( handle ) print ( \"END - function call - Free memory:\" , info . free ) return bins_matrix_gpu , n_bins_matrix_gpu","title":"masters_cut_gpu()"},{"location":"utils/pca/","text":"General purpose functions for use with Principal Component Analysis. horns_method \u00a4 horns_method ( ncases , nvars , nreps ) Horn's method for determining cutoff values for eigenvalues in order to help determine the number of components to be retained during PCA. Given the number of observations and the number of variables, generate 'nreps' covariance matrices using observations from a random normal distribution (zero mean and unit variance) for each variable. The eigenvalues are calculated using these covariance matrices and stored for reference to be used by the PCA class. According to Horn, the median of the ordered eigenvalues at each position will provide a 'cutoff' reference value to the user. All eigenvalues from a subsequent, actual-data principal component calculation which are greater than these reference values should be retained (classified as signal) while the rest should be discarded (classified as noise). Parameters: Name Type Description Default ncases int number of observations required nvars: int number of variables nreps: int number of Monte Carlo reps to perform to calculate reference eigenvalues Returns: Name Type Description eigvals_mat np.ndarray contains the ordered eigenvalues (from greatest to least) for each randomly generated covariance matrix shape: (nreps, nvars) References \u00a4 Horn, J. (1965). \"A rationale and test for the number of factors in factor analysis.\" Psychometrika, 30(2), pp. 179-185. Source code in narrowgate/utils/pca.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @numba . jit ( nopython = True , nogil = True , fastmath = True ) def horns_method ( ncases : int , nvars : int , nreps : int ): \"\"\" Horn's method for determining cutoff values for eigenvalues in order to help determine the number of components to be retained during PCA. Given the number of observations and the number of variables, generate 'nreps' covariance matrices using observations from a random normal distribution (zero mean and unit variance) for each variable. The eigenvalues are calculated using these covariance matrices and stored for reference to be used by the PCA class. According to Horn, the median of the ordered eigenvalues at each position will provide a 'cutoff' reference value to the user. All eigenvalues from a subsequent, actual-data principal component calculation which are greater than these reference values should be retained (classified as signal) while the rest should be discarded (classified as noise). Parameters ---------- ncases: int number of observations nvars: int number of variables nreps: int number of Monte Carlo reps to perform to calculate reference eigenvalues Returns ------- eigvals_mat : np.ndarray contains the ordered eigenvalues (from greatest to least) for each randomly generated covariance matrix shape: (nreps, nvars) References ---------- Horn, J. (1965). \"A rationale and test for the number of factors in factor analysis.\" Psychometrika, 30(2), pp. 179-185. \"\"\" assert nreps > 1 assert nvars > 1 assert ncases > 1 covar = np . zeros (( nreps , nvars , nvars )) sums = np . zeros (( nreps , nvars )) eigvals_mat = np . zeros (( nreps , nvars )) for irep in numba . prange ( nreps ): for icase in numba . prange ( ncases ): # Generate random vector for each 'variable' # in the observation. numba 'nopython' mode # does not support a 'size' parameter for # 'random.normal' so have to iterate this # function within a loop. xvec = np . zeros ( nvars ) for i in numba . prange ( nvars ): xvec [ i ] = np . random . normal () for i in numba . prange ( nvars ): sums [ irep , i ] += xvec [ i ] for j in numba . prange ( i + 1 ): covar [ irep , i , j ] += xvec [ i ] * xvec [ j ] # Compute n_cases times covariances for i in numba . prange ( nvars ): for j in numba . prange ( i + 1 ): covar [ irep , i , j ] -= ( sums [ irep , i ] * sums [ irep , j ]) / ncases # Compute correlation matrix for i in numba . prange ( nvars ): covar [ irep , i , i ] = math . sqrt ( covar [ irep , i , i ]) for j in numba . prange ( i ): covar [ irep , i , j ] /= covar [ irep , i , i ] * covar [ irep , j , j ] covar [ irep , j , i ] = covar [ irep , i , j ] # Definition of correlation matrix for i in numba . prange ( nvars ): covar [ irep , i , i ] = 1.0 eigvals , _ = np . linalg . eig ( covar [ irep ]) # numpy doesn't guarantee ordered eigenvalues. # order them from greatest to least along with their respective # eigenvectors eig_sort_idx = np . argsort ( eigvals )[:: - 1 ] eigvals_mat [ irep ] = eigvals [ eig_sort_idx ] return eigvals_mat","title":"PCA"},{"location":"utils/pca/#narrowgate.utils.pca.horns_method","text":"horns_method ( ncases , nvars , nreps ) Horn's method for determining cutoff values for eigenvalues in order to help determine the number of components to be retained during PCA. Given the number of observations and the number of variables, generate 'nreps' covariance matrices using observations from a random normal distribution (zero mean and unit variance) for each variable. The eigenvalues are calculated using these covariance matrices and stored for reference to be used by the PCA class. According to Horn, the median of the ordered eigenvalues at each position will provide a 'cutoff' reference value to the user. All eigenvalues from a subsequent, actual-data principal component calculation which are greater than these reference values should be retained (classified as signal) while the rest should be discarded (classified as noise). Parameters: Name Type Description Default ncases int number of observations required nvars: int number of variables nreps: int number of Monte Carlo reps to perform to calculate reference eigenvalues Returns: Name Type Description eigvals_mat np.ndarray contains the ordered eigenvalues (from greatest to least) for each randomly generated covariance matrix shape: (nreps, nvars)","title":"horns_method()"},{"location":"utils/pca/#narrowgate.utils.pca.horns_method--references","text":"Horn, J. (1965). \"A rationale and test for the number of factors in factor analysis.\" Psychometrika, 30(2), pp. 179-185. Source code in narrowgate/utils/pca.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @numba . jit ( nopython = True , nogil = True , fastmath = True ) def horns_method ( ncases : int , nvars : int , nreps : int ): \"\"\" Horn's method for determining cutoff values for eigenvalues in order to help determine the number of components to be retained during PCA. Given the number of observations and the number of variables, generate 'nreps' covariance matrices using observations from a random normal distribution (zero mean and unit variance) for each variable. The eigenvalues are calculated using these covariance matrices and stored for reference to be used by the PCA class. According to Horn, the median of the ordered eigenvalues at each position will provide a 'cutoff' reference value to the user. All eigenvalues from a subsequent, actual-data principal component calculation which are greater than these reference values should be retained (classified as signal) while the rest should be discarded (classified as noise). Parameters ---------- ncases: int number of observations nvars: int number of variables nreps: int number of Monte Carlo reps to perform to calculate reference eigenvalues Returns ------- eigvals_mat : np.ndarray contains the ordered eigenvalues (from greatest to least) for each randomly generated covariance matrix shape: (nreps, nvars) References ---------- Horn, J. (1965). \"A rationale and test for the number of factors in factor analysis.\" Psychometrika, 30(2), pp. 179-185. \"\"\" assert nreps > 1 assert nvars > 1 assert ncases > 1 covar = np . zeros (( nreps , nvars , nvars )) sums = np . zeros (( nreps , nvars )) eigvals_mat = np . zeros (( nreps , nvars )) for irep in numba . prange ( nreps ): for icase in numba . prange ( ncases ): # Generate random vector for each 'variable' # in the observation. numba 'nopython' mode # does not support a 'size' parameter for # 'random.normal' so have to iterate this # function within a loop. xvec = np . zeros ( nvars ) for i in numba . prange ( nvars ): xvec [ i ] = np . random . normal () for i in numba . prange ( nvars ): sums [ irep , i ] += xvec [ i ] for j in numba . prange ( i + 1 ): covar [ irep , i , j ] += xvec [ i ] * xvec [ j ] # Compute n_cases times covariances for i in numba . prange ( nvars ): for j in numba . prange ( i + 1 ): covar [ irep , i , j ] -= ( sums [ irep , i ] * sums [ irep , j ]) / ncases # Compute correlation matrix for i in numba . prange ( nvars ): covar [ irep , i , i ] = math . sqrt ( covar [ irep , i , i ]) for j in numba . prange ( i ): covar [ irep , i , j ] /= covar [ irep , i , i ] * covar [ irep , j , j ] covar [ irep , j , i ] = covar [ irep , i , j ] # Definition of correlation matrix for i in numba . prange ( nvars ): covar [ irep , i , i ] = 1.0 eigvals , _ = np . linalg . eig ( covar [ irep ]) # numpy doesn't guarantee ordered eigenvalues. # order them from greatest to least along with their respective # eigenvectors eig_sort_idx = np . argsort ( eigvals )[:: - 1 ] eigvals_mat [ irep ] = eigvals [ eig_sort_idx ] return eigvals_mat","title":"References"},{"location":"utils/sort_cpu/","text":"Sorting (CPU) \u00a4 qsortd_cpu \u00a4 qsortd_cpu ( values ) Numba JIT quicksort sorting function for a single array on the CPU. Reorders values from least to greatest in place. Essentially leverages numpy's sort method to sort values . Parameters: Name Type Description Default values np.ndarray as input, data to be sorted. Upon completion, contains sorted values shape : (ncases,) required Source code in narrowgate/utils/sort/cpu.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @numba . jit ( nopython = True , nogil = True ) def qsortd_cpu ( values ): \"\"\" Numba JIT quicksort sorting function for a single array on the CPU. Reorders `values` from least to greatest in place. Essentially leverages numpy's `sort` method to sort `values`. Parameters ---------- values : np.ndarray as input, data to be sorted. Upon completion, contains sorted values shape : (ncases,) \"\"\" tmp = np . sort ( values ) for i in range ( values . shape [ 0 ]): values [ i ] = tmp [ i ] qsortds_cpu \u00a4 qsortds_cpu ( values , sidecar ) Numba JIT quicksort sorting function for the CPU (with sidecar array). Reorders values from least to greatest while simultaneously reordering a sidecar array in the same sorted order as values . Essentially leverages numpy's argsort method to first sort values and then reorders both values and sidecar using its results. Parameters: Name Type Description Default values np.ndarray as input, data to be sorted. Upon completion, contains sorted values shape : (ncases,) required sidecar np.ndarray as input, array containing same number of observations as values . Upon completion, contains reordered values positionally identical to the sorted values . shape : (ncases, ) required Source code in narrowgate/utils/sort/cpu.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @numba . jit ( nopython = True , nogil = True ) def qsortds_cpu ( values , sidecar ): \"\"\" Numba JIT quicksort sorting function for the CPU (with sidecar array). Reorders `values` from least to greatest while simultaneously reordering a `sidecar` array in the same sorted order as `values`. Essentially leverages numpy's `argsort` method to first sort `values` and then reorders both `values` and `sidecar` using its results. Parameters ---------- values : np.ndarray as input, data to be sorted. Upon completion, contains sorted values shape : (ncases,) sidecar : np.ndarray as input, array containing same number of observations as `values`. Upon completion, contains reordered values positionally identical to the sorted `values`. shape : (ncases, ) \"\"\" assert ( values . shape [ 0 ] == slave . shape [ 0 ]) sorted_idxs = np . argsort ( values ) reorder_jit ( values , sorted_idxs ) reorder_jit ( sidecar , sorted_idxs ) qsortdsi_cpu \u00a4 qsortdsi_cpu ( values , idxs ) Numba JIT quicksort sorting function for the CPU (with index array). Reorders values from least to greatest while simultaneously reordering the indices of these values (residing in idxs ). Essentially leverages numpy's argsort method to first sort values and then reorders both values and idxs using its results. Parameters: Name Type Description Default values np.ndarray as input, data to be sorted. Upon completion, contains sorted values shape : (ncases,) required idxs np.ndarray as input, contains the integer values corresponding to the indices of values . Upon completion, contains the indices corresponding to the sorted values present in values . shape : (ncases, ) required Source code in narrowgate/utils/sort/cpu.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @numba . jit ( nopython = True , nogil = True ) def qsortdsi_cpu ( values , idxs ): \"\"\" Numba JIT quicksort sorting function for the CPU (with index array). Reorders `values` from least to greatest while simultaneously reordering the indices of these values (residing in `idxs`). Essentially leverages numpy's `argsort` method to first sort `values` and then reorders both `values` and `idxs` using its results. Parameters ---------- values : np.ndarray as input, data to be sorted. Upon completion, contains sorted values shape : (ncases,) idxs : np.ndarray as input, contains the integer values corresponding to the indices of `values`. Upon completion, contains the indices corresponding to the sorted values present in `values`. shape : (ncases, ) \"\"\" assert ( values . shape [ 0 ] == idxs . shape [ 0 ]) sorted_idxs = np . argsort ( values ) reorder_jit ( values , sorted_idxs ) reorder_jit ( idxs , sorted_idxs )","title":"CPU"},{"location":"utils/sort_cpu/#sorting-cpu","text":"","title":"Sorting (CPU)"},{"location":"utils/sort_cpu/#narrowgate.utils.sort.cpu.qsortd_cpu","text":"qsortd_cpu ( values ) Numba JIT quicksort sorting function for a single array on the CPU. Reorders values from least to greatest in place. Essentially leverages numpy's sort method to sort values . Parameters: Name Type Description Default values np.ndarray as input, data to be sorted. Upon completion, contains sorted values shape : (ncases,) required Source code in narrowgate/utils/sort/cpu.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @numba . jit ( nopython = True , nogil = True ) def qsortd_cpu ( values ): \"\"\" Numba JIT quicksort sorting function for a single array on the CPU. Reorders `values` from least to greatest in place. Essentially leverages numpy's `sort` method to sort `values`. Parameters ---------- values : np.ndarray as input, data to be sorted. Upon completion, contains sorted values shape : (ncases,) \"\"\" tmp = np . sort ( values ) for i in range ( values . shape [ 0 ]): values [ i ] = tmp [ i ]","title":"qsortd_cpu()"},{"location":"utils/sort_cpu/#narrowgate.utils.sort.cpu.qsortds_cpu","text":"qsortds_cpu ( values , sidecar ) Numba JIT quicksort sorting function for the CPU (with sidecar array). Reorders values from least to greatest while simultaneously reordering a sidecar array in the same sorted order as values . Essentially leverages numpy's argsort method to first sort values and then reorders both values and sidecar using its results. Parameters: Name Type Description Default values np.ndarray as input, data to be sorted. Upon completion, contains sorted values shape : (ncases,) required sidecar np.ndarray as input, array containing same number of observations as values . Upon completion, contains reordered values positionally identical to the sorted values . shape : (ncases, ) required Source code in narrowgate/utils/sort/cpu.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @numba . jit ( nopython = True , nogil = True ) def qsortds_cpu ( values , sidecar ): \"\"\" Numba JIT quicksort sorting function for the CPU (with sidecar array). Reorders `values` from least to greatest while simultaneously reordering a `sidecar` array in the same sorted order as `values`. Essentially leverages numpy's `argsort` method to first sort `values` and then reorders both `values` and `sidecar` using its results. Parameters ---------- values : np.ndarray as input, data to be sorted. Upon completion, contains sorted values shape : (ncases,) sidecar : np.ndarray as input, array containing same number of observations as `values`. Upon completion, contains reordered values positionally identical to the sorted `values`. shape : (ncases, ) \"\"\" assert ( values . shape [ 0 ] == slave . shape [ 0 ]) sorted_idxs = np . argsort ( values ) reorder_jit ( values , sorted_idxs ) reorder_jit ( sidecar , sorted_idxs )","title":"qsortds_cpu()"},{"location":"utils/sort_cpu/#narrowgate.utils.sort.cpu.qsortdsi_cpu","text":"qsortdsi_cpu ( values , idxs ) Numba JIT quicksort sorting function for the CPU (with index array). Reorders values from least to greatest while simultaneously reordering the indices of these values (residing in idxs ). Essentially leverages numpy's argsort method to first sort values and then reorders both values and idxs using its results. Parameters: Name Type Description Default values np.ndarray as input, data to be sorted. Upon completion, contains sorted values shape : (ncases,) required idxs np.ndarray as input, contains the integer values corresponding to the indices of values . Upon completion, contains the indices corresponding to the sorted values present in values . shape : (ncases, ) required Source code in narrowgate/utils/sort/cpu.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @numba . jit ( nopython = True , nogil = True ) def qsortdsi_cpu ( values , idxs ): \"\"\" Numba JIT quicksort sorting function for the CPU (with index array). Reorders `values` from least to greatest while simultaneously reordering the indices of these values (residing in `idxs`). Essentially leverages numpy's `argsort` method to first sort `values` and then reorders both `values` and `idxs` using its results. Parameters ---------- values : np.ndarray as input, data to be sorted. Upon completion, contains sorted values shape : (ncases,) idxs : np.ndarray as input, contains the integer values corresponding to the indices of `values`. Upon completion, contains the indices corresponding to the sorted values present in `values`. shape : (ncases, ) \"\"\" assert ( values . shape [ 0 ] == idxs . shape [ 0 ]) sorted_idxs = np . argsort ( values ) reorder_jit ( values , sorted_idxs ) reorder_jit ( idxs , sorted_idxs )","title":"qsortdsi_cpu()"},{"location":"utils/sort_gpu/","text":"Sorting (GPU) \u00a4 _partition_jit \u00a4 _partition_jit ( values , idxs , left , right ) Partition method. The following argsort code was taken from the following gist: https://gist.github.com/hgrecco/818705ad1eef70f5f6ab Source code in narrowgate/utils/sort/gpu.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @numba . jit ( nopython = True ) def _partition_jit ( values , idxs , left , right ): \"\"\" Partition method. The following argsort code was taken from the following gist: https://gist.github.com/hgrecco/818705ad1eef70f5f6ab \"\"\" piv = values [ idxs [ left ]] i = left + 1 j = right while True : while i <= j and values [ idxs [ i ]] <= piv : i += 1 while j >= i and values [ idxs [ j ]] >= piv : j -= 1 if j <= i : break idxs [ i ], idxs [ j ] = idxs [ j ], idxs [ i ] idxs [ left ], idxs [ j ] = idxs [ j ], idxs [ left ] return j qsortdsi_gpu \u00a4 qsortdsi_gpu ( X , idxs , tmp_sort ) Quicksort sorting function for the GPU. Reorders the values in each ROW of X in place from least to greatest while simultaneously reordering the indices of these values in idxs . The data in X should be transposed where the variables (traditionally represented as columns) will instead the rows and the observations (traditionally represented as rows) wil be the columns. Parameters: Name Type Description Default X cuda device array as input, data to be sorted. Upon completion, contains sorted values shape : (nvars, ncases) required idxs cuda device array as input, contains the integer values corresponding to the indices of X . Upon completion, contains the indices corresponding to the sorted values present in X . shape : (nvars, ncases) required tmp_sort cuda device array temporary cuda device array used during sorting shape : (nvars, ncases) required Source code in narrowgate/utils/sort/gpu.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @cuda . jit def qsortdsi_gpu ( X , idxs , tmp_sort ): \"\"\" Quicksort sorting function for the GPU. Reorders the values in each **ROW** of `X` in place from least to greatest while simultaneously reordering the indices of these values in `idxs`. The data in `X` should be transposed where the variables (traditionally represented as columns) will instead the rows and the observations (traditionally represented as rows) wil be the columns. Parameters ---------- X : cuda device array as input, data to be sorted. Upon completion, contains sorted values shape : (nvars, ncases) idxs : cuda device array as input, contains the integer values corresponding to the indices of `X`. Upon completion, contains the indices corresponding to the sorted values present in `X`. shape : (nvars, ncases) tmp_sort : cuda device array temporary cuda device array used during sorting shape : (nvars, ncases) \"\"\" i = cuda . grid ( 1 ) if i < X . shape [ 0 ]: _qsortdsi_gpu_jit ( X [ i ], idxs [ i ], tmp_sort [ i ]) cuda . syncthreads ()","title":"GPU"},{"location":"utils/sort_gpu/#sorting-gpu","text":"","title":"Sorting (GPU)"},{"location":"utils/sort_gpu/#narrowgate.utils.sort.gpu._partition_jit","text":"_partition_jit ( values , idxs , left , right ) Partition method. The following argsort code was taken from the following gist: https://gist.github.com/hgrecco/818705ad1eef70f5f6ab Source code in narrowgate/utils/sort/gpu.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @numba . jit ( nopython = True ) def _partition_jit ( values , idxs , left , right ): \"\"\" Partition method. The following argsort code was taken from the following gist: https://gist.github.com/hgrecco/818705ad1eef70f5f6ab \"\"\" piv = values [ idxs [ left ]] i = left + 1 j = right while True : while i <= j and values [ idxs [ i ]] <= piv : i += 1 while j >= i and values [ idxs [ j ]] >= piv : j -= 1 if j <= i : break idxs [ i ], idxs [ j ] = idxs [ j ], idxs [ i ] idxs [ left ], idxs [ j ] = idxs [ j ], idxs [ left ] return j","title":"_partition_jit()"},{"location":"utils/sort_gpu/#narrowgate.utils.sort.gpu.qsortdsi_gpu","text":"qsortdsi_gpu ( X , idxs , tmp_sort ) Quicksort sorting function for the GPU. Reorders the values in each ROW of X in place from least to greatest while simultaneously reordering the indices of these values in idxs . The data in X should be transposed where the variables (traditionally represented as columns) will instead the rows and the observations (traditionally represented as rows) wil be the columns. Parameters: Name Type Description Default X cuda device array as input, data to be sorted. Upon completion, contains sorted values shape : (nvars, ncases) required idxs cuda device array as input, contains the integer values corresponding to the indices of X . Upon completion, contains the indices corresponding to the sorted values present in X . shape : (nvars, ncases) required tmp_sort cuda device array temporary cuda device array used during sorting shape : (nvars, ncases) required Source code in narrowgate/utils/sort/gpu.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 @cuda . jit def qsortdsi_gpu ( X , idxs , tmp_sort ): \"\"\" Quicksort sorting function for the GPU. Reorders the values in each **ROW** of `X` in place from least to greatest while simultaneously reordering the indices of these values in `idxs`. The data in `X` should be transposed where the variables (traditionally represented as columns) will instead the rows and the observations (traditionally represented as rows) wil be the columns. Parameters ---------- X : cuda device array as input, data to be sorted. Upon completion, contains sorted values shape : (nvars, ncases) idxs : cuda device array as input, contains the integer values corresponding to the indices of `X`. Upon completion, contains the indices corresponding to the sorted values present in `X`. shape : (nvars, ncases) tmp_sort : cuda device array temporary cuda device array used during sorting shape : (nvars, ncases) \"\"\" i = cuda . grid ( 1 ) if i < X . shape [ 0 ]: _qsortdsi_gpu_jit ( X [ i ], idxs [ i ], tmp_sort [ i ]) cuda . syncthreads ()","title":"qsortdsi_gpu()"},{"location":"utils/stats/","text":"Numba-based statistical functions implemented in nopython mode . The primary reason these functions have been implemented (rather than using existing functions within numpy and scipy ) is that these functions are able to be JIT-compiled and, therefore, integrated into Numba-parallelized loops ( prange ) for maximum performance. These functions have been implemented primarily for use within this package. As a result, robust error checking/handling has not been implemented. While the resultd from these functions do match those given by similar functions in the above-mentioned pacakges, users are strongly advised to review the source code and use cautiously. The majority of these functions have been ported directly from C++ code written by Timothy Masters and freely available at his website . normal_cdf_nb \u00a4 normal_cdf_nb ( z ) Normal Cumulative Distribution Function. Accurate to 7.5 e-8. Parameters: Name Type Description Default z input variable required Source code in narrowgate/utils/stats.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 @numba . jit ( nopython = True ) def normal_cdf_nb ( z ): \"\"\" Normal Cumulative Distribution Function. Accurate to 7.5 e-8. Parameters ---------- z : input variable \"\"\" zz = abs ( z ) pdf = math . exp ( - 0.5 * zz * zz ) / math . sqrt ( 2.0 * 3.141592653589793 ) t = 1.0 / ( 1.0 + zz * 0.2316419 ) poly = (((( 1.330274429 * t - 1.821255978 ) * t + 1.781477937 ) * t - 0.356563782 ) * t + 0.319381530 ) * t if z > 0.0 : x = 1.0 - pdf * poly else : x = pdf * poly return x inverse_normal_cdf_nb \u00a4 inverse_normal_cdf_nb ( p ) Inverse normal CDF ... Accurate to 4.5 e-4 Source code in narrowgate/utils/stats.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @numba . jit ( nopython = True ) def inverse_normal_cdf_nb ( p ): \"\"\" Inverse normal CDF ... Accurate to 4.5 e-4 \"\"\" if p <= 0.5 : pp = p else : pp = 1.0 - p t = math . sqrt ( math . log ( 1 / ( pp * pp ))) numer = ( 0.010328 * t + 0.802853 ) * t + 2.515517 denom = (( 0.001308 * t + 0.189269 ) * t + 1.432788 ) * t + 1.0 x = t - numer / denom if p <= 0.5 : x *= - 1 return x mv_normal_pdf_nb \u00a4 mv_normal_pdf_nb ( x , means , covars ) The probability density function of multivariate normal distribution. Parameters: Name Type Description Default x np.array observation containing the values of multiple variables Shape: (nvars,) required means np.array the mean of z required covars np.ndarray the covarianece matrix of z required Source code in narrowgate/utils/stats.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @numba . jit ( nopython = True ) def mv_normal_pdf_nb ( x , means , covars ): \"\"\" The probability density function of multivariate normal distribution. Parameters --------------- x : np.array observation containing the values of multiple variables Shape: (nvars,) means : np.array the mean of z covars : np.ndarray the covarianece matrix of z \"\"\" x = np . atleast_2d ( x ) means = np . atleast_2d ( means ) covars = np . atleast_2d ( covars ) nvars = x . size denom0 = ( 2 * np . pi ) ** ( nvars / 2 ) denom1 = np . linalg . det ( covars ) ** ( 1 / 2 ) num0 = np . exp ( - .5 * ( x - means ) @ np . linalg . inv ( covars ) @ ( x - means ) . T ) val = num0 / ( denom0 * denom1 ) # is 2d matrix return val [ 0 , 0 ] lgamma_nb \u00a4 lgamma_nb ( x ) Log Gamma (ACM algorithm 291) seems good to about 9-10 significant digits Source code in narrowgate/utils/stats.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 @numba . jit ( nopython = True ) def lgamma_nb ( x ): \"\"\" Log Gamma (ACM algorithm 291) seems good to about 9-10 significant digits \"\"\" result = 0.0 if x <= 0.0 : result = 0.0 else : # x > 0 if x < 7.0 : result = 1.0 z = x while z < 7 : result *= z x = z z += 1.0 x += 1.0 result = - 1 * math . log ( result ) else : result = 0.0 z = 1.0 / ( x * x ) result = result + ( x - 0.5 ) * math . log ( x ) - x + .918938533204673 + \\ ((( - .000595238095238 * z + .000793650793651 ) * z - \\ .002777777777778 ) * z + .083333333333333 ) / x return result igamma_nb \u00a4 igamma_nb ( a , x ) Incomplete Gamma (From Press et al) Note that Chi-square CDF is igamma(df/2, chisq/2) Source code in narrowgate/utils/stats.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 @numba . jit ( nopython = True ) def igamma_nb ( a , x ): \"\"\" Incomplete Gamma (From Press et al) Note that Chi-square CDF is igamma(df/2, chisq/2) \"\"\" FPMIN = 1.e-30 value = 0.0 if x > 0 : if ( x < ( a + 1.0 )): ap = a tmp_del = 1.0 / a tmp_sum = 1.0 / a condition = True while condition : ap += 1.0 tmp_del *= x / ap tmp_sum += tmp_del if tmp_del < ( tmp_sum * 1.e-8 ): condition = False value = tmp_sum * math . exp ( a * math . log ( x ) - x - lgamma_nb ( a )) else : b = x + 1.0 - a c = 1.0 / FPMIN d = 1.0 / b h = d for i in range ( 1 , 1000 ): an = i * ( a - i ) b += 2.0 d = an * d + b if abs ( d ) < FPMIN : d = FPMIN c = b + an / c if abs ( c ) < FPMIN : c = FPMIN d = 1.0 / d tmp_del = d * c h *= tmp_del if abs ( tmp_del - 1.0 ) < 1.e-8 : break value = 1.0 - h * math . exp ( a * math . log ( x ) - x - lgamma_nb ( a )) return value ibeta_nb \u00a4 ibeta_nb ( p , q , x ) Incomplete Beta (ACM algorithm 179 with modifications through 1976) Note that you can set the precision via eps and eps1. Higher precision can result in longer execution time. Parameters: Name Type Description Default p float greater than 0 required q float greater than 0 required x Upper integration limit: 0 <= x <= 1 required Source code in narrowgate/utils/stats.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 @numba . jit ( nopython = True ) def ibeta_nb ( p , q , x ): \"\"\" Incomplete Beta (ACM algorithm 179 with modifications through 1976) Note that you can set the precision via eps and eps1. Higher precision can result in longer execution time. Parameters ---------- p : float greater than 0 q : float greater than 0 x : Upper integration limit: 0 <= x <= 1 \"\"\" # Low precision # Assumed machine precision #eps = 1.e-10 # Tiny representable number (float32 for GPU) #eps1 = 1.e-30 # High precision # Assumed machine precision eps = 1.e-12 # Tiny representable number eps1 = 1.e-30 aleps1 = math . log ( eps1 ) # Verify not below lower limit if x <= 0.0 : return 0.0 # Or above upper limit if x >= 1.0 : return 1.0 # If illegal parameters, return obvious error flag if ( p <= 0.0 ) or ( q <= 0.0 ): return - 1.0 # Switch the arguments if needed for better convergence if x > 0.5 : temp = p p = q q = temp x = 1.0 - x switched_args = 1 else : switched_args = 0 # Define ps as 1 if q is an integer, else q - (int) q ps = q - int ( q ) if ps == 0.0 : ps = 1.0 # Compute INFSUM px = p * math . log ( x ) pq = math . lgamma_nb ( p + q ) p1 = math . lgamma_nb ( p ) d4 = math . log ( p ) # First term term = px + math . lgamma_nb ( ps + p ) - math . lgamma_nb ( ps ) - d4 - p1 # If first term does not underflow if int ( term / aleps1 ) == 0 : infsum = math . exp ( term ) cnt = infsum * p # Avoid underflow wh = 0.0 underflow_avoided = False while not underflow_avoided : wh += 1.0 cnt *= ( wh - ps ) * x / wh term = cnt / ( p + wh ) infsum += term if ( term / eps <= infsum ): underflow_avoided = True else : # First term underflowed infsum = 0.0 # Compute FINSUM finsum = 0.0 #print('q: ' + str(q)) if ( q > 1.0 ): xb = \\ px + q * math . log ( 1.0 - x ) + pq - p1 - math . log ( q ) - math . lgamma_nb ( q ) #print('xb: ' + str(xb)) ib = int ( xb / aleps1 ) #print('ib: ' + str(ib)) if ib < 0 : ib = 0 xfac = 1.0 / ( 1.0 - x ) term = math . exp ( xb - ib * aleps1 ) ps = q wh = q - 1 while wh > 0.0 : px = ps * xfac / ( p + wh ) if ( px <= 1.0 ) and ((( term / eps ) <= finsum ) or ( term <= ( eps1 / px ))): break ps = wh term *= px # Scale if about to underflow if term > 1.0 : ib -= 1 term *= eps1 # Only if no underflow is sum cumulated if ib == 0 : finsum += term # Decrement wh wh -= 1.0 prob = finsum + infsum if switched_args : return 1.0 - prob else : return prob F_cdf_nb \u00a4 F_cdf_nb ( ndf1 , ndf2 , F ) F-distribution Cumulative Distribution Function Source code in narrowgate/utils/stats.py 311 312 313 314 315 316 317 318 319 320 321 322 @numba . jit ( nopython = True ) def F_cdf_nb ( ndf1 , ndf2 , F ): \"\"\" F-distribution Cumulative Distribution Function \"\"\" prob = 1.0 - ibeta_nb ( 0.5 * ndf2 , 0.5 * ndf1 , ndf2 / ( ndf2 + ndf1 * F )) # Trivial rounding errors can produce out-of-bound results if prob < 0.0 : prob = 0.0 if prob > 1.0 : prob = 1.0 return prob U_test_nb \u00a4 U_test_nb ( x1 , x2 ) Mann-Whitney U-test This functions returns 'U' based on x1 relative to x2, thus allowing a one-tailed test. 'U' will be small when the mean of x1 is greater than that of x2. Note that U' = n1 * n2 - U. Most tables perform a two-tailed test by considering the smaller of U and U'. This function also returns the normal approximation for the one-tailed test, good when the the number of items in x1 and x2 add to be greater than 20. The sign of z if flipped so z>0 when mean1 > mean2. Source code in narrowgate/utils/stats.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 @numba . jit ( nopython = True , fastmath = True ) def U_test_nb ( x1 , x2 ): \"\"\" Mann-Whitney U-test This functions returns 'U' based on x1 relative to x2, thus allowing a one-tailed test. 'U' will be small when the mean of x1 is greater than that of x2. Note that U' = n1 * n2 - U. Most tables perform a two-tailed test by considering the smaller of U and U'. This function also returns the normal approximation for the one-tailed test, good when the the number of items in x1 and x2 add to be greater than 20. The sign of z if flipped so z>0 when mean1 > mean2. \"\"\" n1 = x1 . shape [ 0 ] n2 = x2 . shape [ 0 ] n = n1 + n2 # Create an array that can hold both x1 and x2 # Then copy the data into and sort, preserving membership. work = np . zeros ( n1 + n2 , dtype = np . float32 ) iwork = np . zeros ( n1 + n2 , dtype = np . int32 ) for i in range ( n1 ): work [ i ] = x1 [ i ] for i in range ( n2 ): work [ n1 + i ] = x2 [ i ] iwork [ n1 + i ] = 1 qsortdsi_cpu ( work , iwork ) # Compute the ranks and tie correction tie_correc = 0.0 j = 0 # For each case in sorted x array while j < n : val = work [ j ] # Find all ties # Check for when j+1 == n # and bypass for loop if j + 1 == n : k = n else : for k in range ( j + 1 , n ): if ( work [ k ] > val ): break ntied = k - j tie_correc += ntied * ntied * ntied - ntied rank = 0.5 * ( j + k + 1 ) while j < k : work [ j ] = rank j += 1 # Compute the U-statistic U = 0.0 for i in range ( n ): if iwork [ i ] == 0 : U += work [ i ] U = n1 * n2 + 0.5 * ( n1 * ( n1 + 1.0 )) - U # Compute the normal approximation dn = n term1 = n1 * n2 / ( dn * ( dn - 1.0 )) term2 = ( dn * dn * dn - dn - tie_correc ) / 12.0 z = ( 0.5 * n1 * n2 - U ) / math . sqrt ( term1 * term2 ) return U , z spearman_nb \u00a4 spearman_nb ( var1 , var2 ) Spearman-rho rank correlation Source code in narrowgate/utils/stats.py 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 @numba . jit ( nopython = True , parallel = True ) def spearman_nb ( var1 , var2 ): \"\"\" Spearman-rho rank correlation \"\"\" n1 = var1 . shape [ 0 ] n2 = var2 . shape [ 0 ] assert ( n1 == n2 ) n = n1 # copy var1 and var2 into working arrays x = var1 . copy () y = var2 . copy () # Compute ties in x, compute correction as: # - sum(ties**3 - ties) # The following routine sorts x ascending # and simultaneously moves y qsortds_cpu ( x , y ) x_tie_correc = 0.0 # Convert x to ranks, cumulate tie corec # For each case in sorted x array j = 0 while j < n : val = x [ j ] # Find all ties k = j + 1 while k < n : if x [ k ] > val : break k += 1 ntied = k - j x_tie_correc += ntied * ntied * ntied - ntied rank = 0.5 * ( j + k + 1 ) while j < k : x [ j ] = rank j += 1 # Do the same for y qsortds_cpu ( y , x ) y_tie_correc = 0.0 # Convert y to ranks, cumulate tie corec j = 0 while j < n : val = y [ j ] # Find all ties k = j + 1 while k < n : if y [ k ] > val : break k += 1 ntied = k - j y_tie_correc += ntied * ntied * ntied - ntied rank = 0.5 * ( j + k + 1 ) while j < k : y [ j ] = rank j += 1 # Final computations dn = n ssx = ( dn * dn * dn - dn - x_tie_correc ) / 12.0 ssy = ( dn * dn * dn - dn - y_tie_correc ) / 12.0 rankerr = 0.0 # Cumulate squared rank differences for j in numba . prange ( n ): diff = x [ j ] - y [ j ] rankerr += diff * diff rho = 0.5 * ( ssx + ssy - rankerr ) / math . sqrt ( ssx * ssy + 1.e-20 ) return rho pearson_nb \u00a4 pearson_nb ( x , y ) Pearson-R correlation Source code in narrowgate/utils/stats.py 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 @numba . jit ( nopython = True , parallel = True , fastmath = True ) def pearson_nb ( x , y ): \"\"\" Pearson-R correlation \"\"\" assert ( x . ndim == 1 ) assert ( y . ndim == 1 ) n_x = x . shape [ 0 ] n_y = y . shape [ 0 ] assert ( n_x == n_y ) ncases = n_x xmean = 0.0 ymean = 0.0 for i in numba . prange ( ncases ): xmean += x [ i ] ymean += y [ i ] xmean /= ncases ymean /= ncases xvar = 1.e-30 yvar = 1.e-30 xy = 1.e-30 for i in numba . prange ( ncases ): xdiff = x [ i ] - xmean ydiff = y [ i ] - ymean xvar += xdiff * xdiff yvar += ydiff * ydiff xy += xdiff * ydiff r = xy / math . sqrt ( xvar * yvar ) return r autocorr_nb \u00a4 autocorr_nb ( x , max_lag ) Autocorrelation. Parameters: Name Type Description Default x np.array array of values used in autocorrelation evaluation required max_lag int the maximum number of lags to evaluate for autocorrelation required Source code in narrowgate/utils/stats.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 @numba . jit ( nopython = True , parallel = True ) def autocorr_nb ( x , max_lag ): \"\"\" Autocorrelation. Parameters ----------- x : np.array array of values used in autocorrelation evaluation max_lag : int the maximum number of lags to evaluate for autocorrelation \"\"\" n = x . shape [ 0 ] acorr = np . zeros ( max_lag ) x_mean = np . nanmean ( x ) x_std = np . nanstd ( x ) for lag in numba . prange ( 1 , max_lag + 1 ): corr = 0.0 for icase in range ( lag , n ): diff1 = x [ icase ] - x_mean diff2 = x [ icase - lag ] - x_mean corr += diff1 * diff2 # Dividing by n reduces the bias. # Limit to +/-1 in case of fpt errors. corr /= n * x_std * x_std if ( corr > 1.0 ): corr = 1.0 if ( corr < - 1.0 ): corr = - 1.0 acorr [ lag - 1 ] = corr pcorr = burg_nb ( x , max_lag ) return acorr , pcorr burg_nb \u00a4 burg_nb ( x , maxlag ) Partial correlation function using Burg's method Use J. P. Burg's version of the Levinson recursion to estimate partial autocorrelations of a series. Parameters: Name Type Description Default x np.array array of values used in evaluation required max_lag int the maximum number of lags to evaluate required Source code in narrowgate/utils/stats.py 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 @numba . jit ( nopython = True ) def burg_nb ( x , maxlag ): \"\"\" Partial correlation function using Burg's method Use J. P. Burg's version of the Levinson recursion to estimate partial autocorrelations of a series. Parameters ----------- x : np.array array of values used in evaluation max_lag : int the maximum number of lags to evaluate \"\"\" n = x . shape [ 0 ] alpha = np . zeros ( n ) beta = np . zeros ( n ) pcorr = np . zeros ( maxlag ) coefs = np . zeros ( maxlag ) prev = np . zeros ( maxlag ) # center the signal mean = 0.0 for i in range ( n ): mean += x [ i ] mean /= n coef = x [ 0 ] - mean for i in range ( n - 1 ): alpha [ i ] = coef coef = x [ i + 1 ] - mean beta [ i ] = coef # Recursively compute partial autocorrelations for lag in range ( 1 , maxlag ): # compute partial autocorr for 'lag' numer = 0.0 denom = 0.0 for i in range ( n - lag ): term1 = alpha [ i ] term2 = beta [ i ] numer += term1 * term2 denom += ( term1 * term1 ) + ( term2 * term2 ) coef = 2.0 * numer / ( denom + 1.e-40 ) pcorr [ lag - 1 ] = coef coefs [ lag - 1 ] = coef # adjust previous coes per this new one for i in range ( lag - 1 ): coefs [ i ] = prev [ i ] - ( coef * prev [ lag - i - 2 ]) # save these for next for i in range ( lag ): prev [ i ] = coefs [ i ] for i in range ( n - lag - 1 ): alpha [ i ] -= coef * beta [ i ] beta [ i ] = beta [ i + 1 ] - ( coef * alpha [ i + 1 ]) return pcorr","title":"Statistics"},{"location":"utils/stats/#narrowgate.utils.stats.normal_cdf_nb","text":"normal_cdf_nb ( z ) Normal Cumulative Distribution Function. Accurate to 7.5 e-8. Parameters: Name Type Description Default z input variable required Source code in narrowgate/utils/stats.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 @numba . jit ( nopython = True ) def normal_cdf_nb ( z ): \"\"\" Normal Cumulative Distribution Function. Accurate to 7.5 e-8. Parameters ---------- z : input variable \"\"\" zz = abs ( z ) pdf = math . exp ( - 0.5 * zz * zz ) / math . sqrt ( 2.0 * 3.141592653589793 ) t = 1.0 / ( 1.0 + zz * 0.2316419 ) poly = (((( 1.330274429 * t - 1.821255978 ) * t + 1.781477937 ) * t - 0.356563782 ) * t + 0.319381530 ) * t if z > 0.0 : x = 1.0 - pdf * poly else : x = pdf * poly return x","title":"normal_cdf_nb()"},{"location":"utils/stats/#narrowgate.utils.stats.inverse_normal_cdf_nb","text":"inverse_normal_cdf_nb ( p ) Inverse normal CDF ... Accurate to 4.5 e-4 Source code in narrowgate/utils/stats.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @numba . jit ( nopython = True ) def inverse_normal_cdf_nb ( p ): \"\"\" Inverse normal CDF ... Accurate to 4.5 e-4 \"\"\" if p <= 0.5 : pp = p else : pp = 1.0 - p t = math . sqrt ( math . log ( 1 / ( pp * pp ))) numer = ( 0.010328 * t + 0.802853 ) * t + 2.515517 denom = (( 0.001308 * t + 0.189269 ) * t + 1.432788 ) * t + 1.0 x = t - numer / denom if p <= 0.5 : x *= - 1 return x","title":"inverse_normal_cdf_nb()"},{"location":"utils/stats/#narrowgate.utils.stats.mv_normal_pdf_nb","text":"mv_normal_pdf_nb ( x , means , covars ) The probability density function of multivariate normal distribution. Parameters: Name Type Description Default x np.array observation containing the values of multiple variables Shape: (nvars,) required means np.array the mean of z required covars np.ndarray the covarianece matrix of z required Source code in narrowgate/utils/stats.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @numba . jit ( nopython = True ) def mv_normal_pdf_nb ( x , means , covars ): \"\"\" The probability density function of multivariate normal distribution. Parameters --------------- x : np.array observation containing the values of multiple variables Shape: (nvars,) means : np.array the mean of z covars : np.ndarray the covarianece matrix of z \"\"\" x = np . atleast_2d ( x ) means = np . atleast_2d ( means ) covars = np . atleast_2d ( covars ) nvars = x . size denom0 = ( 2 * np . pi ) ** ( nvars / 2 ) denom1 = np . linalg . det ( covars ) ** ( 1 / 2 ) num0 = np . exp ( - .5 * ( x - means ) @ np . linalg . inv ( covars ) @ ( x - means ) . T ) val = num0 / ( denom0 * denom1 ) # is 2d matrix return val [ 0 , 0 ]","title":"mv_normal_pdf_nb()"},{"location":"utils/stats/#narrowgate.utils.stats.lgamma_nb","text":"lgamma_nb ( x ) Log Gamma (ACM algorithm 291) seems good to about 9-10 significant digits Source code in narrowgate/utils/stats.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 @numba . jit ( nopython = True ) def lgamma_nb ( x ): \"\"\" Log Gamma (ACM algorithm 291) seems good to about 9-10 significant digits \"\"\" result = 0.0 if x <= 0.0 : result = 0.0 else : # x > 0 if x < 7.0 : result = 1.0 z = x while z < 7 : result *= z x = z z += 1.0 x += 1.0 result = - 1 * math . log ( result ) else : result = 0.0 z = 1.0 / ( x * x ) result = result + ( x - 0.5 ) * math . log ( x ) - x + .918938533204673 + \\ ((( - .000595238095238 * z + .000793650793651 ) * z - \\ .002777777777778 ) * z + .083333333333333 ) / x return result","title":"lgamma_nb()"},{"location":"utils/stats/#narrowgate.utils.stats.igamma_nb","text":"igamma_nb ( a , x ) Incomplete Gamma (From Press et al) Note that Chi-square CDF is igamma(df/2, chisq/2) Source code in narrowgate/utils/stats.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 @numba . jit ( nopython = True ) def igamma_nb ( a , x ): \"\"\" Incomplete Gamma (From Press et al) Note that Chi-square CDF is igamma(df/2, chisq/2) \"\"\" FPMIN = 1.e-30 value = 0.0 if x > 0 : if ( x < ( a + 1.0 )): ap = a tmp_del = 1.0 / a tmp_sum = 1.0 / a condition = True while condition : ap += 1.0 tmp_del *= x / ap tmp_sum += tmp_del if tmp_del < ( tmp_sum * 1.e-8 ): condition = False value = tmp_sum * math . exp ( a * math . log ( x ) - x - lgamma_nb ( a )) else : b = x + 1.0 - a c = 1.0 / FPMIN d = 1.0 / b h = d for i in range ( 1 , 1000 ): an = i * ( a - i ) b += 2.0 d = an * d + b if abs ( d ) < FPMIN : d = FPMIN c = b + an / c if abs ( c ) < FPMIN : c = FPMIN d = 1.0 / d tmp_del = d * c h *= tmp_del if abs ( tmp_del - 1.0 ) < 1.e-8 : break value = 1.0 - h * math . exp ( a * math . log ( x ) - x - lgamma_nb ( a )) return value","title":"igamma_nb()"},{"location":"utils/stats/#narrowgate.utils.stats.ibeta_nb","text":"ibeta_nb ( p , q , x ) Incomplete Beta (ACM algorithm 179 with modifications through 1976) Note that you can set the precision via eps and eps1. Higher precision can result in longer execution time. Parameters: Name Type Description Default p float greater than 0 required q float greater than 0 required x Upper integration limit: 0 <= x <= 1 required Source code in narrowgate/utils/stats.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 @numba . jit ( nopython = True ) def ibeta_nb ( p , q , x ): \"\"\" Incomplete Beta (ACM algorithm 179 with modifications through 1976) Note that you can set the precision via eps and eps1. Higher precision can result in longer execution time. Parameters ---------- p : float greater than 0 q : float greater than 0 x : Upper integration limit: 0 <= x <= 1 \"\"\" # Low precision # Assumed machine precision #eps = 1.e-10 # Tiny representable number (float32 for GPU) #eps1 = 1.e-30 # High precision # Assumed machine precision eps = 1.e-12 # Tiny representable number eps1 = 1.e-30 aleps1 = math . log ( eps1 ) # Verify not below lower limit if x <= 0.0 : return 0.0 # Or above upper limit if x >= 1.0 : return 1.0 # If illegal parameters, return obvious error flag if ( p <= 0.0 ) or ( q <= 0.0 ): return - 1.0 # Switch the arguments if needed for better convergence if x > 0.5 : temp = p p = q q = temp x = 1.0 - x switched_args = 1 else : switched_args = 0 # Define ps as 1 if q is an integer, else q - (int) q ps = q - int ( q ) if ps == 0.0 : ps = 1.0 # Compute INFSUM px = p * math . log ( x ) pq = math . lgamma_nb ( p + q ) p1 = math . lgamma_nb ( p ) d4 = math . log ( p ) # First term term = px + math . lgamma_nb ( ps + p ) - math . lgamma_nb ( ps ) - d4 - p1 # If first term does not underflow if int ( term / aleps1 ) == 0 : infsum = math . exp ( term ) cnt = infsum * p # Avoid underflow wh = 0.0 underflow_avoided = False while not underflow_avoided : wh += 1.0 cnt *= ( wh - ps ) * x / wh term = cnt / ( p + wh ) infsum += term if ( term / eps <= infsum ): underflow_avoided = True else : # First term underflowed infsum = 0.0 # Compute FINSUM finsum = 0.0 #print('q: ' + str(q)) if ( q > 1.0 ): xb = \\ px + q * math . log ( 1.0 - x ) + pq - p1 - math . log ( q ) - math . lgamma_nb ( q ) #print('xb: ' + str(xb)) ib = int ( xb / aleps1 ) #print('ib: ' + str(ib)) if ib < 0 : ib = 0 xfac = 1.0 / ( 1.0 - x ) term = math . exp ( xb - ib * aleps1 ) ps = q wh = q - 1 while wh > 0.0 : px = ps * xfac / ( p + wh ) if ( px <= 1.0 ) and ((( term / eps ) <= finsum ) or ( term <= ( eps1 / px ))): break ps = wh term *= px # Scale if about to underflow if term > 1.0 : ib -= 1 term *= eps1 # Only if no underflow is sum cumulated if ib == 0 : finsum += term # Decrement wh wh -= 1.0 prob = finsum + infsum if switched_args : return 1.0 - prob else : return prob","title":"ibeta_nb()"},{"location":"utils/stats/#narrowgate.utils.stats.F_cdf_nb","text":"F_cdf_nb ( ndf1 , ndf2 , F ) F-distribution Cumulative Distribution Function Source code in narrowgate/utils/stats.py 311 312 313 314 315 316 317 318 319 320 321 322 @numba . jit ( nopython = True ) def F_cdf_nb ( ndf1 , ndf2 , F ): \"\"\" F-distribution Cumulative Distribution Function \"\"\" prob = 1.0 - ibeta_nb ( 0.5 * ndf2 , 0.5 * ndf1 , ndf2 / ( ndf2 + ndf1 * F )) # Trivial rounding errors can produce out-of-bound results if prob < 0.0 : prob = 0.0 if prob > 1.0 : prob = 1.0 return prob","title":"F_cdf_nb()"},{"location":"utils/stats/#narrowgate.utils.stats.U_test_nb","text":"U_test_nb ( x1 , x2 ) Mann-Whitney U-test This functions returns 'U' based on x1 relative to x2, thus allowing a one-tailed test. 'U' will be small when the mean of x1 is greater than that of x2. Note that U' = n1 * n2 - U. Most tables perform a two-tailed test by considering the smaller of U and U'. This function also returns the normal approximation for the one-tailed test, good when the the number of items in x1 and x2 add to be greater than 20. The sign of z if flipped so z>0 when mean1 > mean2. Source code in narrowgate/utils/stats.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 @numba . jit ( nopython = True , fastmath = True ) def U_test_nb ( x1 , x2 ): \"\"\" Mann-Whitney U-test This functions returns 'U' based on x1 relative to x2, thus allowing a one-tailed test. 'U' will be small when the mean of x1 is greater than that of x2. Note that U' = n1 * n2 - U. Most tables perform a two-tailed test by considering the smaller of U and U'. This function also returns the normal approximation for the one-tailed test, good when the the number of items in x1 and x2 add to be greater than 20. The sign of z if flipped so z>0 when mean1 > mean2. \"\"\" n1 = x1 . shape [ 0 ] n2 = x2 . shape [ 0 ] n = n1 + n2 # Create an array that can hold both x1 and x2 # Then copy the data into and sort, preserving membership. work = np . zeros ( n1 + n2 , dtype = np . float32 ) iwork = np . zeros ( n1 + n2 , dtype = np . int32 ) for i in range ( n1 ): work [ i ] = x1 [ i ] for i in range ( n2 ): work [ n1 + i ] = x2 [ i ] iwork [ n1 + i ] = 1 qsortdsi_cpu ( work , iwork ) # Compute the ranks and tie correction tie_correc = 0.0 j = 0 # For each case in sorted x array while j < n : val = work [ j ] # Find all ties # Check for when j+1 == n # and bypass for loop if j + 1 == n : k = n else : for k in range ( j + 1 , n ): if ( work [ k ] > val ): break ntied = k - j tie_correc += ntied * ntied * ntied - ntied rank = 0.5 * ( j + k + 1 ) while j < k : work [ j ] = rank j += 1 # Compute the U-statistic U = 0.0 for i in range ( n ): if iwork [ i ] == 0 : U += work [ i ] U = n1 * n2 + 0.5 * ( n1 * ( n1 + 1.0 )) - U # Compute the normal approximation dn = n term1 = n1 * n2 / ( dn * ( dn - 1.0 )) term2 = ( dn * dn * dn - dn - tie_correc ) / 12.0 z = ( 0.5 * n1 * n2 - U ) / math . sqrt ( term1 * term2 ) return U , z","title":"U_test_nb()"},{"location":"utils/stats/#narrowgate.utils.stats.spearman_nb","text":"spearman_nb ( var1 , var2 ) Spearman-rho rank correlation Source code in narrowgate/utils/stats.py 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 @numba . jit ( nopython = True , parallel = True ) def spearman_nb ( var1 , var2 ): \"\"\" Spearman-rho rank correlation \"\"\" n1 = var1 . shape [ 0 ] n2 = var2 . shape [ 0 ] assert ( n1 == n2 ) n = n1 # copy var1 and var2 into working arrays x = var1 . copy () y = var2 . copy () # Compute ties in x, compute correction as: # - sum(ties**3 - ties) # The following routine sorts x ascending # and simultaneously moves y qsortds_cpu ( x , y ) x_tie_correc = 0.0 # Convert x to ranks, cumulate tie corec # For each case in sorted x array j = 0 while j < n : val = x [ j ] # Find all ties k = j + 1 while k < n : if x [ k ] > val : break k += 1 ntied = k - j x_tie_correc += ntied * ntied * ntied - ntied rank = 0.5 * ( j + k + 1 ) while j < k : x [ j ] = rank j += 1 # Do the same for y qsortds_cpu ( y , x ) y_tie_correc = 0.0 # Convert y to ranks, cumulate tie corec j = 0 while j < n : val = y [ j ] # Find all ties k = j + 1 while k < n : if y [ k ] > val : break k += 1 ntied = k - j y_tie_correc += ntied * ntied * ntied - ntied rank = 0.5 * ( j + k + 1 ) while j < k : y [ j ] = rank j += 1 # Final computations dn = n ssx = ( dn * dn * dn - dn - x_tie_correc ) / 12.0 ssy = ( dn * dn * dn - dn - y_tie_correc ) / 12.0 rankerr = 0.0 # Cumulate squared rank differences for j in numba . prange ( n ): diff = x [ j ] - y [ j ] rankerr += diff * diff rho = 0.5 * ( ssx + ssy - rankerr ) / math . sqrt ( ssx * ssy + 1.e-20 ) return rho","title":"spearman_nb()"},{"location":"utils/stats/#narrowgate.utils.stats.pearson_nb","text":"pearson_nb ( x , y ) Pearson-R correlation Source code in narrowgate/utils/stats.py 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 @numba . jit ( nopython = True , parallel = True , fastmath = True ) def pearson_nb ( x , y ): \"\"\" Pearson-R correlation \"\"\" assert ( x . ndim == 1 ) assert ( y . ndim == 1 ) n_x = x . shape [ 0 ] n_y = y . shape [ 0 ] assert ( n_x == n_y ) ncases = n_x xmean = 0.0 ymean = 0.0 for i in numba . prange ( ncases ): xmean += x [ i ] ymean += y [ i ] xmean /= ncases ymean /= ncases xvar = 1.e-30 yvar = 1.e-30 xy = 1.e-30 for i in numba . prange ( ncases ): xdiff = x [ i ] - xmean ydiff = y [ i ] - ymean xvar += xdiff * xdiff yvar += ydiff * ydiff xy += xdiff * ydiff r = xy / math . sqrt ( xvar * yvar ) return r","title":"pearson_nb()"},{"location":"utils/stats/#narrowgate.utils.stats.autocorr_nb","text":"autocorr_nb ( x , max_lag ) Autocorrelation. Parameters: Name Type Description Default x np.array array of values used in autocorrelation evaluation required max_lag int the maximum number of lags to evaluate for autocorrelation required Source code in narrowgate/utils/stats.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 @numba . jit ( nopython = True , parallel = True ) def autocorr_nb ( x , max_lag ): \"\"\" Autocorrelation. Parameters ----------- x : np.array array of values used in autocorrelation evaluation max_lag : int the maximum number of lags to evaluate for autocorrelation \"\"\" n = x . shape [ 0 ] acorr = np . zeros ( max_lag ) x_mean = np . nanmean ( x ) x_std = np . nanstd ( x ) for lag in numba . prange ( 1 , max_lag + 1 ): corr = 0.0 for icase in range ( lag , n ): diff1 = x [ icase ] - x_mean diff2 = x [ icase - lag ] - x_mean corr += diff1 * diff2 # Dividing by n reduces the bias. # Limit to +/-1 in case of fpt errors. corr /= n * x_std * x_std if ( corr > 1.0 ): corr = 1.0 if ( corr < - 1.0 ): corr = - 1.0 acorr [ lag - 1 ] = corr pcorr = burg_nb ( x , max_lag ) return acorr , pcorr","title":"autocorr_nb()"},{"location":"utils/stats/#narrowgate.utils.stats.burg_nb","text":"burg_nb ( x , maxlag ) Partial correlation function using Burg's method Use J. P. Burg's version of the Levinson recursion to estimate partial autocorrelations of a series. Parameters: Name Type Description Default x np.array array of values used in evaluation required max_lag int the maximum number of lags to evaluate required Source code in narrowgate/utils/stats.py 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 @numba . jit ( nopython = True ) def burg_nb ( x , maxlag ): \"\"\" Partial correlation function using Burg's method Use J. P. Burg's version of the Levinson recursion to estimate partial autocorrelations of a series. Parameters ----------- x : np.array array of values used in evaluation max_lag : int the maximum number of lags to evaluate \"\"\" n = x . shape [ 0 ] alpha = np . zeros ( n ) beta = np . zeros ( n ) pcorr = np . zeros ( maxlag ) coefs = np . zeros ( maxlag ) prev = np . zeros ( maxlag ) # center the signal mean = 0.0 for i in range ( n ): mean += x [ i ] mean /= n coef = x [ 0 ] - mean for i in range ( n - 1 ): alpha [ i ] = coef coef = x [ i + 1 ] - mean beta [ i ] = coef # Recursively compute partial autocorrelations for lag in range ( 1 , maxlag ): # compute partial autocorr for 'lag' numer = 0.0 denom = 0.0 for i in range ( n - lag ): term1 = alpha [ i ] term2 = beta [ i ] numer += term1 * term2 denom += ( term1 * term1 ) + ( term2 * term2 ) coef = 2.0 * numer / ( denom + 1.e-40 ) pcorr [ lag - 1 ] = coef coefs [ lag - 1 ] = coef # adjust previous coes per this new one for i in range ( lag - 1 ): coefs [ i ] = prev [ i ] - ( coef * prev [ lag - i - 2 ]) # save these for next for i in range ( lag ): prev [ i ] = coefs [ i ] for i in range ( n - lag - 1 ): alpha [ i ] -= coef * beta [ i ] beta [ i ] = beta [ i + 1 ] - ( coef * alpha [ i + 1 ]) return pcorr","title":"burg_nb()"},{"location":"utils/test/","text":"These functions can be utilized to generate synthetic data sets in order to demonstrate functionality of the various screening classes present within this package. generate_masters_sample_regression_data \u00a4 generate_masters_sample_regression_data ( n_obs , n_cols , random_state = 32 ) Generates sample data similar to that used by Timothy Masters in his books to demonstrate feature screening algorithms. Produces a Pandas DataFrame with a target column 'y' which is the sum of two columns. Each of these two columns will, themselves, be the sum of two columns of randomly generated values. As a result, the screening methods should reveal the target variable 'y' having extremely strong information measures for the first two columns, and relevant information measures for an additional 4 columns within the synthetically-generated dataset. Parameters: Name Type Description Default n_obs int number of rows/observations in the synthetically-generated data set required n_cols int number of colums in the generated data set not including the target variable. required random_state int random integer value used for reproducibility 32 Returns: Name Type Description X pd.DataFrame synthetically-generated data set with a target variable column 'y' and 'n_cols' predictor columns of which 6 variables should possess non-random information measures in relation to the target variable shape: (n_obs, n_cols+1) y pd.Series Target variable shape: (n_obs,) Source code in narrowgate/utils/test.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def generate_masters_sample_regression_data ( n_obs : int , n_cols : int , random_state : int = 32 ): \"\"\" Generates sample data similar to that used by Timothy Masters in his books to demonstrate feature screening algorithms. Produces a Pandas DataFrame with a target column 'y' which is the sum of two columns. Each of these two columns will, themselves, be the sum of two columns of randomly generated values. As a result, the screening methods should reveal the target variable 'y' having extremely strong information measures for the first two columns, and relevant information measures for an additional 4 columns within the synthetically-generated dataset. Parameters ---------- n_obs: number of rows/observations in the synthetically-generated data set n_cols: number of colums in the generated data set not including the target variable. random_state: random integer value used for reproducibility Returns ------- X : pd.DataFrame synthetically-generated data set with a target variable column 'y' and 'n_cols' predictor columns of which 6 variables should possess non-random information measures in relation to the target variable shape: (n_obs, n_cols+1) y : pd.Series Target variable shape: (n_obs,) \"\"\" assert n_obs >= 100 , \"'n_obs' should have a value of at least 100\" assert n_cols >= 10 , \"'n_cols' should have a value of at least 10\" rng = np . random . default_rng ( seed = random_state ) X = rng . random ( n_obs * n_cols ) . astype ( np . float32 ) X = np . reshape ( X , ( n_obs , n_cols )) #sum23 X [:, 0 ] = X [:, 2 ] + X [:, 3 ] #sum45 X [:, 1 ] = X [:, 4 ] + X [:, 5 ] # Dependent variable (sum1234) y = X [:, 0 ] + X [:, 1 ] colnames = [ 'y' ] + [ f 'x_ { i } ' for i in range ( X . shape [ 1 ])] X = np . hstack (( y . reshape ( - 1 , 1 ), X )) X = pd . DataFrame ( X , columns = colnames ) return X , y make_regression_with_categoricals \u00a4 make_regression_with_categoricals ( n_obs = 100 , n_cat_cols = 10 , n_cat_informative = 10 , n_cats_per_col = 10 , imbalance = 0.0 , noise = 1.0 , n_cont_cols = 0 , cont_weight = 0.1 , interactions = 0.0 , random_state = 32 , ) Generates a regression-targeted data set with categorical features. Note: This code has been adapted from the code present within the blog post written by Brendan Hasz and available at the following URL: https://brendanhasz.github.io/2019/03/04/target-encoding.html#data As an enhancement, this funciton includes a random_state parameter which supports reproducibility. In addition, several parameter names have been changed to more closely align with naming conventions used within this package. Parameters: Name Type Description Default n_obs int Number of rows/observations in the synthetically-generated data set 100 n_cat_cols int Number of categorical columns to generate 10 n_cat_informative int Number of categorical columns that are informationally-related to the target variable 10 n_cats_per_col int Number of categories per categorical column 10 imbalance float Imbalance between the number of observations of each category in an individual categorical column. The default value of 0 will generate the same number of observations for each category within an individual categorical column. Increasing this value will result in a higher number of observations in some categories vs other categories. 0.0 noise float Noise to add to target variable 1.0 n_cont_cols int Number of continuous (non-categorical) columns to include in the generated data set 0 cont_weight float Weight of the effect of the continuous variables on the target variable 0.1 interactions float Proportion of the variance due to interaction effects. Note that this only adds interaction effects between the categorical features and not the continuous features. 0.0 random_state int random integer value used for reproducibility 32 Returns: Name Type Description X pandas DataFrame Synthetically-generated data set shape: (n_obs, n_cat_cols+n_cont_features) y pandas Series Target variable shape: (n_obs,) Source code in narrowgate/utils/test.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def make_regression_with_categoricals ( n_obs : int = 100 , n_cat_cols : int = 10 , n_cat_informative : int = 10 , n_cats_per_col : int = 10 , imbalance : float = 0.0 , noise : float = 1.0 , n_cont_cols : int = 0 , cont_weight : float = 0.1 , interactions : float = 0.0 , random_state : int = 32 ): \"\"\" Generates a regression-targeted data set with categorical features. **Note:** This code has been adapted from the code present within the blog post written by Brendan Hasz and available at the following URL: https://brendanhasz.github.io/2019/03/04/target-encoding.html#data As an enhancement, this funciton includes a `random_state` parameter which supports reproducibility. In addition, several parameter names have been changed to more closely align with naming conventions used within this package. Parameters ---------- n_obs: int Number of rows/observations in the synthetically-generated data set n_cat_cols: int Number of categorical columns to generate n_cat_informative: int Number of categorical columns that are informationally-related to the target variable n_cats_per_col: int Number of categories per categorical column imbalance: float Imbalance between the number of observations of each category in an individual categorical column. The default value of 0 will generate the same number of observations for each category within an individual categorical column. Increasing this value will result in a higher number of observations in some categories vs other categories. noise: float Noise to add to target variable n_cont_cols: int Number of continuous (non-categorical) columns to include in the generated data set cont_weight: float Weight of the effect of the continuous variables on the target variable interactions: float Proportion of the variance due to interaction effects. Note that this only adds interaction effects between the categorical features and not the continuous features. random_state: random integer value used for reproducibility Returns ------- X : pandas DataFrame Synthetically-generated data set shape: (n_obs, n_cat_cols+n_cont_features) y : pandas Series Target variable shape: (n_obs,) \"\"\" def beta_binomial ( n , a , b ): \"\"\" Beta-binomial probability mass function. \"\"\" from scipy.special import beta from scipy.misc import comb k = np . arange ( n + 1 ) return comb ( n , k ) * beta ( k + a , n - k + b ) / beta ( a , b ) if not isinstance ( n_obs , int ): raise TypeError ( 'n_obs must be an int' ) elif n_obs < 1 : raise ValueError ( 'n_obs must be one or greater' ) if not isinstance ( n_cat_cols , int ): raise TypeError ( 'n_cat_cols must be an int' ) elif n_cat_cols < 1 : raise ValueError ( 'n_cat_cols must be one or greater' ) if not isinstance ( n_cat_informative , int ): raise TypeError ( 'n_cat_informative must be an int' ) elif n_cat_informative < 0 : raise ValueError ( 'n_cat_informative must be non-negative' ) if not isinstance ( n_cats_per_col , int ): raise TypeError ( 'n_cats_per_col must be an int' ) if n_cats_per_col < 1 : raise ValueError ( 'n_cats_per_col must be one or greater' ) if not isinstance ( imbalance , float ): raise TypeError ( 'imbalance must be a float' ) elif imbalance < 0 : raise ValueError ( 'imbalance must be non-negative' ) if not isinstance ( noise , float ): raise TypeError ( 'noise must be a float' ) elif noise < 0 : raise ValueError ( 'noise must be positive' ) if not isinstance ( n_cont_features , int ): raise TypeError ( 'n_cont_features must be an int' ) elif n_cont_features < 0 : raise ValueError ( 'n_cont_features must be non-negative' ) if not isinstance ( cont_weight , float ): raise TypeError ( 'cont_weight must be a float' ) elif cont_weight < 0 : raise ValueError ( 'cont_weight must be non-negative' ) if not isinstance ( interactions , float ): raise TypeError ( 'interactions must be a float' ) elif interactions < 0 : raise ValueError ( 'interactions must be non-negative' ) rng = np . random . default_rng ( seed = random_state ) # Generate random categorical data # category probabilities are drawn from a beta-binomial distribution # with alpha=1 and beta=imbalance+1 cat_probs = beta_binomial ( n_cats_per_col - 1 , 1.0 , imbalance + 1 ) categories = np . empty (( n_obs , n_cat_cols ), dtype = 'uint64' ) for iC in range ( n_cat_cols ): categories [:, iC ] = rng . random . choice ( np . arange ( n_cats_per_col ), size = n_obs , p = cat_probs ) # Generate random values for each category cat_vals = rng . random . randn ( n_cats_per_col , n_cat_cols ) # Set non-informative columns' effect to 0 cat_vals [:,:( n_cat_cols - n_cat_informative )] = 0 # Compute target variable from categories and their values y = np . zeros ( n_obs ) for iC in range ( n_cat_cols ): y += ( 1.0 - interactions ) * cat_vals [ categories [:, iC ], iC ] # Add interaction effects if interactions > 0 : for iC1 in range ( n_cat_informative ): for iC2 in range ( iC1 + 1 , n_cat_informative ): int_vals = rng . random . randn ( n_cats_per_col , n_cats_per_col ) y += interactions * int_vals [ categories [:, iC1 ], categories [:, iC2 ]] # Add noise y += noise * rng . random . randn ( n_obs ) # Generate dataframe from categories cat_strs = [ '' . join ([ chr ( ord ( c ) + 49 ) for c in str ( n )]) for n in range ( n_cats_per_col )] X = pd . DataFrame () for iC in range ( n_cat_cols ): col_str = 'categorical_' + str ( iC ) X [ col_str ] = [ cat_strs [ i ] for i in categories [:, iC ]] # Add continuous features for iC in range ( n_cont_features ): col_str = 'continuous_' + str ( iC ) X [ col_str ] = cont_weight * rng . random . randn ( n_obs ) y += rng . random . randn () * X [ col_str ] # Generate series from target y = pd . Series ( data = y , index = X . index ) # Return features and target return X , y","title":"Testing"},{"location":"utils/test/#narrowgate.utils.test.generate_masters_sample_regression_data","text":"generate_masters_sample_regression_data ( n_obs , n_cols , random_state = 32 ) Generates sample data similar to that used by Timothy Masters in his books to demonstrate feature screening algorithms. Produces a Pandas DataFrame with a target column 'y' which is the sum of two columns. Each of these two columns will, themselves, be the sum of two columns of randomly generated values. As a result, the screening methods should reveal the target variable 'y' having extremely strong information measures for the first two columns, and relevant information measures for an additional 4 columns within the synthetically-generated dataset. Parameters: Name Type Description Default n_obs int number of rows/observations in the synthetically-generated data set required n_cols int number of colums in the generated data set not including the target variable. required random_state int random integer value used for reproducibility 32 Returns: Name Type Description X pd.DataFrame synthetically-generated data set with a target variable column 'y' and 'n_cols' predictor columns of which 6 variables should possess non-random information measures in relation to the target variable shape: (n_obs, n_cols+1) y pd.Series Target variable shape: (n_obs,) Source code in narrowgate/utils/test.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def generate_masters_sample_regression_data ( n_obs : int , n_cols : int , random_state : int = 32 ): \"\"\" Generates sample data similar to that used by Timothy Masters in his books to demonstrate feature screening algorithms. Produces a Pandas DataFrame with a target column 'y' which is the sum of two columns. Each of these two columns will, themselves, be the sum of two columns of randomly generated values. As a result, the screening methods should reveal the target variable 'y' having extremely strong information measures for the first two columns, and relevant information measures for an additional 4 columns within the synthetically-generated dataset. Parameters ---------- n_obs: number of rows/observations in the synthetically-generated data set n_cols: number of colums in the generated data set not including the target variable. random_state: random integer value used for reproducibility Returns ------- X : pd.DataFrame synthetically-generated data set with a target variable column 'y' and 'n_cols' predictor columns of which 6 variables should possess non-random information measures in relation to the target variable shape: (n_obs, n_cols+1) y : pd.Series Target variable shape: (n_obs,) \"\"\" assert n_obs >= 100 , \"'n_obs' should have a value of at least 100\" assert n_cols >= 10 , \"'n_cols' should have a value of at least 10\" rng = np . random . default_rng ( seed = random_state ) X = rng . random ( n_obs * n_cols ) . astype ( np . float32 ) X = np . reshape ( X , ( n_obs , n_cols )) #sum23 X [:, 0 ] = X [:, 2 ] + X [:, 3 ] #sum45 X [:, 1 ] = X [:, 4 ] + X [:, 5 ] # Dependent variable (sum1234) y = X [:, 0 ] + X [:, 1 ] colnames = [ 'y' ] + [ f 'x_ { i } ' for i in range ( X . shape [ 1 ])] X = np . hstack (( y . reshape ( - 1 , 1 ), X )) X = pd . DataFrame ( X , columns = colnames ) return X , y","title":"generate_masters_sample_regression_data()"},{"location":"utils/test/#narrowgate.utils.test.make_regression_with_categoricals","text":"make_regression_with_categoricals ( n_obs = 100 , n_cat_cols = 10 , n_cat_informative = 10 , n_cats_per_col = 10 , imbalance = 0.0 , noise = 1.0 , n_cont_cols = 0 , cont_weight = 0.1 , interactions = 0.0 , random_state = 32 , ) Generates a regression-targeted data set with categorical features. Note: This code has been adapted from the code present within the blog post written by Brendan Hasz and available at the following URL: https://brendanhasz.github.io/2019/03/04/target-encoding.html#data As an enhancement, this funciton includes a random_state parameter which supports reproducibility. In addition, several parameter names have been changed to more closely align with naming conventions used within this package. Parameters: Name Type Description Default n_obs int Number of rows/observations in the synthetically-generated data set 100 n_cat_cols int Number of categorical columns to generate 10 n_cat_informative int Number of categorical columns that are informationally-related to the target variable 10 n_cats_per_col int Number of categories per categorical column 10 imbalance float Imbalance between the number of observations of each category in an individual categorical column. The default value of 0 will generate the same number of observations for each category within an individual categorical column. Increasing this value will result in a higher number of observations in some categories vs other categories. 0.0 noise float Noise to add to target variable 1.0 n_cont_cols int Number of continuous (non-categorical) columns to include in the generated data set 0 cont_weight float Weight of the effect of the continuous variables on the target variable 0.1 interactions float Proportion of the variance due to interaction effects. Note that this only adds interaction effects between the categorical features and not the continuous features. 0.0 random_state int random integer value used for reproducibility 32 Returns: Name Type Description X pandas DataFrame Synthetically-generated data set shape: (n_obs, n_cat_cols+n_cont_features) y pandas Series Target variable shape: (n_obs,) Source code in narrowgate/utils/test.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def make_regression_with_categoricals ( n_obs : int = 100 , n_cat_cols : int = 10 , n_cat_informative : int = 10 , n_cats_per_col : int = 10 , imbalance : float = 0.0 , noise : float = 1.0 , n_cont_cols : int = 0 , cont_weight : float = 0.1 , interactions : float = 0.0 , random_state : int = 32 ): \"\"\" Generates a regression-targeted data set with categorical features. **Note:** This code has been adapted from the code present within the blog post written by Brendan Hasz and available at the following URL: https://brendanhasz.github.io/2019/03/04/target-encoding.html#data As an enhancement, this funciton includes a `random_state` parameter which supports reproducibility. In addition, several parameter names have been changed to more closely align with naming conventions used within this package. Parameters ---------- n_obs: int Number of rows/observations in the synthetically-generated data set n_cat_cols: int Number of categorical columns to generate n_cat_informative: int Number of categorical columns that are informationally-related to the target variable n_cats_per_col: int Number of categories per categorical column imbalance: float Imbalance between the number of observations of each category in an individual categorical column. The default value of 0 will generate the same number of observations for each category within an individual categorical column. Increasing this value will result in a higher number of observations in some categories vs other categories. noise: float Noise to add to target variable n_cont_cols: int Number of continuous (non-categorical) columns to include in the generated data set cont_weight: float Weight of the effect of the continuous variables on the target variable interactions: float Proportion of the variance due to interaction effects. Note that this only adds interaction effects between the categorical features and not the continuous features. random_state: random integer value used for reproducibility Returns ------- X : pandas DataFrame Synthetically-generated data set shape: (n_obs, n_cat_cols+n_cont_features) y : pandas Series Target variable shape: (n_obs,) \"\"\" def beta_binomial ( n , a , b ): \"\"\" Beta-binomial probability mass function. \"\"\" from scipy.special import beta from scipy.misc import comb k = np . arange ( n + 1 ) return comb ( n , k ) * beta ( k + a , n - k + b ) / beta ( a , b ) if not isinstance ( n_obs , int ): raise TypeError ( 'n_obs must be an int' ) elif n_obs < 1 : raise ValueError ( 'n_obs must be one or greater' ) if not isinstance ( n_cat_cols , int ): raise TypeError ( 'n_cat_cols must be an int' ) elif n_cat_cols < 1 : raise ValueError ( 'n_cat_cols must be one or greater' ) if not isinstance ( n_cat_informative , int ): raise TypeError ( 'n_cat_informative must be an int' ) elif n_cat_informative < 0 : raise ValueError ( 'n_cat_informative must be non-negative' ) if not isinstance ( n_cats_per_col , int ): raise TypeError ( 'n_cats_per_col must be an int' ) if n_cats_per_col < 1 : raise ValueError ( 'n_cats_per_col must be one or greater' ) if not isinstance ( imbalance , float ): raise TypeError ( 'imbalance must be a float' ) elif imbalance < 0 : raise ValueError ( 'imbalance must be non-negative' ) if not isinstance ( noise , float ): raise TypeError ( 'noise must be a float' ) elif noise < 0 : raise ValueError ( 'noise must be positive' ) if not isinstance ( n_cont_features , int ): raise TypeError ( 'n_cont_features must be an int' ) elif n_cont_features < 0 : raise ValueError ( 'n_cont_features must be non-negative' ) if not isinstance ( cont_weight , float ): raise TypeError ( 'cont_weight must be a float' ) elif cont_weight < 0 : raise ValueError ( 'cont_weight must be non-negative' ) if not isinstance ( interactions , float ): raise TypeError ( 'interactions must be a float' ) elif interactions < 0 : raise ValueError ( 'interactions must be non-negative' ) rng = np . random . default_rng ( seed = random_state ) # Generate random categorical data # category probabilities are drawn from a beta-binomial distribution # with alpha=1 and beta=imbalance+1 cat_probs = beta_binomial ( n_cats_per_col - 1 , 1.0 , imbalance + 1 ) categories = np . empty (( n_obs , n_cat_cols ), dtype = 'uint64' ) for iC in range ( n_cat_cols ): categories [:, iC ] = rng . random . choice ( np . arange ( n_cats_per_col ), size = n_obs , p = cat_probs ) # Generate random values for each category cat_vals = rng . random . randn ( n_cats_per_col , n_cat_cols ) # Set non-informative columns' effect to 0 cat_vals [:,:( n_cat_cols - n_cat_informative )] = 0 # Compute target variable from categories and their values y = np . zeros ( n_obs ) for iC in range ( n_cat_cols ): y += ( 1.0 - interactions ) * cat_vals [ categories [:, iC ], iC ] # Add interaction effects if interactions > 0 : for iC1 in range ( n_cat_informative ): for iC2 in range ( iC1 + 1 , n_cat_informative ): int_vals = rng . random . randn ( n_cats_per_col , n_cats_per_col ) y += interactions * int_vals [ categories [:, iC1 ], categories [:, iC2 ]] # Add noise y += noise * rng . random . randn ( n_obs ) # Generate dataframe from categories cat_strs = [ '' . join ([ chr ( ord ( c ) + 49 ) for c in str ( n )]) for n in range ( n_cats_per_col )] X = pd . DataFrame () for iC in range ( n_cat_cols ): col_str = 'categorical_' + str ( iC ) X [ col_str ] = [ cat_strs [ i ] for i in categories [:, iC ]] # Add continuous features for iC in range ( n_cont_features ): col_str = 'continuous_' + str ( iC ) X [ col_str ] = cont_weight * rng . random . randn ( n_obs ) y += rng . random . randn () * X [ col_str ] # Generate series from target y = pd . Series ( data = y , index = X . index ) # Return features and target return X , y","title":"make_regression_with_categoricals()"},{"location":"utils/validation/","text":"The following functions perform some basic validation of input and target variables used by the various screening classes implemented within the package. Pandas and Numpy objects are validated and prepared for processing and, ultimately, results reporting. validate_pandas_inputs \u00a4 validate_pandas_inputs ( X , y = None ) Validation function for screening inputs. Validate X is a pandas DataFrame Validate y is one of the following: a string representing a column in X a numpy array having the same number of observations at X a pandas Series having the same index as X Once validated, X and y will be returned as 'raw' numpy ndarray objects along with column names and target name. Parameters: Name Type Description Default X pd . DataFrame pandas DataFrame of predictor variables required y Optional [ str , pd . Series , np . ndarray ] Valid options : str, numpy array, pandas Series, or None If str , represents a column in X whose values are to be used as a target variable. If np.array or pandas Series, values to be used as target variable. If None , then only X is validated. None Returns: Name Type Description X np.ndarray raw values of X X_cols list of str name of predictor variables (columns) in X y np.ndarray target values y_name str name of target variable Source code in narrowgate/utils/validation.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def validate_pandas_inputs ( X : pd . DataFrame , y : Optional [ str , pd . Series , np . ndarray ] = None ): \"\"\" Validation function for screening inputs. 1. Validate `X` is a pandas DataFrame 2. Validate `y` is one of the following: * a string representing a column in `X` * a numpy array having the same number of observations at `X` * a pandas Series having the same index as `X` Once validated, `X` and `y` will be returned as 'raw' numpy `ndarray` objects along with column names and target name. Parameters ---------- X : pandas DataFrame of predictor variables y : Valid options : str, numpy array, pandas Series, or None If `str`, represents a column in `X` whose values are to be used as a target variable. If np.array or pandas Series, values to be used as target variable. If `None`, then only `X` is validated. Returns ------- X : np.ndarray raw values of `X` X_cols : list of str name of predictor variables (columns) in `X` y : np.ndarray target values y_name : str name of target variable \"\"\" assert isinstance ( X , pd . DataFrame ) if not y is None : if isinstance ( y , pd . Series ) or isinstance ( y , np . ndarray ): if isinstance ( y , np . ndarray ): assert y . ndim == 1 assert y . shape [ 0 ] == X . shape [ 0 ] # if it is a numpy array then need to make it into a series # and assign a name to that series y_name = 'target' else : # verify that the two indices are the same pd . testing . assert_index_equal ( X . index , y . index ) # capture the name from the y pandas Series y_name = y . name y = y . values # add y into X so that it can be pre-processed correctly #X.insert(0, y_name, y.values)) elif isinstance ( y , str ): # make sure that 'y' is a column in X assert y in X . columns , \"The target column 'y' does not exist in 'X'!\" y_name = y y = X [ y ] . values X = X . filter ( items = [ col for col in X . columns if not col == y_name ]) else : raise TypeError ( f \"Unsupported type for 'y' ( { type ( y ) } )\" ) # Return raw_data and column names return X . values , y , list ( X . columns ), y_name else : return X . values , list ( X . columns ) validate_numpy_inputs \u00a4 validate_numpy_inputs ( X , y ) Numpy input validation function for screening inputs. Validates both X and y are numpy matrices/arrays with same number of observations. Once validated, 'y' will be joined to 'X' (if necessary) The (potentially) modified X will be returned by the function along with the 'name' of y (target). Column names and target variable name will be automatically generated as no column information is present in the raw numpy arrays Parameters: Name Type Description Default X np . ndarray numpy array of predictor variables required y np . ndarray numpy array of target variable values required Returns: Name Type Description X np.ndarray raw values in X after validation X_cols list of str automatically-generated predictor variable names for X y np.ndarray target values y_name str automatically-generated target variable name for y Source code in narrowgate/utils/validation.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def validate_numpy_inputs ( X : np . ndarray , y : np . ndarray ): \"\"\" Numpy input validation function for screening inputs. Validates both `X` and `y` are numpy matrices/arrays with same number of observations. Once validated, 'y' will be joined to 'X' (if necessary) The (potentially) modified `X` will be returned by the function along with the 'name' of `y` (target). Column names and target variable name will be automatically generated as no column information is present in the raw numpy arrays Parameters ---------- X : numpy array of predictor variables y : numpy array of target variable values Returns ------- X : np.ndarray raw values in `X` after validation X_cols : list of str automatically-generated predictor variable names for `X` y : np.ndarray target values y_name : str automatically-generated target variable name for `y` \"\"\" if isinstance ( y , np . ndarray ): assert y . ndim == 1 assert y . shape [ 0 ] == X . shape [ 0 ] # if it is a numpy array then need to make it into a series # and assign a name to that series y_name = 'y_auto' X_cols = [ f 'var { i } ' for i in range ( X . shape [ 1 ])] else : raise TypeError ( f \"Unsupported type for 'y' ( { type ( y ) } )\" ) # Return raw_data and column names return X , y , X_cols , y_name","title":"Validation"},{"location":"utils/validation/#narrowgate.utils.validation.validate_pandas_inputs","text":"validate_pandas_inputs ( X , y = None ) Validation function for screening inputs. Validate X is a pandas DataFrame Validate y is one of the following: a string representing a column in X a numpy array having the same number of observations at X a pandas Series having the same index as X Once validated, X and y will be returned as 'raw' numpy ndarray objects along with column names and target name. Parameters: Name Type Description Default X pd . DataFrame pandas DataFrame of predictor variables required y Optional [ str , pd . Series , np . ndarray ] Valid options : str, numpy array, pandas Series, or None If str , represents a column in X whose values are to be used as a target variable. If np.array or pandas Series, values to be used as target variable. If None , then only X is validated. None Returns: Name Type Description X np.ndarray raw values of X X_cols list of str name of predictor variables (columns) in X y np.ndarray target values y_name str name of target variable Source code in narrowgate/utils/validation.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def validate_pandas_inputs ( X : pd . DataFrame , y : Optional [ str , pd . Series , np . ndarray ] = None ): \"\"\" Validation function for screening inputs. 1. Validate `X` is a pandas DataFrame 2. Validate `y` is one of the following: * a string representing a column in `X` * a numpy array having the same number of observations at `X` * a pandas Series having the same index as `X` Once validated, `X` and `y` will be returned as 'raw' numpy `ndarray` objects along with column names and target name. Parameters ---------- X : pandas DataFrame of predictor variables y : Valid options : str, numpy array, pandas Series, or None If `str`, represents a column in `X` whose values are to be used as a target variable. If np.array or pandas Series, values to be used as target variable. If `None`, then only `X` is validated. Returns ------- X : np.ndarray raw values of `X` X_cols : list of str name of predictor variables (columns) in `X` y : np.ndarray target values y_name : str name of target variable \"\"\" assert isinstance ( X , pd . DataFrame ) if not y is None : if isinstance ( y , pd . Series ) or isinstance ( y , np . ndarray ): if isinstance ( y , np . ndarray ): assert y . ndim == 1 assert y . shape [ 0 ] == X . shape [ 0 ] # if it is a numpy array then need to make it into a series # and assign a name to that series y_name = 'target' else : # verify that the two indices are the same pd . testing . assert_index_equal ( X . index , y . index ) # capture the name from the y pandas Series y_name = y . name y = y . values # add y into X so that it can be pre-processed correctly #X.insert(0, y_name, y.values)) elif isinstance ( y , str ): # make sure that 'y' is a column in X assert y in X . columns , \"The target column 'y' does not exist in 'X'!\" y_name = y y = X [ y ] . values X = X . filter ( items = [ col for col in X . columns if not col == y_name ]) else : raise TypeError ( f \"Unsupported type for 'y' ( { type ( y ) } )\" ) # Return raw_data and column names return X . values , y , list ( X . columns ), y_name else : return X . values , list ( X . columns )","title":"validate_pandas_inputs()"},{"location":"utils/validation/#narrowgate.utils.validation.validate_numpy_inputs","text":"validate_numpy_inputs ( X , y ) Numpy input validation function for screening inputs. Validates both X and y are numpy matrices/arrays with same number of observations. Once validated, 'y' will be joined to 'X' (if necessary) The (potentially) modified X will be returned by the function along with the 'name' of y (target). Column names and target variable name will be automatically generated as no column information is present in the raw numpy arrays Parameters: Name Type Description Default X np . ndarray numpy array of predictor variables required y np . ndarray numpy array of target variable values required Returns: Name Type Description X np.ndarray raw values in X after validation X_cols list of str automatically-generated predictor variable names for X y np.ndarray target values y_name str automatically-generated target variable name for y Source code in narrowgate/utils/validation.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def validate_numpy_inputs ( X : np . ndarray , y : np . ndarray ): \"\"\" Numpy input validation function for screening inputs. Validates both `X` and `y` are numpy matrices/arrays with same number of observations. Once validated, 'y' will be joined to 'X' (if necessary) The (potentially) modified `X` will be returned by the function along with the 'name' of `y` (target). Column names and target variable name will be automatically generated as no column information is present in the raw numpy arrays Parameters ---------- X : numpy array of predictor variables y : numpy array of target variable values Returns ------- X : np.ndarray raw values in `X` after validation X_cols : list of str automatically-generated predictor variable names for `X` y : np.ndarray target values y_name : str automatically-generated target variable name for `y` \"\"\" if isinstance ( y , np . ndarray ): assert y . ndim == 1 assert y . shape [ 0 ] == X . shape [ 0 ] # if it is a numpy array then need to make it into a series # and assign a name to that series y_name = 'y_auto' X_cols = [ f 'var { i } ' for i in range ( X . shape [ 1 ])] else : raise TypeError ( f \"Unsupported type for 'y' ( { type ( y ) } )\" ) # Return raw_data and column names return X , y , X_cols , y_name","title":"validate_numpy_inputs()"}]}